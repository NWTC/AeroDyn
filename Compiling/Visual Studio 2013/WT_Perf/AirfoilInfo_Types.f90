!STARTOFREGISTRYGENERATEDFILE './AirfoilInfo_Types.f90'
!
! WARNING This file is generated automatically by the FAST registry
! Do not edit.  Your changes to this file will be lost.
!
! FAST Registry (v2.05.00, 10-Jan-2015)
!*********************************************************************************************************************************
! AirfoilInfo_Types
!.................................................................................................................................
! This file is part of AirfoilInfo.
!
! Copyright (C) 2012-2015 National Renewable Energy Laboratory
!
! Licensed under the Apache License, Version 2.0 (the "License");
! you may not use this file except in compliance with the License.
! You may obtain a copy of the License at
!
!     http://www.apache.org/licenses/LICENSE-2.0
!
! Unless required by applicable law or agreed to in writing, software
! distributed under the License is distributed on an "AS IS" BASIS,
! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
! See the License for the specific language governing permissions and
! limitations under the License.
!
!
! W A R N I N G : This file was automatically generated from the FAST registry.  Changes made to this file may be lost.
!
!*********************************************************************************************************************************
MODULE AirfoilInfo_Types
! This module contains all of the user-defined types needed in AirfoilInfo. It also contains copy, destroy, pack, and
! unpack routines associated with each defined data type. This code will be generated by the FAST Registry.
!---------------------------------------------------------------------------------------------------------------------------------
USE NWTC_Library
IMPLICIT NONE
! =========  AFI_UA_BL_Type  =======
  TYPE, PUBLIC :: AFI_UA_BL_Type
    REAL(ReKi)  :: BL_AOD      ! Angle of attack for minimum Cd (used for Beddoes-Leishman unsteady aero) [degrees]
    REAL(ReKi)  :: BL_AOL      ! Angle of attack for zero lift (used for Beddoes-Leishman unsteady aero) [degrees]
    REAL(ReKi)  :: BL_Cd0      ! Minimum Cd value (used for Beddoes-Leishman unsteady aero) [degrees]
    REAL(ReKi)  :: BL_CnA      ! Cn slope for zero lift (used for Beddoes-Leishman unsteady aero) [-]
    REAL(ReKi)  :: BL_CnS      ! Cn at stall value for positive angle of attack (used for Beddoes-Leishman unsteady aero) [-]
    REAL(ReKi)  :: BL_CnSL      ! Cn at stall value for negative angle (used for Beddoes-Leishman unsteady aero) [-]
  END TYPE AFI_UA_BL_Type
! =======================
! =========  AFI_Table_Type  =======
  TYPE, PUBLIC :: AFI_Table_Type
    REAL(SiKi) , DIMENSION(:), ALLOCATABLE  :: Alpha      ! Angle-of-attack vector that matches the Coefs matrix [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: Coefs      ! Airfoil coefficients for Cd, Cl,  and maybe Cm and/or Cpmin [-]
    REAL(ReKi) , DIMENSION(:,:,:), ALLOCATABLE  :: SplineCoefs      ! Spline coefficients for Cd, Cl,  and maybe Cm and/or Cpmin [-]
    REAL(ReKi) , DIMENSION(:,:,:,:), ALLOCATABLE  :: BEMT_Spline      ! Spline coefficients for Cd, Cl for the two bounding Re when doing BEM [-]
    REAL(ReKi)  :: Ctrl      ! Control setting [user-specified]
    REAL(ReKi)  :: Re      ! Reynolds numbers in millions [-]
    INTEGER(IntKi)  :: NumAlf      ! Length of the Alpha and Coefs arrays [-]
    LOGICAL  :: ConstData      ! Flag that tells if aerodynamic coefficients are the same for all alphas [-]
    LOGICAL  :: InclUAdata      ! Flag that tells if UA data is included in the input file [-]
    INTEGER(IntKi)  :: UA_Model      ! Length of the Alpha and Coefs arrays [-]
    TYPE(AFI_UA_BL_Type)  :: UA_BL      ! The tables of Leishman-Beddoes unsteady-aero data for given Re and control setting [-]
  END TYPE AFI_Table_Type
! =======================
! =========  AFInfoType  =======
  TYPE, PUBLIC :: AFInfoType
    REAL(ReKi)  :: NonDimArea      ! The non-dimensional area of the airfoil (area/chord^2) [-]
    REAL(SiKi) , DIMENSION(:), ALLOCATABLE  :: CdAoAknots      ! Spline knots for the angle of attack for Cd [-]
    REAL(SiKi) , DIMENSION(:), ALLOCATABLE  :: CdReKnots      ! Spline knots for the Re for Cd [-]
    REAL(SiKi) , DIMENSION(:), ALLOCATABLE  :: ClAoAknots      ! Spline knots for the angle of attack for Cl [-]
    REAL(SiKi) , DIMENSION(:), ALLOCATABLE  :: ClReKnots      ! Spline knots for the Re for Cl [-]
    REAL(SiKi) , DIMENSION(:), ALLOCATABLE  :: CmAoAknots      ! Spline knots for the angle of attack for Cm [-]
    REAL(SiKi) , DIMENSION(:), ALLOCATABLE  :: CmReKnots      ! Spline knots for the Re for Cm [-]
    REAL(SiKi) , DIMENSION(:), ALLOCATABLE  :: CpminAoAknots      ! Spline knots for the angle of attack for Cpmin [-]
    REAL(SiKi) , DIMENSION(:), ALLOCATABLE  :: CpminReKnots      ! Spline knots for the Re for Cpmin [-]
    REAL(SiKi) , DIMENSION(:), ALLOCATABLE  :: LogRe      ! An array storing the LN(Re) for all the tables in a file [-]
    REAL(SiKi) , DIMENSION(:,:), ALLOCATABLE  :: ReKnots      ! Spline knots for the logs of the Reynolds numbers [-]
    REAL(SiKi) , DIMENSION(:), ALLOCATABLE  :: CdSpCoef2D      ! The spline coefficients for bicubic-spline interpolation of Cd data [-]
    REAL(SiKi) , DIMENSION(:), ALLOCATABLE  :: ClSpCoef2D      ! The spline coefficients for bicubic-spline interpolation of Cl data [-]
    REAL(SiKi) , DIMENSION(:), ALLOCATABLE  :: CmSpCoef2D      ! The spline coefficients for bicubic-spline interpolation of Cm data [-]
    REAL(SiKi) , DIMENSION(:), ALLOCATABLE  :: CpminSpCoef2D      ! The spline coefficients for bicubic-spline interpolation of Cpmin data [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: X_Coord      ! X-coordinate for the airfoil shape [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: Y_Coord      ! Y-coordinate for the airfoil shape [-]
    INTEGER(IntKi) , DIMENSION(:), ALLOCATABLE  :: MaxAoAknots      ! The maximum number of angle-of-attack knots for 2D splines; essentially the dimension of the array [-]
    INTEGER(IntKi) , DIMENSION(:), ALLOCATABLE  :: MaxReKnots      ! The maximum number of Re knots for 2D splines; essentially the dimension of the array [-]
    INTEGER(IntKi)  :: NumCdAoAkts      ! The number of angle-of-attack knots for 2D splines of Cd [-]
    INTEGER(IntKi)  :: NumCdReKts      ! The number of log(Re) knots for 2D splines of Cd [-]
    INTEGER(IntKi)  :: NumClAoAkts      ! The number of angle-of-attack knots for 2D splines of Cl [-]
    INTEGER(IntKi)  :: NumClReKts      ! The number of log(Re) knots for 2D splines of Cl [-]
    INTEGER(IntKi)  :: NumCmAoAkts      ! The number of angle-of-attack knots for 2D splines of Cm [-]
    INTEGER(IntKi)  :: NumCmReKts      ! The number of log(Re) knots for 2D splines of Cm [-]
    INTEGER(IntKi)  :: NumCoords      ! The number of coordinates in the airfoil-shape table [-]
    INTEGER(IntKi)  :: NumCpminAoAkts      ! The number of angle-of-attack knots for 2D splines of Cpmin [-]
    INTEGER(IntKi)  :: NumCpminReKts      ! The number of log(Re) knots for 2D splines of Cpmin [-]
    INTEGER(IntKi)  :: NumTabs      ! The number of airfoil tables in the airfoil file [-]
    TYPE(AFI_Table_Type) , DIMENSION(:), ALLOCATABLE  :: Table      ! The tables of airfoil data for given Re and control setting [-]
  END TYPE AFInfoType
! =======================
! =========  AFI_InitInputType  =======
  TYPE, PUBLIC :: AFI_InitInputType
    INTEGER(IntKi)  :: NumAFfiles      ! The number of airfoil files [-]
    CHARACTER(1024) , DIMENSION(:), ALLOCATABLE  :: FileNames      ! The name of the file the data were read from [-]
    INTEGER(IntKi)  :: UA_Model      ! The type of unsteady aero model (1-Beddoes-Leishman) [-]
    INTEGER(IntKi)  :: NumCoefs      ! The number of aerodynamic coefficients to be stored in the coefficients arrays [-]
    INTEGER(IntKi)  :: InCol_Alfa      ! The column of the coefficient tables that holds the angle of attack [-]
    INTEGER(IntKi)  :: InCol_Cl      ! The column of the coefficient tables that holds the lift coefficient [-]
    INTEGER(IntKi)  :: InCol_Cd      ! The column of the coefficient tables that holds the minimum pressure coefficient [-]
    INTEGER(IntKi)  :: InCol_Cm      ! The column of the coefficient tables that holds the pitching-moment coefficient [-]
    INTEGER(IntKi)  :: InCol_Cpmin      ! The column of the coefficient tables that holds the minimum pressure coefficient [-]
  END TYPE AFI_InitInputType
! =======================
! =========  AFI_InitOutputType  =======
  TYPE, PUBLIC :: AFI_InitOutputType
    TYPE(ProgDesc)  :: Ver      ! This module's name, version, and date [-]
  END TYPE AFI_InitOutputType
! =======================
! =========  AFI_ContinuousStateType  =======
  TYPE, PUBLIC :: AFI_ContinuousStateType
    REAL(ReKi)  :: DummyContState      ! Remove this variable if you have continuous states [-]
  END TYPE AFI_ContinuousStateType
! =======================
! =========  AFI_DiscreteStateType  =======
  TYPE, PUBLIC :: AFI_DiscreteStateType
    REAL(ReKi)  :: DummyDiscState      ! Remove this variable if you have discrete states [-]
  END TYPE AFI_DiscreteStateType
! =======================
! =========  AFI_ConstraintStateType  =======
  TYPE, PUBLIC :: AFI_ConstraintStateType
    REAL(ReKi)  :: DummyConstrState      ! Remove this variable if you have constraint states [-]
  END TYPE AFI_ConstraintStateType
! =======================
! =========  AFI_OtherStateType  =======
  TYPE, PUBLIC :: AFI_OtherStateType
    LOGICAL  :: IntCl      ! A flag telling AFI to interpolate the lift cofficient this call [-]
    LOGICAL  :: IntCd      ! A flag telling AFI to interpolate the drag cofficient this call [-]
    LOGICAL  :: IntCm      ! A flag telling AFI to interpolate the pitching moment cofficient this call [-]
    LOGICAL  :: IntCpmin      ! A flag telling AFI to interpolate the minimum pressure cofficient this call [-]
    INTEGER(IntKi)  :: AFfile      ! The number of the airfoil file that applies to the current node [-]
  END TYPE AFI_OtherStateType
! =======================
! =========  AFI_ParameterType  =======
  TYPE, PUBLIC :: AFI_ParameterType
    INTEGER(IntKi)  :: ColCd      ! The column in the Coefs arrays that contains Cd data [-]
    INTEGER(IntKi)  :: ColCl      ! The column in the Coefs arrays that contains Cl data [-]
    INTEGER(IntKi)  :: ColCm      ! The column in the Coefs arrays that contains Cm data [-]
    INTEGER(IntKi)  :: ColCpmin      ! The column in the Coefs arrays that contains Cpmin data [-]
    TYPE(AFInfoType) , DIMENSION(:), ALLOCATABLE  :: AFInfo      ! The [derived]
  END TYPE AFI_ParameterType
! =======================
! =========  AFI_InputType  =======
  TYPE, PUBLIC :: AFI_InputType
    REAL(ReKi)  :: AoA      ! The angle of attack [radians]
    REAL(ReKi)  :: Ctrl      ! The user-defined control setting [-]
    REAL(ReKi)  :: Re      ! Reynolds number [millions]
  END TYPE AFI_InputType
! =======================
! =========  AFI_OutputType  =======
  TYPE, PUBLIC :: AFI_OutputType
    REAL(ReKi)  :: Cl      ! Dimensionless coefficient of lift [-]
    REAL(ReKi)  :: Cd      ! Dimensionless coefficient of drag [-]
    REAL(ReKi)  :: Cm      ! Dimensionless coefficient of pitching moment [-]
    REAL(ReKi)  :: Cpmin      ! Dimensionless coefficient of minimum pressure [-]
  END TYPE AFI_OutputType
! =======================
CONTAINS
 SUBROUTINE AFI_CopyUA_BL_Type( SrcUA_BL_TypeData, DstUA_BL_TypeData, CtrlCode, ErrStat, ErrMsg )
   TYPE(AFI_UA_BL_Type), INTENT(IN) :: SrcUA_BL_TypeData
   TYPE(AFI_UA_BL_Type), INTENT(INOUT) :: DstUA_BL_TypeData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: i2, i2_l, i2_u  !  bounds (upper/lower) for an array dimension 2
   INTEGER(IntKi)                 :: i3, i3_l, i3_u  !  bounds (upper/lower) for an array dimension 3
   INTEGER(IntKi)                 :: i4, i4_l, i4_u  !  bounds (upper/lower) for an array dimension 4
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(1024)                :: ErrMsg2
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
   DstUA_BL_TypeData%BL_AOD = SrcUA_BL_TypeData%BL_AOD
   DstUA_BL_TypeData%BL_AOL = SrcUA_BL_TypeData%BL_AOL
   DstUA_BL_TypeData%BL_Cd0 = SrcUA_BL_TypeData%BL_Cd0
   DstUA_BL_TypeData%BL_CnA = SrcUA_BL_TypeData%BL_CnA
   DstUA_BL_TypeData%BL_CnS = SrcUA_BL_TypeData%BL_CnS
   DstUA_BL_TypeData%BL_CnSL = SrcUA_BL_TypeData%BL_CnSL
 END SUBROUTINE AFI_CopyUA_BL_Type

 SUBROUTINE AFI_DestroyUA_BL_Type( UA_BL_TypeData, ErrStat, ErrMsg )
  TYPE(AFI_UA_BL_Type), INTENT(INOUT) :: UA_BL_TypeData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
 END SUBROUTINE AFI_DestroyUA_BL_Type

 SUBROUTINE AFI_PackUA_BL_Type( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(AFI_UA_BL_Type),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  Re_BufSz   = Re_BufSz   + 1  ! BL_AOD
  Re_BufSz   = Re_BufSz   + 1  ! BL_AOL
  Re_BufSz   = Re_BufSz   + 1  ! BL_Cd0
  Re_BufSz   = Re_BufSz   + 1  ! BL_CnA
  Re_BufSz   = Re_BufSz   + 1  ! BL_CnS
  Re_BufSz   = Re_BufSz   + 1  ! BL_CnSL
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%BL_AOD )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%BL_AOL )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%BL_Cd0 )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%BL_CnA )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%BL_CnS )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%BL_CnSL )
  Re_Xferred   = Re_Xferred   + 1
 END SUBROUTINE AFI_PackUA_BL_Type

 SUBROUTINE AFI_UnPackUA_BL_Type( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(AFI_UA_BL_Type), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  OutData%BL_AOD = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%BL_AOL = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%BL_Cd0 = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%BL_CnA = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%BL_CnS = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%BL_CnSL = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE AFI_UnPackUA_BL_Type

 SUBROUTINE AFI_CopyTable_Type( SrcTable_TypeData, DstTable_TypeData, CtrlCode, ErrStat, ErrMsg )
   TYPE(AFI_Table_Type), INTENT(IN) :: SrcTable_TypeData
   TYPE(AFI_Table_Type), INTENT(INOUT) :: DstTable_TypeData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: i2, i2_l, i2_u  !  bounds (upper/lower) for an array dimension 2
   INTEGER(IntKi)                 :: i3, i3_l, i3_u  !  bounds (upper/lower) for an array dimension 3
   INTEGER(IntKi)                 :: i4, i4_l, i4_u  !  bounds (upper/lower) for an array dimension 4
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(1024)                :: ErrMsg2
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
IF (ALLOCATED(SrcTable_TypeData%Alpha)) THEN
   i1_l = LBOUND(SrcTable_TypeData%Alpha,1)
   i1_u = UBOUND(SrcTable_TypeData%Alpha,1)
   IF (.NOT. ALLOCATED(DstTable_TypeData%Alpha)) THEN 
      ALLOCATE(DstTable_TypeData%Alpha(i1_l:i1_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstTable_TypeData%Alpha.', ErrStat, ErrMsg,'AFI_CopyTable_Type')
         RETURN
      END IF
   END IF
   DstTable_TypeData%Alpha = SrcTable_TypeData%Alpha
ENDIF
IF (ALLOCATED(SrcTable_TypeData%Coefs)) THEN
   i1_l = LBOUND(SrcTable_TypeData%Coefs,1)
   i1_u = UBOUND(SrcTable_TypeData%Coefs,1)
   i2_l = LBOUND(SrcTable_TypeData%Coefs,2)
   i2_u = UBOUND(SrcTable_TypeData%Coefs,2)
   IF (.NOT. ALLOCATED(DstTable_TypeData%Coefs)) THEN 
      ALLOCATE(DstTable_TypeData%Coefs(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstTable_TypeData%Coefs.', ErrStat, ErrMsg,'AFI_CopyTable_Type')
         RETURN
      END IF
   END IF
   DstTable_TypeData%Coefs = SrcTable_TypeData%Coefs
ENDIF
IF (ALLOCATED(SrcTable_TypeData%SplineCoefs)) THEN
   i1_l = LBOUND(SrcTable_TypeData%SplineCoefs,1)
   i1_u = UBOUND(SrcTable_TypeData%SplineCoefs,1)
   i2_l = LBOUND(SrcTable_TypeData%SplineCoefs,2)
   i2_u = UBOUND(SrcTable_TypeData%SplineCoefs,2)
   i3_l = LBOUND(SrcTable_TypeData%SplineCoefs,3)
   i3_u = UBOUND(SrcTable_TypeData%SplineCoefs,3)
   IF (.NOT. ALLOCATED(DstTable_TypeData%SplineCoefs)) THEN 
      ALLOCATE(DstTable_TypeData%SplineCoefs(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstTable_TypeData%SplineCoefs.', ErrStat, ErrMsg,'AFI_CopyTable_Type')
         RETURN
      END IF
   END IF
   DstTable_TypeData%SplineCoefs = SrcTable_TypeData%SplineCoefs
ENDIF
IF (ALLOCATED(SrcTable_TypeData%BEMT_Spline)) THEN
   i1_l = LBOUND(SrcTable_TypeData%BEMT_Spline,1)
   i1_u = UBOUND(SrcTable_TypeData%BEMT_Spline,1)
   i2_l = LBOUND(SrcTable_TypeData%BEMT_Spline,2)
   i2_u = UBOUND(SrcTable_TypeData%BEMT_Spline,2)
   i3_l = LBOUND(SrcTable_TypeData%BEMT_Spline,3)
   i3_u = UBOUND(SrcTable_TypeData%BEMT_Spline,3)
   i4_l = LBOUND(SrcTable_TypeData%BEMT_Spline,4)
   i4_u = UBOUND(SrcTable_TypeData%BEMT_Spline,4)
   IF (.NOT. ALLOCATED(DstTable_TypeData%BEMT_Spline)) THEN 
      ALLOCATE(DstTable_TypeData%BEMT_Spline(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u,i4_l:i4_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstTable_TypeData%BEMT_Spline.', ErrStat, ErrMsg,'AFI_CopyTable_Type')
         RETURN
      END IF
   END IF
   DstTable_TypeData%BEMT_Spline = SrcTable_TypeData%BEMT_Spline
ENDIF
   DstTable_TypeData%Ctrl = SrcTable_TypeData%Ctrl
   DstTable_TypeData%Re = SrcTable_TypeData%Re
   DstTable_TypeData%NumAlf = SrcTable_TypeData%NumAlf
   DstTable_TypeData%ConstData = SrcTable_TypeData%ConstData
   DstTable_TypeData%InclUAdata = SrcTable_TypeData%InclUAdata
   DstTable_TypeData%UA_Model = SrcTable_TypeData%UA_Model
      CALL AFI_Copyua_bl_type( SrcTable_TypeData%UA_BL, DstTable_TypeData%UA_BL, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,'AFI_CopyTable_Type:UA_BL')
         IF (ErrStat>=AbortErrLev) RETURN
 END SUBROUTINE AFI_CopyTable_Type

 SUBROUTINE AFI_DestroyTable_Type( Table_TypeData, ErrStat, ErrMsg )
  TYPE(AFI_Table_Type), INTENT(INOUT) :: Table_TypeData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
IF (ALLOCATED(Table_TypeData%Alpha)) THEN
   DEALLOCATE(Table_TypeData%Alpha)
ENDIF
IF (ALLOCATED(Table_TypeData%Coefs)) THEN
   DEALLOCATE(Table_TypeData%Coefs)
ENDIF
IF (ALLOCATED(Table_TypeData%SplineCoefs)) THEN
   DEALLOCATE(Table_TypeData%SplineCoefs)
ENDIF
IF (ALLOCATED(Table_TypeData%BEMT_Spline)) THEN
   DEALLOCATE(Table_TypeData%BEMT_Spline)
ENDIF
  CALL AFI_Destroyua_bl_type( Table_TypeData%UA_BL, ErrStat, ErrMsg )
 END SUBROUTINE AFI_DestroyTable_Type

 SUBROUTINE AFI_PackTable_Type( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(AFI_Table_Type),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  REAL(ReKi),     ALLOCATABLE :: Re_UA_BL_Buf(:)
  REAL(DbKi),     ALLOCATABLE :: Db_UA_BL_Buf(:)
  INTEGER(IntKi), ALLOCATABLE :: Int_UA_BL_Buf(:)
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  IF ( ALLOCATED(InData%Alpha) )   Re_BufSz    = Re_BufSz    + SIZE( InData%Alpha )  ! Alpha 
  IF ( ALLOCATED(InData%Coefs) )   Re_BufSz    = Re_BufSz    + SIZE( InData%Coefs )  ! Coefs 
  IF ( ALLOCATED(InData%SplineCoefs) )   Re_BufSz    = Re_BufSz    + SIZE( InData%SplineCoefs )  ! SplineCoefs 
  IF ( ALLOCATED(InData%BEMT_Spline) )   Re_BufSz    = Re_BufSz    + SIZE( InData%BEMT_Spline )  ! BEMT_Spline 
  Re_BufSz   = Re_BufSz   + 1  ! Ctrl
  Re_BufSz   = Re_BufSz   + 1  ! Re
  Int_BufSz  = Int_BufSz  + 1  ! NumAlf
  Int_BufSz  = Int_BufSz  + 1  ! ConstData
  Int_BufSz  = Int_BufSz  + 1  ! InclUAdata
  Int_BufSz  = Int_BufSz  + 1  ! UA_Model
  CALL AFI_Packua_bl_type( Re_UA_BL_Buf, Db_UA_BL_Buf, Int_UA_BL_Buf, InData%UA_BL, ErrStat, ErrMsg, .TRUE. ) ! UA_BL 
  IF(ALLOCATED(Re_UA_BL_Buf)) Re_BufSz  = Re_BufSz  + SIZE( Re_UA_BL_Buf  ) ! UA_BL
  IF(ALLOCATED(Db_UA_BL_Buf)) Db_BufSz  = Db_BufSz  + SIZE( Db_UA_BL_Buf  ) ! UA_BL
  IF(ALLOCATED(Int_UA_BL_Buf))Int_BufSz = Int_BufSz + SIZE( Int_UA_BL_Buf ) ! UA_BL
  IF(ALLOCATED(Re_UA_BL_Buf))  DEALLOCATE(Re_UA_BL_Buf)
  IF(ALLOCATED(Db_UA_BL_Buf))  DEALLOCATE(Db_UA_BL_Buf)
  IF(ALLOCATED(Int_UA_BL_Buf)) DEALLOCATE(Int_UA_BL_Buf)
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  IF ( ALLOCATED(InData%Alpha) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%Alpha))-1 ) =  PACK(InData%Alpha ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%Alpha)
  ENDIF
  IF ( ALLOCATED(InData%Coefs) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%Coefs))-1 ) =  PACK(InData%Coefs ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%Coefs)
  ENDIF
  IF ( ALLOCATED(InData%SplineCoefs) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%SplineCoefs))-1 ) =  PACK(InData%SplineCoefs ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%SplineCoefs)
  ENDIF
  IF ( ALLOCATED(InData%BEMT_Spline) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%BEMT_Spline))-1 ) =  PACK(InData%BEMT_Spline ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%BEMT_Spline)
  ENDIF
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%Ctrl )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%Re )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%NumAlf )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = TRANSFER( (InData%ConstData ), IntKiBuf(1), 1)
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = TRANSFER( (InData%InclUAdata ), IntKiBuf(1), 1)
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%UA_Model )
  Int_Xferred   = Int_Xferred   + 1
  CALL AFI_Packua_bl_type( Re_UA_BL_Buf, Db_UA_BL_Buf, Int_UA_BL_Buf, InData%UA_BL, ErrStat, ErrMsg, OnlySize ) ! UA_BL 
  IF(ALLOCATED(Re_UA_BL_Buf)) THEN
    IF ( .NOT. OnlySize ) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_UA_BL_Buf)-1 ) = Re_UA_BL_Buf
    Re_Xferred = Re_Xferred + SIZE(Re_UA_BL_Buf)
  ENDIF
  IF(ALLOCATED(Db_UA_BL_Buf)) THEN
    IF ( .NOT. OnlySize ) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_UA_BL_Buf)-1 ) = Db_UA_BL_Buf
    Db_Xferred = Db_Xferred + SIZE(Db_UA_BL_Buf)
  ENDIF
  IF(ALLOCATED(Int_UA_BL_Buf)) THEN
    IF ( .NOT. OnlySize ) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_UA_BL_Buf)-1 ) = Int_UA_BL_Buf
    Int_Xferred = Int_Xferred + SIZE(Int_UA_BL_Buf)
  ENDIF
  IF( ALLOCATED(Re_UA_BL_Buf) )  DEALLOCATE(Re_UA_BL_Buf)
  IF( ALLOCATED(Db_UA_BL_Buf) )  DEALLOCATE(Db_UA_BL_Buf)
  IF( ALLOCATED(Int_UA_BL_Buf) ) DEALLOCATE(Int_UA_BL_Buf)
 END SUBROUTINE AFI_PackTable_Type

 SUBROUTINE AFI_UnPackTable_Type( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(AFI_Table_Type), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
  REAL(ReKi),    ALLOCATABLE :: Re_UA_BL_Buf(:)
  REAL(DbKi),    ALLOCATABLE :: Db_UA_BL_Buf(:)
  INTEGER(IntKi),    ALLOCATABLE :: Int_UA_BL_Buf(:)
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  IF ( ALLOCATED(OutData%Alpha) ) THEN
  ALLOCATE(mask1(SIZE(OutData%Alpha,1)))
  mask1 = .TRUE.
    OutData%Alpha = REAL( UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%Alpha))-1 ),mask1,REAL(OutData%Alpha,ReKi)), SiKi)
  DEALLOCATE(mask1)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%Alpha)
  ENDIF
  IF ( ALLOCATED(OutData%Coefs) ) THEN
  ALLOCATE(mask2(SIZE(OutData%Coefs,1),SIZE(OutData%Coefs,2)))
  mask2 = .TRUE.
    OutData%Coefs = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%Coefs))-1 ),mask2,OutData%Coefs)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%Coefs)
  ENDIF
  IF ( ALLOCATED(OutData%SplineCoefs) ) THEN
  ALLOCATE(mask3(SIZE(OutData%SplineCoefs,1),SIZE(OutData%SplineCoefs,2),SIZE(OutData%SplineCoefs,3)))
  mask3 = .TRUE.
    OutData%SplineCoefs = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%SplineCoefs))-1 ),mask3,OutData%SplineCoefs)
  DEALLOCATE(mask3)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%SplineCoefs)
  ENDIF
  IF ( ALLOCATED(OutData%BEMT_Spline) ) THEN
  ALLOCATE(mask4(SIZE(OutData%BEMT_Spline,1),SIZE(OutData%BEMT_Spline,2),SIZE(OutData%BEMT_Spline,3),SIZE(OutData%BEMT_Spline,4)))
  mask4 = .TRUE.
    OutData%BEMT_Spline = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%BEMT_Spline))-1 ),mask4,OutData%BEMT_Spline)
  DEALLOCATE(mask4)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%BEMT_Spline)
  ENDIF
  OutData%Ctrl = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%Re = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%NumAlf = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%UA_Model = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
 ! first call AFI_Packua_bl_type to get correctly sized buffers for unpacking
  CALL AFI_Packua_bl_type( Re_UA_BL_Buf, Db_UA_BL_Buf, Int_UA_BL_Buf, OutData%UA_BL, ErrStat, ErrMsg, .TRUE. ) ! UA_BL 
  IF(ALLOCATED(Re_UA_BL_Buf)) THEN
    Re_UA_BL_Buf = ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_UA_BL_Buf)-1 )
    Re_Xferred = Re_Xferred + SIZE(Re_UA_BL_Buf)
  ENDIF
  IF(ALLOCATED(Db_UA_BL_Buf)) THEN
    Db_UA_BL_Buf = DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_UA_BL_Buf)-1 )
    Db_Xferred = Db_Xferred + SIZE(Db_UA_BL_Buf)
  ENDIF
  IF(ALLOCATED(Int_UA_BL_Buf)) THEN
    Int_UA_BL_Buf = IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_UA_BL_Buf)-1 )
    Int_Xferred = Int_Xferred + SIZE(Int_UA_BL_Buf)
  ENDIF
  CALL AFI_UnPackua_bl_type( Re_UA_BL_Buf, Db_UA_BL_Buf, Int_UA_BL_Buf, OutData%UA_BL, ErrStat, ErrMsg ) ! UA_BL 
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE AFI_UnPackTable_Type

 SUBROUTINE AFI_CopyAFInfoType( SrcAFInfoTypeData, DstAFInfoTypeData, CtrlCode, ErrStat, ErrMsg )
   TYPE(AFInfoType), INTENT(IN) :: SrcAFInfoTypeData
   TYPE(AFInfoType), INTENT(INOUT) :: DstAFInfoTypeData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: i2, i2_l, i2_u  !  bounds (upper/lower) for an array dimension 2
   INTEGER(IntKi)                 :: i3, i3_l, i3_u  !  bounds (upper/lower) for an array dimension 3
   INTEGER(IntKi)                 :: i4, i4_l, i4_u  !  bounds (upper/lower) for an array dimension 4
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(1024)                :: ErrMsg2
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
   DstAFInfoTypeData%NonDimArea = SrcAFInfoTypeData%NonDimArea
IF (ALLOCATED(SrcAFInfoTypeData%CdAoAknots)) THEN
   i1_l = LBOUND(SrcAFInfoTypeData%CdAoAknots,1)
   i1_u = UBOUND(SrcAFInfoTypeData%CdAoAknots,1)
   IF (.NOT. ALLOCATED(DstAFInfoTypeData%CdAoAknots)) THEN 
      ALLOCATE(DstAFInfoTypeData%CdAoAknots(i1_l:i1_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstAFInfoTypeData%CdAoAknots.', ErrStat, ErrMsg,'AFI_CopyAFInfoType')
         RETURN
      END IF
   END IF
   DstAFInfoTypeData%CdAoAknots = SrcAFInfoTypeData%CdAoAknots
ENDIF
IF (ALLOCATED(SrcAFInfoTypeData%CdReKnots)) THEN
   i1_l = LBOUND(SrcAFInfoTypeData%CdReKnots,1)
   i1_u = UBOUND(SrcAFInfoTypeData%CdReKnots,1)
   IF (.NOT. ALLOCATED(DstAFInfoTypeData%CdReKnots)) THEN 
      ALLOCATE(DstAFInfoTypeData%CdReKnots(i1_l:i1_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstAFInfoTypeData%CdReKnots.', ErrStat, ErrMsg,'AFI_CopyAFInfoType')
         RETURN
      END IF
   END IF
   DstAFInfoTypeData%CdReKnots = SrcAFInfoTypeData%CdReKnots
ENDIF
IF (ALLOCATED(SrcAFInfoTypeData%ClAoAknots)) THEN
   i1_l = LBOUND(SrcAFInfoTypeData%ClAoAknots,1)
   i1_u = UBOUND(SrcAFInfoTypeData%ClAoAknots,1)
   IF (.NOT. ALLOCATED(DstAFInfoTypeData%ClAoAknots)) THEN 
      ALLOCATE(DstAFInfoTypeData%ClAoAknots(i1_l:i1_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstAFInfoTypeData%ClAoAknots.', ErrStat, ErrMsg,'AFI_CopyAFInfoType')
         RETURN
      END IF
   END IF
   DstAFInfoTypeData%ClAoAknots = SrcAFInfoTypeData%ClAoAknots
ENDIF
IF (ALLOCATED(SrcAFInfoTypeData%ClReKnots)) THEN
   i1_l = LBOUND(SrcAFInfoTypeData%ClReKnots,1)
   i1_u = UBOUND(SrcAFInfoTypeData%ClReKnots,1)
   IF (.NOT. ALLOCATED(DstAFInfoTypeData%ClReKnots)) THEN 
      ALLOCATE(DstAFInfoTypeData%ClReKnots(i1_l:i1_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstAFInfoTypeData%ClReKnots.', ErrStat, ErrMsg,'AFI_CopyAFInfoType')
         RETURN
      END IF
   END IF
   DstAFInfoTypeData%ClReKnots = SrcAFInfoTypeData%ClReKnots
ENDIF
IF (ALLOCATED(SrcAFInfoTypeData%CmAoAknots)) THEN
   i1_l = LBOUND(SrcAFInfoTypeData%CmAoAknots,1)
   i1_u = UBOUND(SrcAFInfoTypeData%CmAoAknots,1)
   IF (.NOT. ALLOCATED(DstAFInfoTypeData%CmAoAknots)) THEN 
      ALLOCATE(DstAFInfoTypeData%CmAoAknots(i1_l:i1_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstAFInfoTypeData%CmAoAknots.', ErrStat, ErrMsg,'AFI_CopyAFInfoType')
         RETURN
      END IF
   END IF
   DstAFInfoTypeData%CmAoAknots = SrcAFInfoTypeData%CmAoAknots
ENDIF
IF (ALLOCATED(SrcAFInfoTypeData%CmReKnots)) THEN
   i1_l = LBOUND(SrcAFInfoTypeData%CmReKnots,1)
   i1_u = UBOUND(SrcAFInfoTypeData%CmReKnots,1)
   IF (.NOT. ALLOCATED(DstAFInfoTypeData%CmReKnots)) THEN 
      ALLOCATE(DstAFInfoTypeData%CmReKnots(i1_l:i1_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstAFInfoTypeData%CmReKnots.', ErrStat, ErrMsg,'AFI_CopyAFInfoType')
         RETURN
      END IF
   END IF
   DstAFInfoTypeData%CmReKnots = SrcAFInfoTypeData%CmReKnots
ENDIF
IF (ALLOCATED(SrcAFInfoTypeData%CpminAoAknots)) THEN
   i1_l = LBOUND(SrcAFInfoTypeData%CpminAoAknots,1)
   i1_u = UBOUND(SrcAFInfoTypeData%CpminAoAknots,1)
   IF (.NOT. ALLOCATED(DstAFInfoTypeData%CpminAoAknots)) THEN 
      ALLOCATE(DstAFInfoTypeData%CpminAoAknots(i1_l:i1_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstAFInfoTypeData%CpminAoAknots.', ErrStat, ErrMsg,'AFI_CopyAFInfoType')
         RETURN
      END IF
   END IF
   DstAFInfoTypeData%CpminAoAknots = SrcAFInfoTypeData%CpminAoAknots
ENDIF
IF (ALLOCATED(SrcAFInfoTypeData%CpminReKnots)) THEN
   i1_l = LBOUND(SrcAFInfoTypeData%CpminReKnots,1)
   i1_u = UBOUND(SrcAFInfoTypeData%CpminReKnots,1)
   IF (.NOT. ALLOCATED(DstAFInfoTypeData%CpminReKnots)) THEN 
      ALLOCATE(DstAFInfoTypeData%CpminReKnots(i1_l:i1_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstAFInfoTypeData%CpminReKnots.', ErrStat, ErrMsg,'AFI_CopyAFInfoType')
         RETURN
      END IF
   END IF
   DstAFInfoTypeData%CpminReKnots = SrcAFInfoTypeData%CpminReKnots
ENDIF
IF (ALLOCATED(SrcAFInfoTypeData%LogRe)) THEN
   i1_l = LBOUND(SrcAFInfoTypeData%LogRe,1)
   i1_u = UBOUND(SrcAFInfoTypeData%LogRe,1)
   IF (.NOT. ALLOCATED(DstAFInfoTypeData%LogRe)) THEN 
      ALLOCATE(DstAFInfoTypeData%LogRe(i1_l:i1_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstAFInfoTypeData%LogRe.', ErrStat, ErrMsg,'AFI_CopyAFInfoType')
         RETURN
      END IF
   END IF
   DstAFInfoTypeData%LogRe = SrcAFInfoTypeData%LogRe
ENDIF
IF (ALLOCATED(SrcAFInfoTypeData%ReKnots)) THEN
   i1_l = LBOUND(SrcAFInfoTypeData%ReKnots,1)
   i1_u = UBOUND(SrcAFInfoTypeData%ReKnots,1)
   i2_l = LBOUND(SrcAFInfoTypeData%ReKnots,2)
   i2_u = UBOUND(SrcAFInfoTypeData%ReKnots,2)
   IF (.NOT. ALLOCATED(DstAFInfoTypeData%ReKnots)) THEN 
      ALLOCATE(DstAFInfoTypeData%ReKnots(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstAFInfoTypeData%ReKnots.', ErrStat, ErrMsg,'AFI_CopyAFInfoType')
         RETURN
      END IF
   END IF
   DstAFInfoTypeData%ReKnots = SrcAFInfoTypeData%ReKnots
ENDIF
IF (ALLOCATED(SrcAFInfoTypeData%CdSpCoef2D)) THEN
   i1_l = LBOUND(SrcAFInfoTypeData%CdSpCoef2D,1)
   i1_u = UBOUND(SrcAFInfoTypeData%CdSpCoef2D,1)
   IF (.NOT. ALLOCATED(DstAFInfoTypeData%CdSpCoef2D)) THEN 
      ALLOCATE(DstAFInfoTypeData%CdSpCoef2D(i1_l:i1_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstAFInfoTypeData%CdSpCoef2D.', ErrStat, ErrMsg,'AFI_CopyAFInfoType')
         RETURN
      END IF
   END IF
   DstAFInfoTypeData%CdSpCoef2D = SrcAFInfoTypeData%CdSpCoef2D
ENDIF
IF (ALLOCATED(SrcAFInfoTypeData%ClSpCoef2D)) THEN
   i1_l = LBOUND(SrcAFInfoTypeData%ClSpCoef2D,1)
   i1_u = UBOUND(SrcAFInfoTypeData%ClSpCoef2D,1)
   IF (.NOT. ALLOCATED(DstAFInfoTypeData%ClSpCoef2D)) THEN 
      ALLOCATE(DstAFInfoTypeData%ClSpCoef2D(i1_l:i1_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstAFInfoTypeData%ClSpCoef2D.', ErrStat, ErrMsg,'AFI_CopyAFInfoType')
         RETURN
      END IF
   END IF
   DstAFInfoTypeData%ClSpCoef2D = SrcAFInfoTypeData%ClSpCoef2D
ENDIF
IF (ALLOCATED(SrcAFInfoTypeData%CmSpCoef2D)) THEN
   i1_l = LBOUND(SrcAFInfoTypeData%CmSpCoef2D,1)
   i1_u = UBOUND(SrcAFInfoTypeData%CmSpCoef2D,1)
   IF (.NOT. ALLOCATED(DstAFInfoTypeData%CmSpCoef2D)) THEN 
      ALLOCATE(DstAFInfoTypeData%CmSpCoef2D(i1_l:i1_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstAFInfoTypeData%CmSpCoef2D.', ErrStat, ErrMsg,'AFI_CopyAFInfoType')
         RETURN
      END IF
   END IF
   DstAFInfoTypeData%CmSpCoef2D = SrcAFInfoTypeData%CmSpCoef2D
ENDIF
IF (ALLOCATED(SrcAFInfoTypeData%CpminSpCoef2D)) THEN
   i1_l = LBOUND(SrcAFInfoTypeData%CpminSpCoef2D,1)
   i1_u = UBOUND(SrcAFInfoTypeData%CpminSpCoef2D,1)
   IF (.NOT. ALLOCATED(DstAFInfoTypeData%CpminSpCoef2D)) THEN 
      ALLOCATE(DstAFInfoTypeData%CpminSpCoef2D(i1_l:i1_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstAFInfoTypeData%CpminSpCoef2D.', ErrStat, ErrMsg,'AFI_CopyAFInfoType')
         RETURN
      END IF
   END IF
   DstAFInfoTypeData%CpminSpCoef2D = SrcAFInfoTypeData%CpminSpCoef2D
ENDIF
IF (ALLOCATED(SrcAFInfoTypeData%X_Coord)) THEN
   i1_l = LBOUND(SrcAFInfoTypeData%X_Coord,1)
   i1_u = UBOUND(SrcAFInfoTypeData%X_Coord,1)
   IF (.NOT. ALLOCATED(DstAFInfoTypeData%X_Coord)) THEN 
      ALLOCATE(DstAFInfoTypeData%X_Coord(i1_l:i1_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstAFInfoTypeData%X_Coord.', ErrStat, ErrMsg,'AFI_CopyAFInfoType')
         RETURN
      END IF
   END IF
   DstAFInfoTypeData%X_Coord = SrcAFInfoTypeData%X_Coord
ENDIF
IF (ALLOCATED(SrcAFInfoTypeData%Y_Coord)) THEN
   i1_l = LBOUND(SrcAFInfoTypeData%Y_Coord,1)
   i1_u = UBOUND(SrcAFInfoTypeData%Y_Coord,1)
   IF (.NOT. ALLOCATED(DstAFInfoTypeData%Y_Coord)) THEN 
      ALLOCATE(DstAFInfoTypeData%Y_Coord(i1_l:i1_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstAFInfoTypeData%Y_Coord.', ErrStat, ErrMsg,'AFI_CopyAFInfoType')
         RETURN
      END IF
   END IF
   DstAFInfoTypeData%Y_Coord = SrcAFInfoTypeData%Y_Coord
ENDIF
IF (ALLOCATED(SrcAFInfoTypeData%MaxAoAknots)) THEN
   i1_l = LBOUND(SrcAFInfoTypeData%MaxAoAknots,1)
   i1_u = UBOUND(SrcAFInfoTypeData%MaxAoAknots,1)
   IF (.NOT. ALLOCATED(DstAFInfoTypeData%MaxAoAknots)) THEN 
      ALLOCATE(DstAFInfoTypeData%MaxAoAknots(i1_l:i1_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstAFInfoTypeData%MaxAoAknots.', ErrStat, ErrMsg,'AFI_CopyAFInfoType')
         RETURN
      END IF
   END IF
   DstAFInfoTypeData%MaxAoAknots = SrcAFInfoTypeData%MaxAoAknots
ENDIF
IF (ALLOCATED(SrcAFInfoTypeData%MaxReKnots)) THEN
   i1_l = LBOUND(SrcAFInfoTypeData%MaxReKnots,1)
   i1_u = UBOUND(SrcAFInfoTypeData%MaxReKnots,1)
   IF (.NOT. ALLOCATED(DstAFInfoTypeData%MaxReKnots)) THEN 
      ALLOCATE(DstAFInfoTypeData%MaxReKnots(i1_l:i1_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstAFInfoTypeData%MaxReKnots.', ErrStat, ErrMsg,'AFI_CopyAFInfoType')
         RETURN
      END IF
   END IF
   DstAFInfoTypeData%MaxReKnots = SrcAFInfoTypeData%MaxReKnots
ENDIF
   DstAFInfoTypeData%NumCdAoAkts = SrcAFInfoTypeData%NumCdAoAkts
   DstAFInfoTypeData%NumCdReKts = SrcAFInfoTypeData%NumCdReKts
   DstAFInfoTypeData%NumClAoAkts = SrcAFInfoTypeData%NumClAoAkts
   DstAFInfoTypeData%NumClReKts = SrcAFInfoTypeData%NumClReKts
   DstAFInfoTypeData%NumCmAoAkts = SrcAFInfoTypeData%NumCmAoAkts
   DstAFInfoTypeData%NumCmReKts = SrcAFInfoTypeData%NumCmReKts
   DstAFInfoTypeData%NumCoords = SrcAFInfoTypeData%NumCoords
   DstAFInfoTypeData%NumCpminAoAkts = SrcAFInfoTypeData%NumCpminAoAkts
   DstAFInfoTypeData%NumCpminReKts = SrcAFInfoTypeData%NumCpminReKts
   DstAFInfoTypeData%NumTabs = SrcAFInfoTypeData%NumTabs
IF (ALLOCATED(SrcAFInfoTypeData%Table)) THEN
   i1_l = LBOUND(SrcAFInfoTypeData%Table,1)
   i1_u = UBOUND(SrcAFInfoTypeData%Table,1)
   IF (.NOT. ALLOCATED(DstAFInfoTypeData%Table)) THEN 
      ALLOCATE(DstAFInfoTypeData%Table(i1_l:i1_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstAFInfoTypeData%Table.', ErrStat, ErrMsg,'AFI_CopyAFInfoType')
         RETURN
      END IF
   END IF
   DO i1 = LBOUND(SrcAFInfoTypeData%Table,1), UBOUND(SrcAFInfoTypeData%Table,1)
      CALL AFI_Copytable_type( SrcAFInfoTypeData%Table(i1), DstAFInfoTypeData%Table(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,'AFI_CopyAFInfoType:Table(i1)')
         IF (ErrStat>=AbortErrLev) RETURN
   ENDDO
ENDIF
 END SUBROUTINE AFI_CopyAFInfoType

 SUBROUTINE AFI_DestroyAFInfoType( AFInfoTypeData, ErrStat, ErrMsg )
  TYPE(AFInfoType), INTENT(INOUT) :: AFInfoTypeData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
IF (ALLOCATED(AFInfoTypeData%CdAoAknots)) THEN
   DEALLOCATE(AFInfoTypeData%CdAoAknots)
ENDIF
IF (ALLOCATED(AFInfoTypeData%CdReKnots)) THEN
   DEALLOCATE(AFInfoTypeData%CdReKnots)
ENDIF
IF (ALLOCATED(AFInfoTypeData%ClAoAknots)) THEN
   DEALLOCATE(AFInfoTypeData%ClAoAknots)
ENDIF
IF (ALLOCATED(AFInfoTypeData%ClReKnots)) THEN
   DEALLOCATE(AFInfoTypeData%ClReKnots)
ENDIF
IF (ALLOCATED(AFInfoTypeData%CmAoAknots)) THEN
   DEALLOCATE(AFInfoTypeData%CmAoAknots)
ENDIF
IF (ALLOCATED(AFInfoTypeData%CmReKnots)) THEN
   DEALLOCATE(AFInfoTypeData%CmReKnots)
ENDIF
IF (ALLOCATED(AFInfoTypeData%CpminAoAknots)) THEN
   DEALLOCATE(AFInfoTypeData%CpminAoAknots)
ENDIF
IF (ALLOCATED(AFInfoTypeData%CpminReKnots)) THEN
   DEALLOCATE(AFInfoTypeData%CpminReKnots)
ENDIF
IF (ALLOCATED(AFInfoTypeData%LogRe)) THEN
   DEALLOCATE(AFInfoTypeData%LogRe)
ENDIF
IF (ALLOCATED(AFInfoTypeData%ReKnots)) THEN
   DEALLOCATE(AFInfoTypeData%ReKnots)
ENDIF
IF (ALLOCATED(AFInfoTypeData%CdSpCoef2D)) THEN
   DEALLOCATE(AFInfoTypeData%CdSpCoef2D)
ENDIF
IF (ALLOCATED(AFInfoTypeData%ClSpCoef2D)) THEN
   DEALLOCATE(AFInfoTypeData%ClSpCoef2D)
ENDIF
IF (ALLOCATED(AFInfoTypeData%CmSpCoef2D)) THEN
   DEALLOCATE(AFInfoTypeData%CmSpCoef2D)
ENDIF
IF (ALLOCATED(AFInfoTypeData%CpminSpCoef2D)) THEN
   DEALLOCATE(AFInfoTypeData%CpminSpCoef2D)
ENDIF
IF (ALLOCATED(AFInfoTypeData%X_Coord)) THEN
   DEALLOCATE(AFInfoTypeData%X_Coord)
ENDIF
IF (ALLOCATED(AFInfoTypeData%Y_Coord)) THEN
   DEALLOCATE(AFInfoTypeData%Y_Coord)
ENDIF
IF (ALLOCATED(AFInfoTypeData%MaxAoAknots)) THEN
   DEALLOCATE(AFInfoTypeData%MaxAoAknots)
ENDIF
IF (ALLOCATED(AFInfoTypeData%MaxReKnots)) THEN
   DEALLOCATE(AFInfoTypeData%MaxReKnots)
ENDIF
IF (ALLOCATED(AFInfoTypeData%Table)) THEN
DO i1 = LBOUND(AFInfoTypeData%Table,1), UBOUND(AFInfoTypeData%Table,1)
  CALL AFI_Destroytable_type( AFInfoTypeData%Table(i1), ErrStat, ErrMsg )
ENDDO
   DEALLOCATE(AFInfoTypeData%Table)
ENDIF
 END SUBROUTINE AFI_DestroyAFInfoType

 SUBROUTINE AFI_PackAFInfoType( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(AFInfoType),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  REAL(ReKi),     ALLOCATABLE :: Re_Table_Buf(:)
  REAL(DbKi),     ALLOCATABLE :: Db_Table_Buf(:)
  INTEGER(IntKi), ALLOCATABLE :: Int_Table_Buf(:)
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  Re_BufSz   = Re_BufSz   + 1  ! NonDimArea
  IF ( ALLOCATED(InData%CdAoAknots) )   Re_BufSz    = Re_BufSz    + SIZE( InData%CdAoAknots )  ! CdAoAknots 
  IF ( ALLOCATED(InData%CdReKnots) )   Re_BufSz    = Re_BufSz    + SIZE( InData%CdReKnots )  ! CdReKnots 
  IF ( ALLOCATED(InData%ClAoAknots) )   Re_BufSz    = Re_BufSz    + SIZE( InData%ClAoAknots )  ! ClAoAknots 
  IF ( ALLOCATED(InData%ClReKnots) )   Re_BufSz    = Re_BufSz    + SIZE( InData%ClReKnots )  ! ClReKnots 
  IF ( ALLOCATED(InData%CmAoAknots) )   Re_BufSz    = Re_BufSz    + SIZE( InData%CmAoAknots )  ! CmAoAknots 
  IF ( ALLOCATED(InData%CmReKnots) )   Re_BufSz    = Re_BufSz    + SIZE( InData%CmReKnots )  ! CmReKnots 
  IF ( ALLOCATED(InData%CpminAoAknots) )   Re_BufSz    = Re_BufSz    + SIZE( InData%CpminAoAknots )  ! CpminAoAknots 
  IF ( ALLOCATED(InData%CpminReKnots) )   Re_BufSz    = Re_BufSz    + SIZE( InData%CpminReKnots )  ! CpminReKnots 
  IF ( ALLOCATED(InData%LogRe) )   Re_BufSz    = Re_BufSz    + SIZE( InData%LogRe )  ! LogRe 
  IF ( ALLOCATED(InData%ReKnots) )   Re_BufSz    = Re_BufSz    + SIZE( InData%ReKnots )  ! ReKnots 
  IF ( ALLOCATED(InData%CdSpCoef2D) )   Re_BufSz    = Re_BufSz    + SIZE( InData%CdSpCoef2D )  ! CdSpCoef2D 
  IF ( ALLOCATED(InData%ClSpCoef2D) )   Re_BufSz    = Re_BufSz    + SIZE( InData%ClSpCoef2D )  ! ClSpCoef2D 
  IF ( ALLOCATED(InData%CmSpCoef2D) )   Re_BufSz    = Re_BufSz    + SIZE( InData%CmSpCoef2D )  ! CmSpCoef2D 
  IF ( ALLOCATED(InData%CpminSpCoef2D) )   Re_BufSz    = Re_BufSz    + SIZE( InData%CpminSpCoef2D )  ! CpminSpCoef2D 
  IF ( ALLOCATED(InData%X_Coord) )   Re_BufSz    = Re_BufSz    + SIZE( InData%X_Coord )  ! X_Coord 
  IF ( ALLOCATED(InData%Y_Coord) )   Re_BufSz    = Re_BufSz    + SIZE( InData%Y_Coord )  ! Y_Coord 
  IF ( ALLOCATED(InData%MaxAoAknots) )   Int_BufSz   = Int_BufSz   + SIZE( InData%MaxAoAknots )  ! MaxAoAknots 
  IF ( ALLOCATED(InData%MaxReKnots) )   Int_BufSz   = Int_BufSz   + SIZE( InData%MaxReKnots )  ! MaxReKnots 
  Int_BufSz  = Int_BufSz  + 1  ! NumCdAoAkts
  Int_BufSz  = Int_BufSz  + 1  ! NumCdReKts
  Int_BufSz  = Int_BufSz  + 1  ! NumClAoAkts
  Int_BufSz  = Int_BufSz  + 1  ! NumClReKts
  Int_BufSz  = Int_BufSz  + 1  ! NumCmAoAkts
  Int_BufSz  = Int_BufSz  + 1  ! NumCmReKts
  Int_BufSz  = Int_BufSz  + 1  ! NumCoords
  Int_BufSz  = Int_BufSz  + 1  ! NumCpminAoAkts
  Int_BufSz  = Int_BufSz  + 1  ! NumCpminReKts
  Int_BufSz  = Int_BufSz  + 1  ! NumTabs
DO i1 = LBOUND(InData%Table,1), UBOUND(InData%Table,1)
  CALL AFI_Packtable_type( Re_Table_Buf, Db_Table_Buf, Int_Table_Buf, InData%Table(i1), ErrStat, ErrMsg, .TRUE. ) ! Table 
  IF(ALLOCATED(Re_Table_Buf)) Re_BufSz  = Re_BufSz  + SIZE( Re_Table_Buf  ) ! Table
  IF(ALLOCATED(Db_Table_Buf)) Db_BufSz  = Db_BufSz  + SIZE( Db_Table_Buf  ) ! Table
  IF(ALLOCATED(Int_Table_Buf))Int_BufSz = Int_BufSz + SIZE( Int_Table_Buf ) ! Table
  IF(ALLOCATED(Re_Table_Buf))  DEALLOCATE(Re_Table_Buf)
  IF(ALLOCATED(Db_Table_Buf))  DEALLOCATE(Db_Table_Buf)
  IF(ALLOCATED(Int_Table_Buf)) DEALLOCATE(Int_Table_Buf)
ENDDO
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%NonDimArea )
  Re_Xferred   = Re_Xferred   + 1
  IF ( ALLOCATED(InData%CdAoAknots) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%CdAoAknots))-1 ) =  PACK(InData%CdAoAknots ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%CdAoAknots)
  ENDIF
  IF ( ALLOCATED(InData%CdReKnots) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%CdReKnots))-1 ) =  PACK(InData%CdReKnots ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%CdReKnots)
  ENDIF
  IF ( ALLOCATED(InData%ClAoAknots) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%ClAoAknots))-1 ) =  PACK(InData%ClAoAknots ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%ClAoAknots)
  ENDIF
  IF ( ALLOCATED(InData%ClReKnots) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%ClReKnots))-1 ) =  PACK(InData%ClReKnots ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%ClReKnots)
  ENDIF
  IF ( ALLOCATED(InData%CmAoAknots) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%CmAoAknots))-1 ) =  PACK(InData%CmAoAknots ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%CmAoAknots)
  ENDIF
  IF ( ALLOCATED(InData%CmReKnots) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%CmReKnots))-1 ) =  PACK(InData%CmReKnots ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%CmReKnots)
  ENDIF
  IF ( ALLOCATED(InData%CpminAoAknots) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%CpminAoAknots))-1 ) =  PACK(InData%CpminAoAknots ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%CpminAoAknots)
  ENDIF
  IF ( ALLOCATED(InData%CpminReKnots) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%CpminReKnots))-1 ) =  PACK(InData%CpminReKnots ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%CpminReKnots)
  ENDIF
  IF ( ALLOCATED(InData%LogRe) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%LogRe))-1 ) =  PACK(InData%LogRe ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%LogRe)
  ENDIF
  IF ( ALLOCATED(InData%ReKnots) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%ReKnots))-1 ) =  PACK(InData%ReKnots ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%ReKnots)
  ENDIF
  IF ( ALLOCATED(InData%CdSpCoef2D) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%CdSpCoef2D))-1 ) =  PACK(InData%CdSpCoef2D ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%CdSpCoef2D)
  ENDIF
  IF ( ALLOCATED(InData%ClSpCoef2D) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%ClSpCoef2D))-1 ) =  PACK(InData%ClSpCoef2D ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%ClSpCoef2D)
  ENDIF
  IF ( ALLOCATED(InData%CmSpCoef2D) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%CmSpCoef2D))-1 ) =  PACK(InData%CmSpCoef2D ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%CmSpCoef2D)
  ENDIF
  IF ( ALLOCATED(InData%CpminSpCoef2D) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%CpminSpCoef2D))-1 ) =  PACK(InData%CpminSpCoef2D ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%CpminSpCoef2D)
  ENDIF
  IF ( ALLOCATED(InData%X_Coord) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%X_Coord))-1 ) =  PACK(InData%X_Coord ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%X_Coord)
  ENDIF
  IF ( ALLOCATED(InData%Y_Coord) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%Y_Coord))-1 ) =  PACK(InData%Y_Coord ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%Y_Coord)
  ENDIF
  IF ( ALLOCATED(InData%MaxAoAknots) ) THEN
    IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(SIZE(InData%MaxAoAknots))-1 ) = PACK(InData%MaxAoAknots ,.TRUE.)
    Int_Xferred   = Int_Xferred   + SIZE(InData%MaxAoAknots)
  ENDIF
  IF ( ALLOCATED(InData%MaxReKnots) ) THEN
    IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(SIZE(InData%MaxReKnots))-1 ) = PACK(InData%MaxReKnots ,.TRUE.)
    Int_Xferred   = Int_Xferred   + SIZE(InData%MaxReKnots)
  ENDIF
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%NumCdAoAkts )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%NumCdReKts )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%NumClAoAkts )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%NumClReKts )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%NumCmAoAkts )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%NumCmReKts )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%NumCoords )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%NumCpminAoAkts )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%NumCpminReKts )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%NumTabs )
  Int_Xferred   = Int_Xferred   + 1
DO i1 = LBOUND(InData%Table,1), UBOUND(InData%Table,1)
  CALL AFI_Packtable_type( Re_Table_Buf, Db_Table_Buf, Int_Table_Buf, InData%Table(i1), ErrStat, ErrMsg, OnlySize ) ! Table 
  IF(ALLOCATED(Re_Table_Buf)) THEN
    IF ( .NOT. OnlySize ) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_Table_Buf)-1 ) = Re_Table_Buf
    Re_Xferred = Re_Xferred + SIZE(Re_Table_Buf)
  ENDIF
  IF(ALLOCATED(Db_Table_Buf)) THEN
    IF ( .NOT. OnlySize ) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_Table_Buf)-1 ) = Db_Table_Buf
    Db_Xferred = Db_Xferred + SIZE(Db_Table_Buf)
  ENDIF
  IF(ALLOCATED(Int_Table_Buf)) THEN
    IF ( .NOT. OnlySize ) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_Table_Buf)-1 ) = Int_Table_Buf
    Int_Xferred = Int_Xferred + SIZE(Int_Table_Buf)
  ENDIF
  IF( ALLOCATED(Re_Table_Buf) )  DEALLOCATE(Re_Table_Buf)
  IF( ALLOCATED(Db_Table_Buf) )  DEALLOCATE(Db_Table_Buf)
  IF( ALLOCATED(Int_Table_Buf) ) DEALLOCATE(Int_Table_Buf)
ENDDO
 END SUBROUTINE AFI_PackAFInfoType

 SUBROUTINE AFI_UnPackAFInfoType( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(AFInfoType), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
  REAL(ReKi),    ALLOCATABLE :: Re_Table_Buf(:)
  REAL(DbKi),    ALLOCATABLE :: Db_Table_Buf(:)
  INTEGER(IntKi),    ALLOCATABLE :: Int_Table_Buf(:)
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  OutData%NonDimArea = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  IF ( ALLOCATED(OutData%CdAoAknots) ) THEN
  ALLOCATE(mask1(SIZE(OutData%CdAoAknots,1)))
  mask1 = .TRUE.
    OutData%CdAoAknots = REAL( UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%CdAoAknots))-1 ),mask1,REAL(OutData%CdAoAknots,ReKi)), SiKi)
  DEALLOCATE(mask1)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%CdAoAknots)
  ENDIF
  IF ( ALLOCATED(OutData%CdReKnots) ) THEN
  ALLOCATE(mask1(SIZE(OutData%CdReKnots,1)))
  mask1 = .TRUE.
    OutData%CdReKnots = REAL( UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%CdReKnots))-1 ),mask1,REAL(OutData%CdReKnots,ReKi)), SiKi)
  DEALLOCATE(mask1)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%CdReKnots)
  ENDIF
  IF ( ALLOCATED(OutData%ClAoAknots) ) THEN
  ALLOCATE(mask1(SIZE(OutData%ClAoAknots,1)))
  mask1 = .TRUE.
    OutData%ClAoAknots = REAL( UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%ClAoAknots))-1 ),mask1,REAL(OutData%ClAoAknots,ReKi)), SiKi)
  DEALLOCATE(mask1)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%ClAoAknots)
  ENDIF
  IF ( ALLOCATED(OutData%ClReKnots) ) THEN
  ALLOCATE(mask1(SIZE(OutData%ClReKnots,1)))
  mask1 = .TRUE.
    OutData%ClReKnots = REAL( UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%ClReKnots))-1 ),mask1,REAL(OutData%ClReKnots,ReKi)), SiKi)
  DEALLOCATE(mask1)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%ClReKnots)
  ENDIF
  IF ( ALLOCATED(OutData%CmAoAknots) ) THEN
  ALLOCATE(mask1(SIZE(OutData%CmAoAknots,1)))
  mask1 = .TRUE.
    OutData%CmAoAknots = REAL( UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%CmAoAknots))-1 ),mask1,REAL(OutData%CmAoAknots,ReKi)), SiKi)
  DEALLOCATE(mask1)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%CmAoAknots)
  ENDIF
  IF ( ALLOCATED(OutData%CmReKnots) ) THEN
  ALLOCATE(mask1(SIZE(OutData%CmReKnots,1)))
  mask1 = .TRUE.
    OutData%CmReKnots = REAL( UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%CmReKnots))-1 ),mask1,REAL(OutData%CmReKnots,ReKi)), SiKi)
  DEALLOCATE(mask1)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%CmReKnots)
  ENDIF
  IF ( ALLOCATED(OutData%CpminAoAknots) ) THEN
  ALLOCATE(mask1(SIZE(OutData%CpminAoAknots,1)))
  mask1 = .TRUE.
    OutData%CpminAoAknots = REAL( UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%CpminAoAknots))-1 ),mask1,REAL(OutData%CpminAoAknots,ReKi)), SiKi)
  DEALLOCATE(mask1)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%CpminAoAknots)
  ENDIF
  IF ( ALLOCATED(OutData%CpminReKnots) ) THEN
  ALLOCATE(mask1(SIZE(OutData%CpminReKnots,1)))
  mask1 = .TRUE.
    OutData%CpminReKnots = REAL( UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%CpminReKnots))-1 ),mask1,REAL(OutData%CpminReKnots,ReKi)), SiKi)
  DEALLOCATE(mask1)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%CpminReKnots)
  ENDIF
  IF ( ALLOCATED(OutData%LogRe) ) THEN
  ALLOCATE(mask1(SIZE(OutData%LogRe,1)))
  mask1 = .TRUE.
    OutData%LogRe = REAL( UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%LogRe))-1 ),mask1,REAL(OutData%LogRe,ReKi)), SiKi)
  DEALLOCATE(mask1)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%LogRe)
  ENDIF
  IF ( ALLOCATED(OutData%ReKnots) ) THEN
  ALLOCATE(mask2(SIZE(OutData%ReKnots,1),SIZE(OutData%ReKnots,2)))
  mask2 = .TRUE.
    OutData%ReKnots = REAL( UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%ReKnots))-1 ),mask2,REAL(OutData%ReKnots,ReKi)), SiKi)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%ReKnots)
  ENDIF
  IF ( ALLOCATED(OutData%CdSpCoef2D) ) THEN
  ALLOCATE(mask1(SIZE(OutData%CdSpCoef2D,1)))
  mask1 = .TRUE.
    OutData%CdSpCoef2D = REAL( UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%CdSpCoef2D))-1 ),mask1,REAL(OutData%CdSpCoef2D,ReKi)), SiKi)
  DEALLOCATE(mask1)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%CdSpCoef2D)
  ENDIF
  IF ( ALLOCATED(OutData%ClSpCoef2D) ) THEN
  ALLOCATE(mask1(SIZE(OutData%ClSpCoef2D,1)))
  mask1 = .TRUE.
    OutData%ClSpCoef2D = REAL( UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%ClSpCoef2D))-1 ),mask1,REAL(OutData%ClSpCoef2D,ReKi)), SiKi)
  DEALLOCATE(mask1)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%ClSpCoef2D)
  ENDIF
  IF ( ALLOCATED(OutData%CmSpCoef2D) ) THEN
  ALLOCATE(mask1(SIZE(OutData%CmSpCoef2D,1)))
  mask1 = .TRUE.
    OutData%CmSpCoef2D = REAL( UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%CmSpCoef2D))-1 ),mask1,REAL(OutData%CmSpCoef2D,ReKi)), SiKi)
  DEALLOCATE(mask1)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%CmSpCoef2D)
  ENDIF
  IF ( ALLOCATED(OutData%CpminSpCoef2D) ) THEN
  ALLOCATE(mask1(SIZE(OutData%CpminSpCoef2D,1)))
  mask1 = .TRUE.
    OutData%CpminSpCoef2D = REAL( UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%CpminSpCoef2D))-1 ),mask1,REAL(OutData%CpminSpCoef2D,ReKi)), SiKi)
  DEALLOCATE(mask1)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%CpminSpCoef2D)
  ENDIF
  IF ( ALLOCATED(OutData%X_Coord) ) THEN
  ALLOCATE(mask1(SIZE(OutData%X_Coord,1)))
  mask1 = .TRUE.
    OutData%X_Coord = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%X_Coord))-1 ),mask1,OutData%X_Coord)
  DEALLOCATE(mask1)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%X_Coord)
  ENDIF
  IF ( ALLOCATED(OutData%Y_Coord) ) THEN
  ALLOCATE(mask1(SIZE(OutData%Y_Coord,1)))
  mask1 = .TRUE.
    OutData%Y_Coord = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%Y_Coord))-1 ),mask1,OutData%Y_Coord)
  DEALLOCATE(mask1)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%Y_Coord)
  ENDIF
  IF ( ALLOCATED(OutData%MaxAoAknots) ) THEN
  ALLOCATE(mask1(SIZE(OutData%MaxAoAknots,1)))
  mask1 = .TRUE.
    OutData%MaxAoAknots = UNPACK(IntKiBuf( Int_Xferred:Re_Xferred+(SIZE(OutData%MaxAoAknots))-1 ),mask1,OutData%MaxAoAknots)
  DEALLOCATE(mask1)
    Int_Xferred   = Int_Xferred   + SIZE(OutData%MaxAoAknots)
  ENDIF
  IF ( ALLOCATED(OutData%MaxReKnots) ) THEN
  ALLOCATE(mask1(SIZE(OutData%MaxReKnots,1)))
  mask1 = .TRUE.
    OutData%MaxReKnots = UNPACK(IntKiBuf( Int_Xferred:Re_Xferred+(SIZE(OutData%MaxReKnots))-1 ),mask1,OutData%MaxReKnots)
  DEALLOCATE(mask1)
    Int_Xferred   = Int_Xferred   + SIZE(OutData%MaxReKnots)
  ENDIF
  OutData%NumCdAoAkts = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%NumCdReKts = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%NumClAoAkts = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%NumClReKts = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%NumCmAoAkts = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%NumCmReKts = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%NumCoords = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%NumCpminAoAkts = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%NumCpminReKts = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%NumTabs = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
DO i1 = LBOUND(OutData%Table,1), UBOUND(OutData%Table,1)
 ! first call AFI_Packtable_type to get correctly sized buffers for unpacking
  CALL AFI_Packtable_type( Re_Table_Buf, Db_Table_Buf, Int_Table_Buf, OutData%Table(i1), ErrStat, ErrMsg, .TRUE. ) ! Table 
  IF(ALLOCATED(Re_Table_Buf)) THEN
    Re_Table_Buf = ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_Table_Buf)-1 )
    Re_Xferred = Re_Xferred + SIZE(Re_Table_Buf)
  ENDIF
  IF(ALLOCATED(Db_Table_Buf)) THEN
    Db_Table_Buf = DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_Table_Buf)-1 )
    Db_Xferred = Db_Xferred + SIZE(Db_Table_Buf)
  ENDIF
  IF(ALLOCATED(Int_Table_Buf)) THEN
    Int_Table_Buf = IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_Table_Buf)-1 )
    Int_Xferred = Int_Xferred + SIZE(Int_Table_Buf)
  ENDIF
  CALL AFI_UnPacktable_type( Re_Table_Buf, Db_Table_Buf, Int_Table_Buf, OutData%Table(i1), ErrStat, ErrMsg ) ! Table 
ENDDO
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE AFI_UnPackAFInfoType

 SUBROUTINE AFI_CopyInitInput( SrcInitInputData, DstInitInputData, CtrlCode, ErrStat, ErrMsg )
   TYPE(AFI_InitInputType), INTENT(IN) :: SrcInitInputData
   TYPE(AFI_InitInputType), INTENT(INOUT) :: DstInitInputData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: i2, i2_l, i2_u  !  bounds (upper/lower) for an array dimension 2
   INTEGER(IntKi)                 :: i3, i3_l, i3_u  !  bounds (upper/lower) for an array dimension 3
   INTEGER(IntKi)                 :: i4, i4_l, i4_u  !  bounds (upper/lower) for an array dimension 4
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(1024)                :: ErrMsg2
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
   DstInitInputData%NumAFfiles = SrcInitInputData%NumAFfiles
IF (ALLOCATED(SrcInitInputData%FileNames)) THEN
   i1_l = LBOUND(SrcInitInputData%FileNames,1)
   i1_u = UBOUND(SrcInitInputData%FileNames,1)
   IF (.NOT. ALLOCATED(DstInitInputData%FileNames)) THEN 
      ALLOCATE(DstInitInputData%FileNames(i1_l:i1_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInitInputData%FileNames.', ErrStat, ErrMsg,'AFI_CopyInitInput')
         RETURN
      END IF
   END IF
   DstInitInputData%FileNames = SrcInitInputData%FileNames
ENDIF
   DstInitInputData%UA_Model = SrcInitInputData%UA_Model
   DstInitInputData%NumCoefs = SrcInitInputData%NumCoefs
   DstInitInputData%InCol_Alfa = SrcInitInputData%InCol_Alfa
   DstInitInputData%InCol_Cl = SrcInitInputData%InCol_Cl
   DstInitInputData%InCol_Cd = SrcInitInputData%InCol_Cd
   DstInitInputData%InCol_Cm = SrcInitInputData%InCol_Cm
   DstInitInputData%InCol_Cpmin = SrcInitInputData%InCol_Cpmin
 END SUBROUTINE AFI_CopyInitInput

 SUBROUTINE AFI_DestroyInitInput( InitInputData, ErrStat, ErrMsg )
  TYPE(AFI_InitInputType), INTENT(INOUT) :: InitInputData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
IF (ALLOCATED(InitInputData%FileNames)) THEN
   DEALLOCATE(InitInputData%FileNames)
ENDIF
 END SUBROUTINE AFI_DestroyInitInput

 SUBROUTINE AFI_PackInitInput( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(AFI_InitInputType),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  Int_BufSz  = Int_BufSz  + 1  ! NumAFfiles
!  missing buffer for FileNames
  Int_BufSz  = Int_BufSz  + 1  ! UA_Model
  Int_BufSz  = Int_BufSz  + 1  ! NumCoefs
  Int_BufSz  = Int_BufSz  + 1  ! InCol_Alfa
  Int_BufSz  = Int_BufSz  + 1  ! InCol_Cl
  Int_BufSz  = Int_BufSz  + 1  ! InCol_Cd
  Int_BufSz  = Int_BufSz  + 1  ! InCol_Cm
  Int_BufSz  = Int_BufSz  + 1  ! InCol_Cpmin
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%NumAFfiles )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%UA_Model )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%NumCoefs )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%InCol_Alfa )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%InCol_Cl )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%InCol_Cd )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%InCol_Cm )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%InCol_Cpmin )
  Int_Xferred   = Int_Xferred   + 1
 END SUBROUTINE AFI_PackInitInput

 SUBROUTINE AFI_UnPackInitInput( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(AFI_InitInputType), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  OutData%NumAFfiles = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%UA_Model = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%NumCoefs = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%InCol_Alfa = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%InCol_Cl = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%InCol_Cd = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%InCol_Cm = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%InCol_Cpmin = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE AFI_UnPackInitInput

 SUBROUTINE AFI_CopyInitOutput( SrcInitOutputData, DstInitOutputData, CtrlCode, ErrStat, ErrMsg )
   TYPE(AFI_InitOutputType), INTENT(IN) :: SrcInitOutputData
   TYPE(AFI_InitOutputType), INTENT(INOUT) :: DstInitOutputData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: i2, i2_l, i2_u  !  bounds (upper/lower) for an array dimension 2
   INTEGER(IntKi)                 :: i3, i3_l, i3_u  !  bounds (upper/lower) for an array dimension 3
   INTEGER(IntKi)                 :: i4, i4_l, i4_u  !  bounds (upper/lower) for an array dimension 4
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(1024)                :: ErrMsg2
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
      CALL NWTC_Library_Copyprogdesc( SrcInitOutputData%Ver, DstInitOutputData%Ver, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,'AFI_CopyInitOutput:Ver')
         IF (ErrStat>=AbortErrLev) RETURN
 END SUBROUTINE AFI_CopyInitOutput

 SUBROUTINE AFI_DestroyInitOutput( InitOutputData, ErrStat, ErrMsg )
  TYPE(AFI_InitOutputType), INTENT(INOUT) :: InitOutputData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
  CALL NWTC_Library_Destroyprogdesc( InitOutputData%Ver, ErrStat, ErrMsg )
 END SUBROUTINE AFI_DestroyInitOutput

 SUBROUTINE AFI_PackInitOutput( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(AFI_InitOutputType),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  REAL(ReKi),     ALLOCATABLE :: Re_Ver_Buf(:)
  REAL(DbKi),     ALLOCATABLE :: Db_Ver_Buf(:)
  INTEGER(IntKi), ALLOCATABLE :: Int_Ver_Buf(:)
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  CALL NWTC_Library_Packprogdesc( Re_Ver_Buf, Db_Ver_Buf, Int_Ver_Buf, InData%Ver, ErrStat, ErrMsg, .TRUE. ) ! Ver 
  IF(ALLOCATED(Re_Ver_Buf)) Re_BufSz  = Re_BufSz  + SIZE( Re_Ver_Buf  ) ! Ver
  IF(ALLOCATED(Db_Ver_Buf)) Db_BufSz  = Db_BufSz  + SIZE( Db_Ver_Buf  ) ! Ver
  IF(ALLOCATED(Int_Ver_Buf))Int_BufSz = Int_BufSz + SIZE( Int_Ver_Buf ) ! Ver
  IF(ALLOCATED(Re_Ver_Buf))  DEALLOCATE(Re_Ver_Buf)
  IF(ALLOCATED(Db_Ver_Buf))  DEALLOCATE(Db_Ver_Buf)
  IF(ALLOCATED(Int_Ver_Buf)) DEALLOCATE(Int_Ver_Buf)
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  CALL NWTC_Library_Packprogdesc( Re_Ver_Buf, Db_Ver_Buf, Int_Ver_Buf, InData%Ver, ErrStat, ErrMsg, OnlySize ) ! Ver 
  IF(ALLOCATED(Re_Ver_Buf)) THEN
    IF ( .NOT. OnlySize ) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_Ver_Buf)-1 ) = Re_Ver_Buf
    Re_Xferred = Re_Xferred + SIZE(Re_Ver_Buf)
  ENDIF
  IF(ALLOCATED(Db_Ver_Buf)) THEN
    IF ( .NOT. OnlySize ) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_Ver_Buf)-1 ) = Db_Ver_Buf
    Db_Xferred = Db_Xferred + SIZE(Db_Ver_Buf)
  ENDIF
  IF(ALLOCATED(Int_Ver_Buf)) THEN
    IF ( .NOT. OnlySize ) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_Ver_Buf)-1 ) = Int_Ver_Buf
    Int_Xferred = Int_Xferred + SIZE(Int_Ver_Buf)
  ENDIF
  IF( ALLOCATED(Re_Ver_Buf) )  DEALLOCATE(Re_Ver_Buf)
  IF( ALLOCATED(Db_Ver_Buf) )  DEALLOCATE(Db_Ver_Buf)
  IF( ALLOCATED(Int_Ver_Buf) ) DEALLOCATE(Int_Ver_Buf)
 END SUBROUTINE AFI_PackInitOutput

 SUBROUTINE AFI_UnPackInitOutput( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(AFI_InitOutputType), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
  REAL(ReKi),    ALLOCATABLE :: Re_Ver_Buf(:)
  REAL(DbKi),    ALLOCATABLE :: Db_Ver_Buf(:)
  INTEGER(IntKi),    ALLOCATABLE :: Int_Ver_Buf(:)
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
 ! first call NWTC_Library_Packprogdesc to get correctly sized buffers for unpacking
  CALL NWTC_Library_Packprogdesc( Re_Ver_Buf, Db_Ver_Buf, Int_Ver_Buf, OutData%Ver, ErrStat, ErrMsg, .TRUE. ) ! Ver 
  IF(ALLOCATED(Re_Ver_Buf)) THEN
    Re_Ver_Buf = ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_Ver_Buf)-1 )
    Re_Xferred = Re_Xferred + SIZE(Re_Ver_Buf)
  ENDIF
  IF(ALLOCATED(Db_Ver_Buf)) THEN
    Db_Ver_Buf = DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_Ver_Buf)-1 )
    Db_Xferred = Db_Xferred + SIZE(Db_Ver_Buf)
  ENDIF
  IF(ALLOCATED(Int_Ver_Buf)) THEN
    Int_Ver_Buf = IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_Ver_Buf)-1 )
    Int_Xferred = Int_Xferred + SIZE(Int_Ver_Buf)
  ENDIF
  CALL NWTC_Library_UnPackprogdesc( Re_Ver_Buf, Db_Ver_Buf, Int_Ver_Buf, OutData%Ver, ErrStat, ErrMsg ) ! Ver 
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE AFI_UnPackInitOutput

 SUBROUTINE AFI_CopyContState( SrcContStateData, DstContStateData, CtrlCode, ErrStat, ErrMsg )
   TYPE(AFI_ContinuousStateType), INTENT(IN) :: SrcContStateData
   TYPE(AFI_ContinuousStateType), INTENT(INOUT) :: DstContStateData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: i2, i2_l, i2_u  !  bounds (upper/lower) for an array dimension 2
   INTEGER(IntKi)                 :: i3, i3_l, i3_u  !  bounds (upper/lower) for an array dimension 3
   INTEGER(IntKi)                 :: i4, i4_l, i4_u  !  bounds (upper/lower) for an array dimension 4
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(1024)                :: ErrMsg2
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
   DstContStateData%DummyContState = SrcContStateData%DummyContState
 END SUBROUTINE AFI_CopyContState

 SUBROUTINE AFI_DestroyContState( ContStateData, ErrStat, ErrMsg )
  TYPE(AFI_ContinuousStateType), INTENT(INOUT) :: ContStateData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
 END SUBROUTINE AFI_DestroyContState

 SUBROUTINE AFI_PackContState( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(AFI_ContinuousStateType),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  Re_BufSz   = Re_BufSz   + 1  ! DummyContState
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%DummyContState )
  Re_Xferred   = Re_Xferred   + 1
 END SUBROUTINE AFI_PackContState

 SUBROUTINE AFI_UnPackContState( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(AFI_ContinuousStateType), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  OutData%DummyContState = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE AFI_UnPackContState

 SUBROUTINE AFI_CopyDiscState( SrcDiscStateData, DstDiscStateData, CtrlCode, ErrStat, ErrMsg )
   TYPE(AFI_DiscreteStateType), INTENT(IN) :: SrcDiscStateData
   TYPE(AFI_DiscreteStateType), INTENT(INOUT) :: DstDiscStateData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: i2, i2_l, i2_u  !  bounds (upper/lower) for an array dimension 2
   INTEGER(IntKi)                 :: i3, i3_l, i3_u  !  bounds (upper/lower) for an array dimension 3
   INTEGER(IntKi)                 :: i4, i4_l, i4_u  !  bounds (upper/lower) for an array dimension 4
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(1024)                :: ErrMsg2
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
   DstDiscStateData%DummyDiscState = SrcDiscStateData%DummyDiscState
 END SUBROUTINE AFI_CopyDiscState

 SUBROUTINE AFI_DestroyDiscState( DiscStateData, ErrStat, ErrMsg )
  TYPE(AFI_DiscreteStateType), INTENT(INOUT) :: DiscStateData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
 END SUBROUTINE AFI_DestroyDiscState

 SUBROUTINE AFI_PackDiscState( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(AFI_DiscreteStateType),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  Re_BufSz   = Re_BufSz   + 1  ! DummyDiscState
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%DummyDiscState )
  Re_Xferred   = Re_Xferred   + 1
 END SUBROUTINE AFI_PackDiscState

 SUBROUTINE AFI_UnPackDiscState( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(AFI_DiscreteStateType), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  OutData%DummyDiscState = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE AFI_UnPackDiscState

 SUBROUTINE AFI_CopyConstrState( SrcConstrStateData, DstConstrStateData, CtrlCode, ErrStat, ErrMsg )
   TYPE(AFI_ConstraintStateType), INTENT(IN) :: SrcConstrStateData
   TYPE(AFI_ConstraintStateType), INTENT(INOUT) :: DstConstrStateData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: i2, i2_l, i2_u  !  bounds (upper/lower) for an array dimension 2
   INTEGER(IntKi)                 :: i3, i3_l, i3_u  !  bounds (upper/lower) for an array dimension 3
   INTEGER(IntKi)                 :: i4, i4_l, i4_u  !  bounds (upper/lower) for an array dimension 4
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(1024)                :: ErrMsg2
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
   DstConstrStateData%DummyConstrState = SrcConstrStateData%DummyConstrState
 END SUBROUTINE AFI_CopyConstrState

 SUBROUTINE AFI_DestroyConstrState( ConstrStateData, ErrStat, ErrMsg )
  TYPE(AFI_ConstraintStateType), INTENT(INOUT) :: ConstrStateData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
 END SUBROUTINE AFI_DestroyConstrState

 SUBROUTINE AFI_PackConstrState( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(AFI_ConstraintStateType),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  Re_BufSz   = Re_BufSz   + 1  ! DummyConstrState
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%DummyConstrState )
  Re_Xferred   = Re_Xferred   + 1
 END SUBROUTINE AFI_PackConstrState

 SUBROUTINE AFI_UnPackConstrState( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(AFI_ConstraintStateType), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  OutData%DummyConstrState = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE AFI_UnPackConstrState

 SUBROUTINE AFI_CopyOtherState( SrcOtherStateData, DstOtherStateData, CtrlCode, ErrStat, ErrMsg )
   TYPE(AFI_OtherStateType), INTENT(IN) :: SrcOtherStateData
   TYPE(AFI_OtherStateType), INTENT(INOUT) :: DstOtherStateData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: i2, i2_l, i2_u  !  bounds (upper/lower) for an array dimension 2
   INTEGER(IntKi)                 :: i3, i3_l, i3_u  !  bounds (upper/lower) for an array dimension 3
   INTEGER(IntKi)                 :: i4, i4_l, i4_u  !  bounds (upper/lower) for an array dimension 4
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(1024)                :: ErrMsg2
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
   DstOtherStateData%IntCl = SrcOtherStateData%IntCl
   DstOtherStateData%IntCd = SrcOtherStateData%IntCd
   DstOtherStateData%IntCm = SrcOtherStateData%IntCm
   DstOtherStateData%IntCpmin = SrcOtherStateData%IntCpmin
   DstOtherStateData%AFfile = SrcOtherStateData%AFfile
 END SUBROUTINE AFI_CopyOtherState

 SUBROUTINE AFI_DestroyOtherState( OtherStateData, ErrStat, ErrMsg )
  TYPE(AFI_OtherStateType), INTENT(INOUT) :: OtherStateData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
 END SUBROUTINE AFI_DestroyOtherState

 SUBROUTINE AFI_PackOtherState( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(AFI_OtherStateType),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  Int_BufSz  = Int_BufSz  + 1  ! IntCl
  Int_BufSz  = Int_BufSz  + 1  ! IntCd
  Int_BufSz  = Int_BufSz  + 1  ! IntCm
  Int_BufSz  = Int_BufSz  + 1  ! IntCpmin
  Int_BufSz  = Int_BufSz  + 1  ! AFfile
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = TRANSFER( (InData%IntCl ), IntKiBuf(1), 1)
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = TRANSFER( (InData%IntCd ), IntKiBuf(1), 1)
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = TRANSFER( (InData%IntCm ), IntKiBuf(1), 1)
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = TRANSFER( (InData%IntCpmin ), IntKiBuf(1), 1)
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%AFfile )
  Int_Xferred   = Int_Xferred   + 1
 END SUBROUTINE AFI_PackOtherState

 SUBROUTINE AFI_UnPackOtherState( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(AFI_OtherStateType), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  OutData%AFfile = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE AFI_UnPackOtherState

 SUBROUTINE AFI_CopyParam( SrcParamData, DstParamData, CtrlCode, ErrStat, ErrMsg )
   TYPE(AFI_ParameterType), INTENT(IN) :: SrcParamData
   TYPE(AFI_ParameterType), INTENT(INOUT) :: DstParamData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: i2, i2_l, i2_u  !  bounds (upper/lower) for an array dimension 2
   INTEGER(IntKi)                 :: i3, i3_l, i3_u  !  bounds (upper/lower) for an array dimension 3
   INTEGER(IntKi)                 :: i4, i4_l, i4_u  !  bounds (upper/lower) for an array dimension 4
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(1024)                :: ErrMsg2
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
   DstParamData%ColCd = SrcParamData%ColCd
   DstParamData%ColCl = SrcParamData%ColCl
   DstParamData%ColCm = SrcParamData%ColCm
   DstParamData%ColCpmin = SrcParamData%ColCpmin
IF (ALLOCATED(SrcParamData%AFInfo)) THEN
   i1_l = LBOUND(SrcParamData%AFInfo,1)
   i1_u = UBOUND(SrcParamData%AFInfo,1)
   IF (.NOT. ALLOCATED(DstParamData%AFInfo)) THEN 
      ALLOCATE(DstParamData%AFInfo(i1_l:i1_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%AFInfo.', ErrStat, ErrMsg,'AFI_CopyParam')
         RETURN
      END IF
   END IF
   DO i1 = LBOUND(SrcParamData%AFInfo,1), UBOUND(SrcParamData%AFInfo,1)
      CALL AFI_Copyafinfotype( SrcParamData%AFInfo(i1), DstParamData%AFInfo(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,'AFI_CopyParam:AFInfo(i1)')
         IF (ErrStat>=AbortErrLev) RETURN
   ENDDO
ENDIF
 END SUBROUTINE AFI_CopyParam

 SUBROUTINE AFI_DestroyParam( ParamData, ErrStat, ErrMsg )
  TYPE(AFI_ParameterType), INTENT(INOUT) :: ParamData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
IF (ALLOCATED(ParamData%AFInfo)) THEN
DO i1 = LBOUND(ParamData%AFInfo,1), UBOUND(ParamData%AFInfo,1)
  CALL AFI_Destroyafinfotype( ParamData%AFInfo(i1), ErrStat, ErrMsg )
ENDDO
   DEALLOCATE(ParamData%AFInfo)
ENDIF
 END SUBROUTINE AFI_DestroyParam

 SUBROUTINE AFI_PackParam( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(AFI_ParameterType),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  REAL(ReKi),     ALLOCATABLE :: Re_AFInfo_Buf(:)
  REAL(DbKi),     ALLOCATABLE :: Db_AFInfo_Buf(:)
  INTEGER(IntKi), ALLOCATABLE :: Int_AFInfo_Buf(:)
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  Int_BufSz  = Int_BufSz  + 1  ! ColCd
  Int_BufSz  = Int_BufSz  + 1  ! ColCl
  Int_BufSz  = Int_BufSz  + 1  ! ColCm
  Int_BufSz  = Int_BufSz  + 1  ! ColCpmin
DO i1 = LBOUND(InData%AFInfo,1), UBOUND(InData%AFInfo,1)
  CALL AFI_Packafinfotype( Re_AFInfo_Buf, Db_AFInfo_Buf, Int_AFInfo_Buf, InData%AFInfo(i1), ErrStat, ErrMsg, .TRUE. ) ! AFInfo 
  IF(ALLOCATED(Re_AFInfo_Buf)) Re_BufSz  = Re_BufSz  + SIZE( Re_AFInfo_Buf  ) ! AFInfo
  IF(ALLOCATED(Db_AFInfo_Buf)) Db_BufSz  = Db_BufSz  + SIZE( Db_AFInfo_Buf  ) ! AFInfo
  IF(ALLOCATED(Int_AFInfo_Buf))Int_BufSz = Int_BufSz + SIZE( Int_AFInfo_Buf ) ! AFInfo
  IF(ALLOCATED(Re_AFInfo_Buf))  DEALLOCATE(Re_AFInfo_Buf)
  IF(ALLOCATED(Db_AFInfo_Buf))  DEALLOCATE(Db_AFInfo_Buf)
  IF(ALLOCATED(Int_AFInfo_Buf)) DEALLOCATE(Int_AFInfo_Buf)
ENDDO
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%ColCd )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%ColCl )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%ColCm )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%ColCpmin )
  Int_Xferred   = Int_Xferred   + 1
DO i1 = LBOUND(InData%AFInfo,1), UBOUND(InData%AFInfo,1)
  CALL AFI_Packafinfotype( Re_AFInfo_Buf, Db_AFInfo_Buf, Int_AFInfo_Buf, InData%AFInfo(i1), ErrStat, ErrMsg, OnlySize ) ! AFInfo 
  IF(ALLOCATED(Re_AFInfo_Buf)) THEN
    IF ( .NOT. OnlySize ) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_AFInfo_Buf)-1 ) = Re_AFInfo_Buf
    Re_Xferred = Re_Xferred + SIZE(Re_AFInfo_Buf)
  ENDIF
  IF(ALLOCATED(Db_AFInfo_Buf)) THEN
    IF ( .NOT. OnlySize ) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_AFInfo_Buf)-1 ) = Db_AFInfo_Buf
    Db_Xferred = Db_Xferred + SIZE(Db_AFInfo_Buf)
  ENDIF
  IF(ALLOCATED(Int_AFInfo_Buf)) THEN
    IF ( .NOT. OnlySize ) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_AFInfo_Buf)-1 ) = Int_AFInfo_Buf
    Int_Xferred = Int_Xferred + SIZE(Int_AFInfo_Buf)
  ENDIF
  IF( ALLOCATED(Re_AFInfo_Buf) )  DEALLOCATE(Re_AFInfo_Buf)
  IF( ALLOCATED(Db_AFInfo_Buf) )  DEALLOCATE(Db_AFInfo_Buf)
  IF( ALLOCATED(Int_AFInfo_Buf) ) DEALLOCATE(Int_AFInfo_Buf)
ENDDO
 END SUBROUTINE AFI_PackParam

 SUBROUTINE AFI_UnPackParam( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(AFI_ParameterType), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
  REAL(ReKi),    ALLOCATABLE :: Re_AFInfo_Buf(:)
  REAL(DbKi),    ALLOCATABLE :: Db_AFInfo_Buf(:)
  INTEGER(IntKi),    ALLOCATABLE :: Int_AFInfo_Buf(:)
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  OutData%ColCd = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%ColCl = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%ColCm = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%ColCpmin = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
DO i1 = LBOUND(OutData%AFInfo,1), UBOUND(OutData%AFInfo,1)
 ! first call AFI_Packafinfotype to get correctly sized buffers for unpacking
  CALL AFI_Packafinfotype( Re_AFInfo_Buf, Db_AFInfo_Buf, Int_AFInfo_Buf, OutData%AFInfo(i1), ErrStat, ErrMsg, .TRUE. ) ! AFInfo 
  IF(ALLOCATED(Re_AFInfo_Buf)) THEN
    Re_AFInfo_Buf = ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_AFInfo_Buf)-1 )
    Re_Xferred = Re_Xferred + SIZE(Re_AFInfo_Buf)
  ENDIF
  IF(ALLOCATED(Db_AFInfo_Buf)) THEN
    Db_AFInfo_Buf = DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_AFInfo_Buf)-1 )
    Db_Xferred = Db_Xferred + SIZE(Db_AFInfo_Buf)
  ENDIF
  IF(ALLOCATED(Int_AFInfo_Buf)) THEN
    Int_AFInfo_Buf = IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_AFInfo_Buf)-1 )
    Int_Xferred = Int_Xferred + SIZE(Int_AFInfo_Buf)
  ENDIF
  CALL AFI_UnPackafinfotype( Re_AFInfo_Buf, Db_AFInfo_Buf, Int_AFInfo_Buf, OutData%AFInfo(i1), ErrStat, ErrMsg ) ! AFInfo 
ENDDO
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE AFI_UnPackParam

 SUBROUTINE AFI_CopyInput( SrcInputData, DstInputData, CtrlCode, ErrStat, ErrMsg )
   TYPE(AFI_InputType), INTENT(IN) :: SrcInputData
   TYPE(AFI_InputType), INTENT(INOUT) :: DstInputData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: i2, i2_l, i2_u  !  bounds (upper/lower) for an array dimension 2
   INTEGER(IntKi)                 :: i3, i3_l, i3_u  !  bounds (upper/lower) for an array dimension 3
   INTEGER(IntKi)                 :: i4, i4_l, i4_u  !  bounds (upper/lower) for an array dimension 4
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(1024)                :: ErrMsg2
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
   DstInputData%AoA = SrcInputData%AoA
   DstInputData%Ctrl = SrcInputData%Ctrl
   DstInputData%Re = SrcInputData%Re
 END SUBROUTINE AFI_CopyInput

 SUBROUTINE AFI_DestroyInput( InputData, ErrStat, ErrMsg )
  TYPE(AFI_InputType), INTENT(INOUT) :: InputData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
 END SUBROUTINE AFI_DestroyInput

 SUBROUTINE AFI_PackInput( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(AFI_InputType),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  Re_BufSz   = Re_BufSz   + 1  ! AoA
  Re_BufSz   = Re_BufSz   + 1  ! Ctrl
  Re_BufSz   = Re_BufSz   + 1  ! Re
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%AoA )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%Ctrl )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%Re )
  Re_Xferred   = Re_Xferred   + 1
 END SUBROUTINE AFI_PackInput

 SUBROUTINE AFI_UnPackInput( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(AFI_InputType), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  OutData%AoA = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%Ctrl = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%Re = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE AFI_UnPackInput

 SUBROUTINE AFI_CopyOutput( SrcOutputData, DstOutputData, CtrlCode, ErrStat, ErrMsg )
   TYPE(AFI_OutputType), INTENT(IN) :: SrcOutputData
   TYPE(AFI_OutputType), INTENT(INOUT) :: DstOutputData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: i2, i2_l, i2_u  !  bounds (upper/lower) for an array dimension 2
   INTEGER(IntKi)                 :: i3, i3_l, i3_u  !  bounds (upper/lower) for an array dimension 3
   INTEGER(IntKi)                 :: i4, i4_l, i4_u  !  bounds (upper/lower) for an array dimension 4
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(1024)                :: ErrMsg2
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
   DstOutputData%Cl = SrcOutputData%Cl
   DstOutputData%Cd = SrcOutputData%Cd
   DstOutputData%Cm = SrcOutputData%Cm
   DstOutputData%Cpmin = SrcOutputData%Cpmin
 END SUBROUTINE AFI_CopyOutput

 SUBROUTINE AFI_DestroyOutput( OutputData, ErrStat, ErrMsg )
  TYPE(AFI_OutputType), INTENT(INOUT) :: OutputData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
 END SUBROUTINE AFI_DestroyOutput

 SUBROUTINE AFI_PackOutput( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(AFI_OutputType),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  Re_BufSz   = Re_BufSz   + 1  ! Cl
  Re_BufSz   = Re_BufSz   + 1  ! Cd
  Re_BufSz   = Re_BufSz   + 1  ! Cm
  Re_BufSz   = Re_BufSz   + 1  ! Cpmin
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%Cl )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%Cd )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%Cm )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%Cpmin )
  Re_Xferred   = Re_Xferred   + 1
 END SUBROUTINE AFI_PackOutput

 SUBROUTINE AFI_UnPackOutput( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(AFI_OutputType), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  OutData%Cl = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%Cd = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%Cm = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%Cpmin = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE AFI_UnPackOutput


 SUBROUTINE AFI_Input_ExtrapInterp(u, tin, u_out, tin_out, ErrStat, ErrMsg )
!
! This subroutine calculates a extrapolated (or interpolated) input u_out at time t_out, from previous/future time
! values of u (which has values associated with times in t).  Order of the interpolation is given by the size of u
!
!  expressions below based on either
!
!  f(t) = a
!  f(t) = a + b * t, or
!  f(t) = a + b * t + c * t**2
!
!  where a, b and c are determined as the solution to
!  f(t1) = u1, f(t2) = u2, f(t3) = u3  (as appropriate)
!
!..................................................................................................................................

 TYPE(AFI_inputtype), INTENT(INOUT)  :: u(:)      ! Inputs at t1 > t2 > t3
 REAL(DbKi),         INTENT(IN   )  :: tin(:)      ! Times associated with the inputs
 TYPE(AFI_inputtype), INTENT(INOUT)  :: u_out     ! Inputs at tin_out
 REAL(DbKi),         INTENT(IN   )  :: tin_out     ! time to be extrap/interp'd to
 INTEGER(IntKi),     INTENT(  OUT)  :: ErrStat   ! Error status of the operation
 CHARACTER(*),       INTENT(  OUT)  :: ErrMsg    ! Error message if ErrStat /= ErrID_None
   ! local variables
 REAL(DbKi) :: t(SIZE(tin))    ! Times associated with the inputs
 REAL(DbKi) :: t_out           ! Time to which to be extrap/interpd
 INTEGER(IntKi)                 :: order    ! order of polynomial fit (max 2)
 REAL(DbKi)                                 :: b0       ! temporary for extrapolation/interpolation
 REAL(DbKi)                                 :: c0       ! temporary for extrapolation/interpolation
 INTEGER(IntKi)                             :: ErrStat2 ! local errors
 CHARACTER(1024)                            :: ErrMsg2  ! local errors
    ! Initialize ErrStat
 ErrStat = ErrID_None
 ErrMsg  = ""
    ! we'll subtract a constant from the times to resolve some 
    ! numerical issues when t gets large (and to simplify the equations)
 t = tin - tin(1)
 t_out = tin_out - tin(1)

 if ( size(t) .ne. size(u)) then
    ErrStat = ErrID_Fatal
    ErrMsg = ' Error in AFI_Input_ExtrapInterp: size(t) must equal size(u) '
    RETURN
 endif
 if (size(u) .gt. 3) then
    ErrStat = ErrID_Fatal
    ErrMsg  = ' Error in AFI_Input_ExtrapInterp: size(u) must be less than 4 '
    RETURN
 endif
 order = SIZE(u) - 1
 IF ( order .eq. 0 ) THEN
  u_out%AoA = u(1)%AoA
  u_out%Ctrl = u(1)%Ctrl
  u_out%Re = u(1)%Re
 ELSE IF ( order .eq. 1 ) THEN
  IF ( EqualRealNos( t(1), t(2) ) ) THEN
    ErrStat = ErrID_Fatal
    ErrMsg  = ' Error in AFI_Input_ExtrapInterp: t(1) must not equal t(2) to avoid a division-by-zero error.'
    RETURN
  END IF
  b0 = -(u(1)%AoA - u(2)%AoA)/t(2)
  u_out%AoA = u(1)%AoA + b0 * t_out
  b0 = -(u(1)%Ctrl - u(2)%Ctrl)/t(2)
  u_out%Ctrl = u(1)%Ctrl + b0 * t_out
  b0 = -(u(1)%Re - u(2)%Re)/t(2)
  u_out%Re = u(1)%Re + b0 * t_out
 ELSE IF ( order .eq. 2 ) THEN
  IF ( EqualRealNos( t(1), t(2) ) ) THEN
    ErrStat = ErrID_Fatal
    ErrMsg  = ' Error in AFI_Input_ExtrapInterp: t(1) must not equal t(2) to avoid a division-by-zero error.'
    RETURN
  END IF
  IF ( EqualRealNos( t(2), t(3) ) ) THEN
    ErrStat = ErrID_Fatal
    ErrMsg  = ' Error in AFI_Input_ExtrapInterp: t(2) must not equal t(3) to avoid a division-by-zero error.'
    RETURN
  END IF
  IF ( EqualRealNos( t(1), t(3) ) ) THEN
    ErrStat = ErrID_Fatal
    ErrMsg  = ' Error in AFI_Input_ExtrapInterp: t(1) must not equal t(3) to avoid a division-by-zero error.'
    RETURN
  END IF
  b0 = (t(3)**2*(u(1)%AoA - u(2)%AoA) + t(2)**2*(-u(1)%AoA + u(3)%AoA))/(t(2)*t(3)*(t(2) - t(3)))
  c0 = ( (t(2)-t(3))*u(1)%AoA + t(3)*u(2)%AoA - t(2)*u(3)%AoA ) / (t(2)*t(3)*(t(2) - t(3)))
  u_out%AoA = u(1)%AoA + b0 * t_out + c0 * t_out**2
  b0 = (t(3)**2*(u(1)%Ctrl - u(2)%Ctrl) + t(2)**2*(-u(1)%Ctrl + u(3)%Ctrl))/(t(2)*t(3)*(t(2) - t(3)))
  c0 = ( (t(2)-t(3))*u(1)%Ctrl + t(3)*u(2)%Ctrl - t(2)*u(3)%Ctrl ) / (t(2)*t(3)*(t(2) - t(3)))
  u_out%Ctrl = u(1)%Ctrl + b0 * t_out + c0 * t_out**2
  b0 = (t(3)**2*(u(1)%Re - u(2)%Re) + t(2)**2*(-u(1)%Re + u(3)%Re))/(t(2)*t(3)*(t(2) - t(3)))
  c0 = ( (t(2)-t(3))*u(1)%Re + t(3)*u(2)%Re - t(2)*u(3)%Re ) / (t(2)*t(3)*(t(2) - t(3)))
  u_out%Re = u(1)%Re + b0 * t_out + c0 * t_out**2
 ELSE 
   ErrStat = ErrID_Fatal
   ErrMsg = ' order must be less than 3 in AFI_Input_ExtrapInterp '
   RETURN
 ENDIF 
 END SUBROUTINE AFI_Input_ExtrapInterp


 SUBROUTINE AFI_Output_ExtrapInterp(u, tin, u_out, tin_out, ErrStat, ErrMsg )
!
! This subroutine calculates a extrapolated (or interpolated) input u_out at time t_out, from previous/future time
! values of u (which has values associated with times in t).  Order of the interpolation is given by the size of u
!
!  expressions below based on either
!
!  f(t) = a
!  f(t) = a + b * t, or
!  f(t) = a + b * t + c * t**2
!
!  where a, b and c are determined as the solution to
!  f(t1) = u1, f(t2) = u2, f(t3) = u3  (as appropriate)
!
!..................................................................................................................................

 TYPE(AFI_outputtype), INTENT(INOUT)  :: u(:)      ! Inputs at t1 > t2 > t3
 REAL(DbKi),         INTENT(IN   )  :: tin(:)      ! Times associated with the inputs
 TYPE(AFI_outputtype), INTENT(INOUT)  :: u_out     ! Inputs at tin_out
 REAL(DbKi),         INTENT(IN   )  :: tin_out     ! time to be extrap/interp'd to
 INTEGER(IntKi),     INTENT(  OUT)  :: ErrStat   ! Error status of the operation
 CHARACTER(*),       INTENT(  OUT)  :: ErrMsg    ! Error message if ErrStat /= ErrID_None
   ! local variables
 REAL(DbKi) :: t(SIZE(tin))    ! Times associated with the inputs
 REAL(DbKi) :: t_out           ! Time to which to be extrap/interpd
 INTEGER(IntKi)                 :: order    ! order of polynomial fit (max 2)
 REAL(DbKi)                                 :: b0       ! temporary for extrapolation/interpolation
 REAL(DbKi)                                 :: c0       ! temporary for extrapolation/interpolation
 INTEGER(IntKi)                             :: ErrStat2 ! local errors
 CHARACTER(1024)                            :: ErrMsg2  ! local errors
    ! Initialize ErrStat
 ErrStat = ErrID_None
 ErrMsg  = ""
    ! we'll subtract a constant from the times to resolve some 
    ! numerical issues when t gets large (and to simplify the equations)
 t = tin - tin(1)
 t_out = tin_out - tin(1)

 if ( size(t) .ne. size(u)) then
    ErrStat = ErrID_Fatal
    ErrMsg = ' Error in AFI_Output_ExtrapInterp: size(t) must equal size(u) '
    RETURN
 endif
 if (size(u) .gt. 3) then
    ErrStat = ErrID_Fatal
    ErrMsg  = ' Error in AFI_Output_ExtrapInterp: size(u) must be less than 4 '
    RETURN
 endif
 order = SIZE(u) - 1
 IF ( order .eq. 0 ) THEN
  u_out%Cl = u(1)%Cl
  u_out%Cd = u(1)%Cd
  u_out%Cm = u(1)%Cm
  u_out%Cpmin = u(1)%Cpmin
 ELSE IF ( order .eq. 1 ) THEN
  IF ( EqualRealNos( t(1), t(2) ) ) THEN
    ErrStat = ErrID_Fatal
    ErrMsg  = ' Error in AFI_Output_ExtrapInterp: t(1) must not equal t(2) to avoid a division-by-zero error.'
    RETURN
  END IF
  b0 = -(u(1)%Cl - u(2)%Cl)/t(2)
  u_out%Cl = u(1)%Cl + b0 * t_out
  b0 = -(u(1)%Cd - u(2)%Cd)/t(2)
  u_out%Cd = u(1)%Cd + b0 * t_out
  b0 = -(u(1)%Cm - u(2)%Cm)/t(2)
  u_out%Cm = u(1)%Cm + b0 * t_out
  b0 = -(u(1)%Cpmin - u(2)%Cpmin)/t(2)
  u_out%Cpmin = u(1)%Cpmin + b0 * t_out
 ELSE IF ( order .eq. 2 ) THEN
  IF ( EqualRealNos( t(1), t(2) ) ) THEN
    ErrStat = ErrID_Fatal
    ErrMsg  = ' Error in AFI_Output_ExtrapInterp: t(1) must not equal t(2) to avoid a division-by-zero error.'
    RETURN
  END IF
  IF ( EqualRealNos( t(2), t(3) ) ) THEN
    ErrStat = ErrID_Fatal
    ErrMsg  = ' Error in AFI_Output_ExtrapInterp: t(2) must not equal t(3) to avoid a division-by-zero error.'
    RETURN
  END IF
  IF ( EqualRealNos( t(1), t(3) ) ) THEN
    ErrStat = ErrID_Fatal
    ErrMsg  = ' Error in AFI_Output_ExtrapInterp: t(1) must not equal t(3) to avoid a division-by-zero error.'
    RETURN
  END IF
  b0 = (t(3)**2*(u(1)%Cl - u(2)%Cl) + t(2)**2*(-u(1)%Cl + u(3)%Cl))/(t(2)*t(3)*(t(2) - t(3)))
  c0 = ( (t(2)-t(3))*u(1)%Cl + t(3)*u(2)%Cl - t(2)*u(3)%Cl ) / (t(2)*t(3)*(t(2) - t(3)))
  u_out%Cl = u(1)%Cl + b0 * t_out + c0 * t_out**2
  b0 = (t(3)**2*(u(1)%Cd - u(2)%Cd) + t(2)**2*(-u(1)%Cd + u(3)%Cd))/(t(2)*t(3)*(t(2) - t(3)))
  c0 = ( (t(2)-t(3))*u(1)%Cd + t(3)*u(2)%Cd - t(2)*u(3)%Cd ) / (t(2)*t(3)*(t(2) - t(3)))
  u_out%Cd = u(1)%Cd + b0 * t_out + c0 * t_out**2
  b0 = (t(3)**2*(u(1)%Cm - u(2)%Cm) + t(2)**2*(-u(1)%Cm + u(3)%Cm))/(t(2)*t(3)*(t(2) - t(3)))
  c0 = ( (t(2)-t(3))*u(1)%Cm + t(3)*u(2)%Cm - t(2)*u(3)%Cm ) / (t(2)*t(3)*(t(2) - t(3)))
  u_out%Cm = u(1)%Cm + b0 * t_out + c0 * t_out**2
  b0 = (t(3)**2*(u(1)%Cpmin - u(2)%Cpmin) + t(2)**2*(-u(1)%Cpmin + u(3)%Cpmin))/(t(2)*t(3)*(t(2) - t(3)))
  c0 = ( (t(2)-t(3))*u(1)%Cpmin + t(3)*u(2)%Cpmin - t(2)*u(3)%Cpmin ) / (t(2)*t(3)*(t(2) - t(3)))
  u_out%Cpmin = u(1)%Cpmin + b0 * t_out + c0 * t_out**2
 ELSE 
   ErrStat = ErrID_Fatal
   ErrMsg = ' order must be less than 3 in AFI_Output_ExtrapInterp '
   RETURN
 ENDIF 
 END SUBROUTINE AFI_Output_ExtrapInterp

END MODULE AirfoilInfo_Types
!ENDOFREGISTRYGENERATEDFILE
