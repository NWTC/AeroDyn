!STARTOFREGISTRYGENERATEDFILE './AeroDyn_Types.f90'
!
! WARNING This file is generated automatically by the FAST registry
! Do not edit.  Your changes to this file will be lost.
!
! FAST Registry (v2.05.00, 10-Jan-2015)
!*********************************************************************************************************************************
! AeroDyn_Types
!.................................................................................................................................
! This file is part of AeroDyn.
!
! Copyright (C) 2012-2015 National Renewable Energy Laboratory
!
! Licensed under the Apache License, Version 2.0 (the "License");
! you may not use this file except in compliance with the License.
! You may obtain a copy of the License at
!
!     http://www.apache.org/licenses/LICENSE-2.0
!
! Unless required by applicable law or agreed to in writing, software
! distributed under the License is distributed on an "AS IS" BASIS,
! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
! See the License for the specific language governing permissions and
! limitations under the License.
!
!
! W A R N I N G : This file was automatically generated from the FAST registry.  Changes made to this file may be lost.
!
!*********************************************************************************************************************************
MODULE AeroDyn_Types
! This module contains all of the user-defined types needed in AeroDyn. It also contains copy, destroy, pack, and
! unpack routines associated with each defined data type. This code will be generated by the FAST Registry.
!---------------------------------------------------------------------------------------------------------------------------------
USE AirfoilInfo_Types
USE BEMT_Types
USE NWTC_Library
IMPLICIT NONE
! =========  AD_InitInputType  =======
  TYPE, PUBLIC :: AD_InitInputType
    REAL(DbKi)  :: DT      ! time step [s]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: chord      ! Chord length at node [m]
    INTEGER(IntKi)  :: numBlades      ! Number of blades [-]
    REAL(ReKi)  :: airDens      ! Air density [kg/m^3]
    REAL(ReKi)  :: kinVisc      ! Kinematic air viscosity [m^2/s]
    INTEGER(IntKi)  :: skewWakeMod      ! Skewed-wake correction model [switch] {0: no correction, 1: Pitt and Peters, 2: Teknikgruppen AB, 3: Coupled model} [-]
    LOGICAL  :: useTipLoss      ! Use the Prandtl tip-loss model?  [flag] [-]
    LOGICAL  :: useHubLoss      ! Use the Prandtl hub-loss model?  [flag] [-]
    LOGICAL  :: useInduction      ! Include induction in BEM calculations [flag] { If FALSE then useTanInd will be set to FALSE} [-]
    LOGICAL  :: useTanInd      ! Include tangential induction in BEM calculations [flag] [-]
    LOGICAL  :: useAIDrag      ! Include the drag term in the axial-induction calculation?  [flag] [-]
    LOGICAL  :: useTIDrag      ! Include the drag term in the tangential-induction calculation?  Ignored if TanInd is False.  [flag] [-]
    INTEGER(IntKi)  :: numBladeNodes      ! Number of blade nodes used in the analysis [-]
    INTEGER(IntKi)  :: numReIterations      ! Number of iterations for finding the Reynolds number [-]
    INTEGER(IntKi)  :: maxIndIterations      ! Maximum number of iterations of induction factor solve [-]
    INTEGER(IntKi) , DIMENSION(:), ALLOCATABLE  :: AFindx      ! Index of airfoil data file for blade node location [array of numBladeNodes] [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: zHub      ! Distance to hub for each blade [m]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: zLocal      ! Distance to blade node, measured along the blade [m]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: zTip      ! Distance to blade tip, measured along the blade [m]
    TYPE(AFInfoType) , DIMENSION(:), ALLOCATABLE  :: AFInfo      ! Parameters for the airfoils [-]
    INTEGER(IntKi)  :: NumAF      ! Parameters for the BEMT module [-]
    CHARACTER(1024) , DIMENSION(:), ALLOCATABLE  :: AF_File      ! Parameters for the BEMT module [-]
    TYPE(BEMT_InitInputType)  :: BEMT      ! Parameters for the BEMT module [-]
    INTEGER(IntKi)  :: BEMT_SkewWakeMod      ! The BEMT module skewed wake model, set to 0 if BEMT is not being used [-]
  END TYPE AD_InitInputType
! =======================
! =========  AD_InitOutputType  =======
  TYPE, PUBLIC :: AD_InitOutputType
    TYPE(ProgDesc)  :: Version      !  [-]
    CHARACTER(15) , DIMENSION(:), ALLOCATABLE  :: WriteOutputHdr      !  [-]
    CHARACTER(15) , DIMENSION(:), ALLOCATABLE  :: WriteOutputUnt      !  [-]
  END TYPE AD_InitOutputType
! =======================
! =========  AD_ContinuousStateType  =======
  TYPE, PUBLIC :: AD_ContinuousStateType
    TYPE(BEMT_ContinuousStateType)  :: BEMT      ! Remove this variable if you have continuous states [-]
  END TYPE AD_ContinuousStateType
! =======================
! =========  AD_DiscreteStateType  =======
  TYPE, PUBLIC :: AD_DiscreteStateType
    TYPE(BEMT_DiscreteStateType)  :: BEMT      !  [-]
  END TYPE AD_DiscreteStateType
! =======================
! =========  AD_ConstraintStateType  =======
  TYPE, PUBLIC :: AD_ConstraintStateType
    TYPE(BEMT_ConstraintStateType)  :: BEMT      ! rad [-]
  END TYPE AD_ConstraintStateType
! =======================
! =========  AD_OtherStateType  =======
  TYPE, PUBLIC :: AD_OtherStateType
    TYPE(BEMT_OtherStateType)  :: BEMT      !  [-]
    TYPE(BEMT_OutputType)  :: BEMT_y      !  [-]
    TYPE(BEMT_InputType)  :: BEMT_u      !  [-]
  END TYPE AD_OtherStateType
! =======================
! =========  AD_ParameterType  =======
  TYPE, PUBLIC :: AD_ParameterType
    REAL(DbKi)  :: DT      ! time step [s]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: chord      ! Chord length at node [m]
    INTEGER(IntKi)  :: numBlades      ! Number of blades [-]
    REAL(ReKi)  :: airDens      ! Air density [kg/m^3]
    REAL(ReKi)  :: kinVisc      ! Kinematic air viscosity [m^2/s]
    INTEGER(IntKi)  :: skewWakeMod      ! Skewed-wake correction model [switch] {0: no correction, 1: Pitt and Peters, 2: Teknikgruppen AB, 3: Coupled model} [-]
    LOGICAL  :: useTipLoss      ! Use the Prandtl tip-loss model?  [flag] [-]
    LOGICAL  :: useHubLoss      ! Use the Prandtl hub-loss model?  [flag] [-]
    LOGICAL  :: useTanInd      ! Include tangential induction in BEM calculations [flag] [-]
    LOGICAL  :: useAIDrag      ! Include the drag term in the axial-induction calculation?  [flag] [-]
    LOGICAL  :: useTIDrag      ! Include the drag term in the tangential-induction calculation?  Ignored if TanInd is False.  [flag] [-]
    INTEGER(IntKi)  :: numBladeNodes      ! Number of blade nodes used in the analysis [-]
    INTEGER(IntKi)  :: numReIterations      ! Number of iterations for finding the Reynolds number [-]
    INTEGER(IntKi)  :: maxIndIterations      ! Maximum number of iterations of induction factor solve [-]
    INTEGER(IntKi) , DIMENSION(:), ALLOCATABLE  :: AFindx      ! Index of airfoil data file for blade node location [array of numBladeNodes] [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: tipLossConst      ! A constant computed during initialization based on B*(zTip-zLocal)/(2*zLocal) [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: hubLossConst      ! A constant computed during initialization based on B*(zLocal-zHub)/(2*zHub) [-]
    TYPE(AFInfoType) , DIMENSION(:), ALLOCATABLE  :: AFInfo      ! Parameters for the airfoils [-]
    TYPE(BEMT_ParameterType)  :: BEMT      ! Parameters for the BEMT module [-]
    INTEGER(IntKi)  :: NumAF      ! Parameters for the BEMT module [-]
    CHARACTER(1024) , DIMENSION(:), ALLOCATABLE  :: AF_File      ! Parameters for the BEMT module [-]
    TYPE(AFI_ParameterType)  :: AFI_Params      !  [-]
    INTEGER(IntKi)  :: NumOuts      ! Number of HydroDyn module-level outputs (not the total number including sub-modules [-]
    INTEGER(IntKi)  :: BEMT_SkewWakeMod      ! The BEMT module skewed wake model, set to 0 if BEMT is not being used [-]
  END TYPE AD_ParameterType
! =======================
! =========  AD_InputType  =======
  TYPE, PUBLIC :: AD_InputType
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: theta      ! Twist angle (includes all sources of twist)  [Array of size (numBlades, NumBlNds)] [rad]
    REAL(ReKi)  :: gamma      ! Yaw angle [rad]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: psi      ! Azimuth angle [rad]
    REAL(ReKi)  :: omega      ! Angular velocity of rotor [rad/s]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: Vx      ! Local axial velocity at node [m/s]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: Vy      ! Local tangential velocity at node [m/s]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: Vinf      ! Local freestream velocity at node [m/s]
    REAL(ReKi)  :: lambda      ! Average tip speed ratio for rotor disk [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: rTip      ! Radial distance from center-of-rotation to blade tip [m]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: rLocal      ! Radial distance from center-of-rotation to node [m]
  END TYPE AD_InputType
! =======================
! =========  AD_OutputType  =======
  TYPE, PUBLIC :: AD_OutputType
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: inducedVel      ! Total local induced velocity [m/s]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: phi      ! angle between the plane of rotation and the direction of the local wind [rad]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: WriteOutput      !  [-]
  END TYPE AD_OutputType
! =======================
CONTAINS
 SUBROUTINE AD_CopyInitInput( SrcInitInputData, DstInitInputData, CtrlCode, ErrStat, ErrMsg )
   TYPE(AD_InitInputType), INTENT(IN) :: SrcInitInputData
   TYPE(AD_InitInputType), INTENT(INOUT) :: DstInitInputData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: i2, i2_l, i2_u  !  bounds (upper/lower) for an array dimension 2
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(1024)                :: ErrMsg2
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
   DstInitInputData%DT = SrcInitInputData%DT
IF (ALLOCATED(SrcInitInputData%chord)) THEN
   i1_l = LBOUND(SrcInitInputData%chord,1)
   i1_u = UBOUND(SrcInitInputData%chord,1)
   i2_l = LBOUND(SrcInitInputData%chord,2)
   i2_u = UBOUND(SrcInitInputData%chord,2)
   IF (.NOT. ALLOCATED(DstInitInputData%chord)) THEN 
      ALLOCATE(DstInitInputData%chord(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInitInputData%chord.', ErrStat, ErrMsg,'AD_CopyInitInput')
         RETURN
      END IF
   END IF
   DstInitInputData%chord = SrcInitInputData%chord
ENDIF
   DstInitInputData%numBlades = SrcInitInputData%numBlades
   DstInitInputData%airDens = SrcInitInputData%airDens
   DstInitInputData%kinVisc = SrcInitInputData%kinVisc
   DstInitInputData%skewWakeMod = SrcInitInputData%skewWakeMod
   DstInitInputData%useTipLoss = SrcInitInputData%useTipLoss
   DstInitInputData%useHubLoss = SrcInitInputData%useHubLoss
   DstInitInputData%useInduction = SrcInitInputData%useInduction
   DstInitInputData%useTanInd = SrcInitInputData%useTanInd
   DstInitInputData%useAIDrag = SrcInitInputData%useAIDrag
   DstInitInputData%useTIDrag = SrcInitInputData%useTIDrag
   DstInitInputData%numBladeNodes = SrcInitInputData%numBladeNodes
   DstInitInputData%numReIterations = SrcInitInputData%numReIterations
   DstInitInputData%maxIndIterations = SrcInitInputData%maxIndIterations
IF (ALLOCATED(SrcInitInputData%AFindx)) THEN
   i1_l = LBOUND(SrcInitInputData%AFindx,1)
   i1_u = UBOUND(SrcInitInputData%AFindx,1)
   IF (.NOT. ALLOCATED(DstInitInputData%AFindx)) THEN 
      ALLOCATE(DstInitInputData%AFindx(i1_l:i1_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInitInputData%AFindx.', ErrStat, ErrMsg,'AD_CopyInitInput')
         RETURN
      END IF
   END IF
   DstInitInputData%AFindx = SrcInitInputData%AFindx
ENDIF
IF (ALLOCATED(SrcInitInputData%zHub)) THEN
   i1_l = LBOUND(SrcInitInputData%zHub,1)
   i1_u = UBOUND(SrcInitInputData%zHub,1)
   IF (.NOT. ALLOCATED(DstInitInputData%zHub)) THEN 
      ALLOCATE(DstInitInputData%zHub(i1_l:i1_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInitInputData%zHub.', ErrStat, ErrMsg,'AD_CopyInitInput')
         RETURN
      END IF
   END IF
   DstInitInputData%zHub = SrcInitInputData%zHub
ENDIF
IF (ALLOCATED(SrcInitInputData%zLocal)) THEN
   i1_l = LBOUND(SrcInitInputData%zLocal,1)
   i1_u = UBOUND(SrcInitInputData%zLocal,1)
   i2_l = LBOUND(SrcInitInputData%zLocal,2)
   i2_u = UBOUND(SrcInitInputData%zLocal,2)
   IF (.NOT. ALLOCATED(DstInitInputData%zLocal)) THEN 
      ALLOCATE(DstInitInputData%zLocal(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInitInputData%zLocal.', ErrStat, ErrMsg,'AD_CopyInitInput')
         RETURN
      END IF
   END IF
   DstInitInputData%zLocal = SrcInitInputData%zLocal
ENDIF
IF (ALLOCATED(SrcInitInputData%zTip)) THEN
   i1_l = LBOUND(SrcInitInputData%zTip,1)
   i1_u = UBOUND(SrcInitInputData%zTip,1)
   IF (.NOT. ALLOCATED(DstInitInputData%zTip)) THEN 
      ALLOCATE(DstInitInputData%zTip(i1_l:i1_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInitInputData%zTip.', ErrStat, ErrMsg,'AD_CopyInitInput')
         RETURN
      END IF
   END IF
   DstInitInputData%zTip = SrcInitInputData%zTip
ENDIF
IF (ALLOCATED(SrcInitInputData%AFInfo)) THEN
   i1_l = LBOUND(SrcInitInputData%AFInfo,1)
   i1_u = UBOUND(SrcInitInputData%AFInfo,1)
   IF (.NOT. ALLOCATED(DstInitInputData%AFInfo)) THEN 
      ALLOCATE(DstInitInputData%AFInfo(i1_l:i1_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInitInputData%AFInfo.', ErrStat, ErrMsg,'AD_CopyInitInput')
         RETURN
      END IF
   END IF
   DO i1 = LBOUND(SrcInitInputData%AFInfo,1), UBOUND(SrcInitInputData%AFInfo,1)
      CALL AFI_Copyafinfotype( SrcInitInputData%AFInfo(i1), DstInitInputData%AFInfo(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,'AD_CopyInitInput:AFInfo(i1)')
         IF (ErrStat>=AbortErrLev) RETURN
   ENDDO
ENDIF
   DstInitInputData%NumAF = SrcInitInputData%NumAF
IF (ALLOCATED(SrcInitInputData%AF_File)) THEN
   i1_l = LBOUND(SrcInitInputData%AF_File,1)
   i1_u = UBOUND(SrcInitInputData%AF_File,1)
   IF (.NOT. ALLOCATED(DstInitInputData%AF_File)) THEN 
      ALLOCATE(DstInitInputData%AF_File(i1_l:i1_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInitInputData%AF_File.', ErrStat, ErrMsg,'AD_CopyInitInput')
         RETURN
      END IF
   END IF
   DstInitInputData%AF_File = SrcInitInputData%AF_File
ENDIF
      CALL BEMT_CopyInitInput( SrcInitInputData%BEMT, DstInitInputData%BEMT, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,'AD_CopyInitInput:BEMT')
         IF (ErrStat>=AbortErrLev) RETURN
   DstInitInputData%BEMT_SkewWakeMod = SrcInitInputData%BEMT_SkewWakeMod
 END SUBROUTINE AD_CopyInitInput

 SUBROUTINE AD_DestroyInitInput( InitInputData, ErrStat, ErrMsg )
  TYPE(AD_InitInputType), INTENT(INOUT) :: InitInputData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
IF (ALLOCATED(InitInputData%chord)) THEN
   DEALLOCATE(InitInputData%chord)
ENDIF
IF (ALLOCATED(InitInputData%AFindx)) THEN
   DEALLOCATE(InitInputData%AFindx)
ENDIF
IF (ALLOCATED(InitInputData%zHub)) THEN
   DEALLOCATE(InitInputData%zHub)
ENDIF
IF (ALLOCATED(InitInputData%zLocal)) THEN
   DEALLOCATE(InitInputData%zLocal)
ENDIF
IF (ALLOCATED(InitInputData%zTip)) THEN
   DEALLOCATE(InitInputData%zTip)
ENDIF
IF (ALLOCATED(InitInputData%AFInfo)) THEN
DO i1 = LBOUND(InitInputData%AFInfo,1), UBOUND(InitInputData%AFInfo,1)
  CALL AFI_Destroyafinfotype( InitInputData%AFInfo(i1), ErrStat, ErrMsg )
ENDDO
   DEALLOCATE(InitInputData%AFInfo)
ENDIF
IF (ALLOCATED(InitInputData%AF_File)) THEN
   DEALLOCATE(InitInputData%AF_File)
ENDIF
  CALL BEMT_DestroyInitInput( InitInputData%BEMT, ErrStat, ErrMsg )
 END SUBROUTINE AD_DestroyInitInput

 SUBROUTINE AD_PackInitInput( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(AD_InitInputType),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  REAL(ReKi),     ALLOCATABLE :: Re_AFInfo_Buf(:)
  REAL(DbKi),     ALLOCATABLE :: Db_AFInfo_Buf(:)
  INTEGER(IntKi), ALLOCATABLE :: Int_AFInfo_Buf(:)
  REAL(ReKi),     ALLOCATABLE :: Re_BEMT_Buf(:)
  REAL(DbKi),     ALLOCATABLE :: Db_BEMT_Buf(:)
  INTEGER(IntKi), ALLOCATABLE :: Int_BEMT_Buf(:)
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  Db_BufSz   = Db_BufSz   + 1  ! DT
  IF ( ALLOCATED(InData%chord) )   Re_BufSz    = Re_BufSz    + SIZE( InData%chord )  ! chord 
  Int_BufSz  = Int_BufSz  + 1  ! numBlades
  Re_BufSz   = Re_BufSz   + 1  ! airDens
  Re_BufSz   = Re_BufSz   + 1  ! kinVisc
  Int_BufSz  = Int_BufSz  + 1  ! skewWakeMod
  Int_BufSz  = Int_BufSz  + 1  ! useTipLoss
  Int_BufSz  = Int_BufSz  + 1  ! useHubLoss
  Int_BufSz  = Int_BufSz  + 1  ! useInduction
  Int_BufSz  = Int_BufSz  + 1  ! useTanInd
  Int_BufSz  = Int_BufSz  + 1  ! useAIDrag
  Int_BufSz  = Int_BufSz  + 1  ! useTIDrag
  Int_BufSz  = Int_BufSz  + 1  ! numBladeNodes
  Int_BufSz  = Int_BufSz  + 1  ! numReIterations
  Int_BufSz  = Int_BufSz  + 1  ! maxIndIterations
  IF ( ALLOCATED(InData%AFindx) )   Int_BufSz   = Int_BufSz   + SIZE( InData%AFindx )  ! AFindx 
  IF ( ALLOCATED(InData%zHub) )   Re_BufSz    = Re_BufSz    + SIZE( InData%zHub )  ! zHub 
  IF ( ALLOCATED(InData%zLocal) )   Re_BufSz    = Re_BufSz    + SIZE( InData%zLocal )  ! zLocal 
  IF ( ALLOCATED(InData%zTip) )   Re_BufSz    = Re_BufSz    + SIZE( InData%zTip )  ! zTip 
DO i1 = LBOUND(InData%AFInfo,1), UBOUND(InData%AFInfo,1)
  CALL AFI_Packafinfotype( Re_AFInfo_Buf, Db_AFInfo_Buf, Int_AFInfo_Buf, InData%AFInfo(i1), ErrStat, ErrMsg, .TRUE. ) ! AFInfo 
  IF(ALLOCATED(Re_AFInfo_Buf)) Re_BufSz  = Re_BufSz  + SIZE( Re_AFInfo_Buf  ) ! AFInfo
  IF(ALLOCATED(Db_AFInfo_Buf)) Db_BufSz  = Db_BufSz  + SIZE( Db_AFInfo_Buf  ) ! AFInfo
  IF(ALLOCATED(Int_AFInfo_Buf))Int_BufSz = Int_BufSz + SIZE( Int_AFInfo_Buf ) ! AFInfo
  IF(ALLOCATED(Re_AFInfo_Buf))  DEALLOCATE(Re_AFInfo_Buf)
  IF(ALLOCATED(Db_AFInfo_Buf))  DEALLOCATE(Db_AFInfo_Buf)
  IF(ALLOCATED(Int_AFInfo_Buf)) DEALLOCATE(Int_AFInfo_Buf)
ENDDO
  Int_BufSz  = Int_BufSz  + 1  ! NumAF
!  missing buffer for AF_File
  CALL BEMT_PackInitInput( Re_BEMT_Buf, Db_BEMT_Buf, Int_BEMT_Buf, InData%BEMT, ErrStat, ErrMsg, .TRUE. ) ! BEMT 
  IF(ALLOCATED(Re_BEMT_Buf)) Re_BufSz  = Re_BufSz  + SIZE( Re_BEMT_Buf  ) ! BEMT
  IF(ALLOCATED(Db_BEMT_Buf)) Db_BufSz  = Db_BufSz  + SIZE( Db_BEMT_Buf  ) ! BEMT
  IF(ALLOCATED(Int_BEMT_Buf))Int_BufSz = Int_BufSz + SIZE( Int_BEMT_Buf ) ! BEMT
  IF(ALLOCATED(Re_BEMT_Buf))  DEALLOCATE(Re_BEMT_Buf)
  IF(ALLOCATED(Db_BEMT_Buf))  DEALLOCATE(Db_BEMT_Buf)
  IF(ALLOCATED(Int_BEMT_Buf)) DEALLOCATE(Int_BEMT_Buf)
  Int_BufSz  = Int_BufSz  + 1  ! BEMT_SkewWakeMod
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  IF ( .NOT. OnlySize ) DbKiBuf ( Db_Xferred:Db_Xferred+(1)-1 ) =  (InData%DT )
  Db_Xferred   = Db_Xferred   + 1
  IF ( ALLOCATED(InData%chord) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%chord))-1 ) =  PACK(InData%chord ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%chord)
  ENDIF
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%numBlades )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%airDens )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%kinVisc )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%skewWakeMod )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = TRANSFER( (InData%useTipLoss ), IntKiBuf(1), 1)
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = TRANSFER( (InData%useHubLoss ), IntKiBuf(1), 1)
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = TRANSFER( (InData%useInduction ), IntKiBuf(1), 1)
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = TRANSFER( (InData%useTanInd ), IntKiBuf(1), 1)
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = TRANSFER( (InData%useAIDrag ), IntKiBuf(1), 1)
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = TRANSFER( (InData%useTIDrag ), IntKiBuf(1), 1)
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%numBladeNodes )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%numReIterations )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%maxIndIterations )
  Int_Xferred   = Int_Xferred   + 1
  IF ( ALLOCATED(InData%AFindx) ) THEN
    IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(SIZE(InData%AFindx))-1 ) = PACK(InData%AFindx ,.TRUE.)
    Int_Xferred   = Int_Xferred   + SIZE(InData%AFindx)
  ENDIF
  IF ( ALLOCATED(InData%zHub) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%zHub))-1 ) =  PACK(InData%zHub ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%zHub)
  ENDIF
  IF ( ALLOCATED(InData%zLocal) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%zLocal))-1 ) =  PACK(InData%zLocal ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%zLocal)
  ENDIF
  IF ( ALLOCATED(InData%zTip) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%zTip))-1 ) =  PACK(InData%zTip ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%zTip)
  ENDIF
DO i1 = LBOUND(InData%AFInfo,1), UBOUND(InData%AFInfo,1)
  CALL AFI_Packafinfotype( Re_AFInfo_Buf, Db_AFInfo_Buf, Int_AFInfo_Buf, InData%AFInfo(i1), ErrStat, ErrMsg, OnlySize ) ! AFInfo 
  IF(ALLOCATED(Re_AFInfo_Buf)) THEN
    IF ( .NOT. OnlySize ) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_AFInfo_Buf)-1 ) = Re_AFInfo_Buf
    Re_Xferred = Re_Xferred + SIZE(Re_AFInfo_Buf)
  ENDIF
  IF(ALLOCATED(Db_AFInfo_Buf)) THEN
    IF ( .NOT. OnlySize ) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_AFInfo_Buf)-1 ) = Db_AFInfo_Buf
    Db_Xferred = Db_Xferred + SIZE(Db_AFInfo_Buf)
  ENDIF
  IF(ALLOCATED(Int_AFInfo_Buf)) THEN
    IF ( .NOT. OnlySize ) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_AFInfo_Buf)-1 ) = Int_AFInfo_Buf
    Int_Xferred = Int_Xferred + SIZE(Int_AFInfo_Buf)
  ENDIF
  IF( ALLOCATED(Re_AFInfo_Buf) )  DEALLOCATE(Re_AFInfo_Buf)
  IF( ALLOCATED(Db_AFInfo_Buf) )  DEALLOCATE(Db_AFInfo_Buf)
  IF( ALLOCATED(Int_AFInfo_Buf) ) DEALLOCATE(Int_AFInfo_Buf)
ENDDO
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%NumAF )
  Int_Xferred   = Int_Xferred   + 1
  CALL BEMT_PackInitInput( Re_BEMT_Buf, Db_BEMT_Buf, Int_BEMT_Buf, InData%BEMT, ErrStat, ErrMsg, OnlySize ) ! BEMT 
  IF(ALLOCATED(Re_BEMT_Buf)) THEN
    IF ( .NOT. OnlySize ) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_BEMT_Buf)-1 ) = Re_BEMT_Buf
    Re_Xferred = Re_Xferred + SIZE(Re_BEMT_Buf)
  ENDIF
  IF(ALLOCATED(Db_BEMT_Buf)) THEN
    IF ( .NOT. OnlySize ) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_BEMT_Buf)-1 ) = Db_BEMT_Buf
    Db_Xferred = Db_Xferred + SIZE(Db_BEMT_Buf)
  ENDIF
  IF(ALLOCATED(Int_BEMT_Buf)) THEN
    IF ( .NOT. OnlySize ) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_BEMT_Buf)-1 ) = Int_BEMT_Buf
    Int_Xferred = Int_Xferred + SIZE(Int_BEMT_Buf)
  ENDIF
  IF( ALLOCATED(Re_BEMT_Buf) )  DEALLOCATE(Re_BEMT_Buf)
  IF( ALLOCATED(Db_BEMT_Buf) )  DEALLOCATE(Db_BEMT_Buf)
  IF( ALLOCATED(Int_BEMT_Buf) ) DEALLOCATE(Int_BEMT_Buf)
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%BEMT_SkewWakeMod )
  Int_Xferred   = Int_Xferred   + 1
 END SUBROUTINE AD_PackInitInput

 SUBROUTINE AD_UnPackInitInput( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(AD_InitInputType), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
  REAL(ReKi),    ALLOCATABLE :: Re_AFInfo_Buf(:)
  REAL(DbKi),    ALLOCATABLE :: Db_AFInfo_Buf(:)
  INTEGER(IntKi),    ALLOCATABLE :: Int_AFInfo_Buf(:)
  REAL(ReKi),    ALLOCATABLE :: Re_BEMT_Buf(:)
  REAL(DbKi),    ALLOCATABLE :: Db_BEMT_Buf(:)
  INTEGER(IntKi),    ALLOCATABLE :: Int_BEMT_Buf(:)
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  OutData%DT = DbKiBuf ( Db_Xferred )
  Db_Xferred   = Db_Xferred   + 1
  IF ( ALLOCATED(OutData%chord) ) THEN
  ALLOCATE(mask2(SIZE(OutData%chord,1),SIZE(OutData%chord,2)))
  mask2 = .TRUE.
    OutData%chord = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%chord))-1 ),mask2,OutData%chord)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%chord)
  ENDIF
  OutData%numBlades = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%airDens = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%kinVisc = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%skewWakeMod = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%numBladeNodes = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%numReIterations = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%maxIndIterations = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  IF ( ALLOCATED(OutData%AFindx) ) THEN
  ALLOCATE(mask1(SIZE(OutData%AFindx,1)))
  mask1 = .TRUE.
    OutData%AFindx = UNPACK(IntKiBuf( Int_Xferred:Re_Xferred+(SIZE(OutData%AFindx))-1 ),mask1,OutData%AFindx)
  DEALLOCATE(mask1)
    Int_Xferred   = Int_Xferred   + SIZE(OutData%AFindx)
  ENDIF
  IF ( ALLOCATED(OutData%zHub) ) THEN
  ALLOCATE(mask1(SIZE(OutData%zHub,1)))
  mask1 = .TRUE.
    OutData%zHub = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%zHub))-1 ),mask1,OutData%zHub)
  DEALLOCATE(mask1)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%zHub)
  ENDIF
  IF ( ALLOCATED(OutData%zLocal) ) THEN
  ALLOCATE(mask2(SIZE(OutData%zLocal,1),SIZE(OutData%zLocal,2)))
  mask2 = .TRUE.
    OutData%zLocal = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%zLocal))-1 ),mask2,OutData%zLocal)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%zLocal)
  ENDIF
  IF ( ALLOCATED(OutData%zTip) ) THEN
  ALLOCATE(mask1(SIZE(OutData%zTip,1)))
  mask1 = .TRUE.
    OutData%zTip = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%zTip))-1 ),mask1,OutData%zTip)
  DEALLOCATE(mask1)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%zTip)
  ENDIF
DO i1 = LBOUND(OutData%AFInfo,1), UBOUND(OutData%AFInfo,1)
 ! first call AFI_Packafinfotype to get correctly sized buffers for unpacking
  CALL AFI_Packafinfotype( Re_AFInfo_Buf, Db_AFInfo_Buf, Int_AFInfo_Buf, OutData%AFInfo(i1), ErrStat, ErrMsg, .TRUE. ) ! AFInfo 
  IF(ALLOCATED(Re_AFInfo_Buf)) THEN
    Re_AFInfo_Buf = ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_AFInfo_Buf)-1 )
    Re_Xferred = Re_Xferred + SIZE(Re_AFInfo_Buf)
  ENDIF
  IF(ALLOCATED(Db_AFInfo_Buf)) THEN
    Db_AFInfo_Buf = DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_AFInfo_Buf)-1 )
    Db_Xferred = Db_Xferred + SIZE(Db_AFInfo_Buf)
  ENDIF
  IF(ALLOCATED(Int_AFInfo_Buf)) THEN
    Int_AFInfo_Buf = IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_AFInfo_Buf)-1 )
    Int_Xferred = Int_Xferred + SIZE(Int_AFInfo_Buf)
  ENDIF
  CALL AFI_UnPackafinfotype( Re_AFInfo_Buf, Db_AFInfo_Buf, Int_AFInfo_Buf, OutData%AFInfo(i1), ErrStat, ErrMsg ) ! AFInfo 
ENDDO
  OutData%NumAF = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
 ! first call BEMT_PackInitInput to get correctly sized buffers for unpacking
  CALL BEMT_PackInitInput( Re_BEMT_Buf, Db_BEMT_Buf, Int_BEMT_Buf, OutData%BEMT, ErrStat, ErrMsg, .TRUE. ) ! BEMT 
  IF(ALLOCATED(Re_BEMT_Buf)) THEN
    Re_BEMT_Buf = ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_BEMT_Buf)-1 )
    Re_Xferred = Re_Xferred + SIZE(Re_BEMT_Buf)
  ENDIF
  IF(ALLOCATED(Db_BEMT_Buf)) THEN
    Db_BEMT_Buf = DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_BEMT_Buf)-1 )
    Db_Xferred = Db_Xferred + SIZE(Db_BEMT_Buf)
  ENDIF
  IF(ALLOCATED(Int_BEMT_Buf)) THEN
    Int_BEMT_Buf = IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_BEMT_Buf)-1 )
    Int_Xferred = Int_Xferred + SIZE(Int_BEMT_Buf)
  ENDIF
  CALL BEMT_UnPackInitInput( Re_BEMT_Buf, Db_BEMT_Buf, Int_BEMT_Buf, OutData%BEMT, ErrStat, ErrMsg ) ! BEMT 
  OutData%BEMT_SkewWakeMod = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE AD_UnPackInitInput

 SUBROUTINE AD_CopyInitOutput( SrcInitOutputData, DstInitOutputData, CtrlCode, ErrStat, ErrMsg )
   TYPE(AD_InitOutputType), INTENT(IN) :: SrcInitOutputData
   TYPE(AD_InitOutputType), INTENT(INOUT) :: DstInitOutputData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: i2, i2_l, i2_u  !  bounds (upper/lower) for an array dimension 2
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(1024)                :: ErrMsg2
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
      CALL NWTC_Library_Copyprogdesc( SrcInitOutputData%Version, DstInitOutputData%Version, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,'AD_CopyInitOutput:Version')
         IF (ErrStat>=AbortErrLev) RETURN
IF (ALLOCATED(SrcInitOutputData%WriteOutputHdr)) THEN
   i1_l = LBOUND(SrcInitOutputData%WriteOutputHdr,1)
   i1_u = UBOUND(SrcInitOutputData%WriteOutputHdr,1)
   IF (.NOT. ALLOCATED(DstInitOutputData%WriteOutputHdr)) THEN 
      ALLOCATE(DstInitOutputData%WriteOutputHdr(i1_l:i1_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInitOutputData%WriteOutputHdr.', ErrStat, ErrMsg,'AD_CopyInitOutput')
         RETURN
      END IF
   END IF
   DstInitOutputData%WriteOutputHdr = SrcInitOutputData%WriteOutputHdr
ENDIF
IF (ALLOCATED(SrcInitOutputData%WriteOutputUnt)) THEN
   i1_l = LBOUND(SrcInitOutputData%WriteOutputUnt,1)
   i1_u = UBOUND(SrcInitOutputData%WriteOutputUnt,1)
   IF (.NOT. ALLOCATED(DstInitOutputData%WriteOutputUnt)) THEN 
      ALLOCATE(DstInitOutputData%WriteOutputUnt(i1_l:i1_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInitOutputData%WriteOutputUnt.', ErrStat, ErrMsg,'AD_CopyInitOutput')
         RETURN
      END IF
   END IF
   DstInitOutputData%WriteOutputUnt = SrcInitOutputData%WriteOutputUnt
ENDIF
 END SUBROUTINE AD_CopyInitOutput

 SUBROUTINE AD_DestroyInitOutput( InitOutputData, ErrStat, ErrMsg )
  TYPE(AD_InitOutputType), INTENT(INOUT) :: InitOutputData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
  CALL NWTC_Library_Destroyprogdesc( InitOutputData%Version, ErrStat, ErrMsg )
IF (ALLOCATED(InitOutputData%WriteOutputHdr)) THEN
   DEALLOCATE(InitOutputData%WriteOutputHdr)
ENDIF
IF (ALLOCATED(InitOutputData%WriteOutputUnt)) THEN
   DEALLOCATE(InitOutputData%WriteOutputUnt)
ENDIF
 END SUBROUTINE AD_DestroyInitOutput

 SUBROUTINE AD_PackInitOutput( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(AD_InitOutputType),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  REAL(ReKi),     ALLOCATABLE :: Re_Version_Buf(:)
  REAL(DbKi),     ALLOCATABLE :: Db_Version_Buf(:)
  INTEGER(IntKi), ALLOCATABLE :: Int_Version_Buf(:)
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  CALL NWTC_Library_Packprogdesc( Re_Version_Buf, Db_Version_Buf, Int_Version_Buf, InData%Version, ErrStat, ErrMsg, .TRUE. ) ! Version 
  IF(ALLOCATED(Re_Version_Buf)) Re_BufSz  = Re_BufSz  + SIZE( Re_Version_Buf  ) ! Version
  IF(ALLOCATED(Db_Version_Buf)) Db_BufSz  = Db_BufSz  + SIZE( Db_Version_Buf  ) ! Version
  IF(ALLOCATED(Int_Version_Buf))Int_BufSz = Int_BufSz + SIZE( Int_Version_Buf ) ! Version
  IF(ALLOCATED(Re_Version_Buf))  DEALLOCATE(Re_Version_Buf)
  IF(ALLOCATED(Db_Version_Buf))  DEALLOCATE(Db_Version_Buf)
  IF(ALLOCATED(Int_Version_Buf)) DEALLOCATE(Int_Version_Buf)
!  missing buffer for WriteOutputHdr
!  missing buffer for WriteOutputUnt
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  CALL NWTC_Library_Packprogdesc( Re_Version_Buf, Db_Version_Buf, Int_Version_Buf, InData%Version, ErrStat, ErrMsg, OnlySize ) ! Version 
  IF(ALLOCATED(Re_Version_Buf)) THEN
    IF ( .NOT. OnlySize ) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_Version_Buf)-1 ) = Re_Version_Buf
    Re_Xferred = Re_Xferred + SIZE(Re_Version_Buf)
  ENDIF
  IF(ALLOCATED(Db_Version_Buf)) THEN
    IF ( .NOT. OnlySize ) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_Version_Buf)-1 ) = Db_Version_Buf
    Db_Xferred = Db_Xferred + SIZE(Db_Version_Buf)
  ENDIF
  IF(ALLOCATED(Int_Version_Buf)) THEN
    IF ( .NOT. OnlySize ) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_Version_Buf)-1 ) = Int_Version_Buf
    Int_Xferred = Int_Xferred + SIZE(Int_Version_Buf)
  ENDIF
  IF( ALLOCATED(Re_Version_Buf) )  DEALLOCATE(Re_Version_Buf)
  IF( ALLOCATED(Db_Version_Buf) )  DEALLOCATE(Db_Version_Buf)
  IF( ALLOCATED(Int_Version_Buf) ) DEALLOCATE(Int_Version_Buf)
 END SUBROUTINE AD_PackInitOutput

 SUBROUTINE AD_UnPackInitOutput( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(AD_InitOutputType), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
  REAL(ReKi),    ALLOCATABLE :: Re_Version_Buf(:)
  REAL(DbKi),    ALLOCATABLE :: Db_Version_Buf(:)
  INTEGER(IntKi),    ALLOCATABLE :: Int_Version_Buf(:)
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
 ! first call NWTC_Library_Packprogdesc to get correctly sized buffers for unpacking
  CALL NWTC_Library_Packprogdesc( Re_Version_Buf, Db_Version_Buf, Int_Version_Buf, OutData%Version, ErrStat, ErrMsg, .TRUE. ) ! Version 
  IF(ALLOCATED(Re_Version_Buf)) THEN
    Re_Version_Buf = ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_Version_Buf)-1 )
    Re_Xferred = Re_Xferred + SIZE(Re_Version_Buf)
  ENDIF
  IF(ALLOCATED(Db_Version_Buf)) THEN
    Db_Version_Buf = DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_Version_Buf)-1 )
    Db_Xferred = Db_Xferred + SIZE(Db_Version_Buf)
  ENDIF
  IF(ALLOCATED(Int_Version_Buf)) THEN
    Int_Version_Buf = IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_Version_Buf)-1 )
    Int_Xferred = Int_Xferred + SIZE(Int_Version_Buf)
  ENDIF
  CALL NWTC_Library_UnPackprogdesc( Re_Version_Buf, Db_Version_Buf, Int_Version_Buf, OutData%Version, ErrStat, ErrMsg ) ! Version 
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE AD_UnPackInitOutput

 SUBROUTINE AD_CopyContState( SrcContStateData, DstContStateData, CtrlCode, ErrStat, ErrMsg )
   TYPE(AD_ContinuousStateType), INTENT(IN) :: SrcContStateData
   TYPE(AD_ContinuousStateType), INTENT(INOUT) :: DstContStateData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: i2, i2_l, i2_u  !  bounds (upper/lower) for an array dimension 2
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(1024)                :: ErrMsg2
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
      CALL BEMT_CopyContState( SrcContStateData%BEMT, DstContStateData%BEMT, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,'AD_CopyContState:BEMT')
         IF (ErrStat>=AbortErrLev) RETURN
 END SUBROUTINE AD_CopyContState

 SUBROUTINE AD_DestroyContState( ContStateData, ErrStat, ErrMsg )
  TYPE(AD_ContinuousStateType), INTENT(INOUT) :: ContStateData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
  CALL BEMT_DestroyContState( ContStateData%BEMT, ErrStat, ErrMsg )
 END SUBROUTINE AD_DestroyContState

 SUBROUTINE AD_PackContState( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(AD_ContinuousStateType),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  REAL(ReKi),     ALLOCATABLE :: Re_BEMT_Buf(:)
  REAL(DbKi),     ALLOCATABLE :: Db_BEMT_Buf(:)
  INTEGER(IntKi), ALLOCATABLE :: Int_BEMT_Buf(:)
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  CALL BEMT_PackContState( Re_BEMT_Buf, Db_BEMT_Buf, Int_BEMT_Buf, InData%BEMT, ErrStat, ErrMsg, .TRUE. ) ! BEMT 
  IF(ALLOCATED(Re_BEMT_Buf)) Re_BufSz  = Re_BufSz  + SIZE( Re_BEMT_Buf  ) ! BEMT
  IF(ALLOCATED(Db_BEMT_Buf)) Db_BufSz  = Db_BufSz  + SIZE( Db_BEMT_Buf  ) ! BEMT
  IF(ALLOCATED(Int_BEMT_Buf))Int_BufSz = Int_BufSz + SIZE( Int_BEMT_Buf ) ! BEMT
  IF(ALLOCATED(Re_BEMT_Buf))  DEALLOCATE(Re_BEMT_Buf)
  IF(ALLOCATED(Db_BEMT_Buf))  DEALLOCATE(Db_BEMT_Buf)
  IF(ALLOCATED(Int_BEMT_Buf)) DEALLOCATE(Int_BEMT_Buf)
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  CALL BEMT_PackContState( Re_BEMT_Buf, Db_BEMT_Buf, Int_BEMT_Buf, InData%BEMT, ErrStat, ErrMsg, OnlySize ) ! BEMT 
  IF(ALLOCATED(Re_BEMT_Buf)) THEN
    IF ( .NOT. OnlySize ) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_BEMT_Buf)-1 ) = Re_BEMT_Buf
    Re_Xferred = Re_Xferred + SIZE(Re_BEMT_Buf)
  ENDIF
  IF(ALLOCATED(Db_BEMT_Buf)) THEN
    IF ( .NOT. OnlySize ) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_BEMT_Buf)-1 ) = Db_BEMT_Buf
    Db_Xferred = Db_Xferred + SIZE(Db_BEMT_Buf)
  ENDIF
  IF(ALLOCATED(Int_BEMT_Buf)) THEN
    IF ( .NOT. OnlySize ) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_BEMT_Buf)-1 ) = Int_BEMT_Buf
    Int_Xferred = Int_Xferred + SIZE(Int_BEMT_Buf)
  ENDIF
  IF( ALLOCATED(Re_BEMT_Buf) )  DEALLOCATE(Re_BEMT_Buf)
  IF( ALLOCATED(Db_BEMT_Buf) )  DEALLOCATE(Db_BEMT_Buf)
  IF( ALLOCATED(Int_BEMT_Buf) ) DEALLOCATE(Int_BEMT_Buf)
 END SUBROUTINE AD_PackContState

 SUBROUTINE AD_UnPackContState( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(AD_ContinuousStateType), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
  REAL(ReKi),    ALLOCATABLE :: Re_BEMT_Buf(:)
  REAL(DbKi),    ALLOCATABLE :: Db_BEMT_Buf(:)
  INTEGER(IntKi),    ALLOCATABLE :: Int_BEMT_Buf(:)
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
 ! first call BEMT_PackContState to get correctly sized buffers for unpacking
  CALL BEMT_PackContState( Re_BEMT_Buf, Db_BEMT_Buf, Int_BEMT_Buf, OutData%BEMT, ErrStat, ErrMsg, .TRUE. ) ! BEMT 
  IF(ALLOCATED(Re_BEMT_Buf)) THEN
    Re_BEMT_Buf = ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_BEMT_Buf)-1 )
    Re_Xferred = Re_Xferred + SIZE(Re_BEMT_Buf)
  ENDIF
  IF(ALLOCATED(Db_BEMT_Buf)) THEN
    Db_BEMT_Buf = DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_BEMT_Buf)-1 )
    Db_Xferred = Db_Xferred + SIZE(Db_BEMT_Buf)
  ENDIF
  IF(ALLOCATED(Int_BEMT_Buf)) THEN
    Int_BEMT_Buf = IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_BEMT_Buf)-1 )
    Int_Xferred = Int_Xferred + SIZE(Int_BEMT_Buf)
  ENDIF
  CALL BEMT_UnPackContState( Re_BEMT_Buf, Db_BEMT_Buf, Int_BEMT_Buf, OutData%BEMT, ErrStat, ErrMsg ) ! BEMT 
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE AD_UnPackContState

 SUBROUTINE AD_CopyDiscState( SrcDiscStateData, DstDiscStateData, CtrlCode, ErrStat, ErrMsg )
   TYPE(AD_DiscreteStateType), INTENT(IN) :: SrcDiscStateData
   TYPE(AD_DiscreteStateType), INTENT(INOUT) :: DstDiscStateData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: i2, i2_l, i2_u  !  bounds (upper/lower) for an array dimension 2
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(1024)                :: ErrMsg2
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
      CALL BEMT_CopyDiscState( SrcDiscStateData%BEMT, DstDiscStateData%BEMT, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,'AD_CopyDiscState:BEMT')
         IF (ErrStat>=AbortErrLev) RETURN
 END SUBROUTINE AD_CopyDiscState

 SUBROUTINE AD_DestroyDiscState( DiscStateData, ErrStat, ErrMsg )
  TYPE(AD_DiscreteStateType), INTENT(INOUT) :: DiscStateData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
  CALL BEMT_DestroyDiscState( DiscStateData%BEMT, ErrStat, ErrMsg )
 END SUBROUTINE AD_DestroyDiscState

 SUBROUTINE AD_PackDiscState( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(AD_DiscreteStateType),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  REAL(ReKi),     ALLOCATABLE :: Re_BEMT_Buf(:)
  REAL(DbKi),     ALLOCATABLE :: Db_BEMT_Buf(:)
  INTEGER(IntKi), ALLOCATABLE :: Int_BEMT_Buf(:)
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  CALL BEMT_PackDiscState( Re_BEMT_Buf, Db_BEMT_Buf, Int_BEMT_Buf, InData%BEMT, ErrStat, ErrMsg, .TRUE. ) ! BEMT 
  IF(ALLOCATED(Re_BEMT_Buf)) Re_BufSz  = Re_BufSz  + SIZE( Re_BEMT_Buf  ) ! BEMT
  IF(ALLOCATED(Db_BEMT_Buf)) Db_BufSz  = Db_BufSz  + SIZE( Db_BEMT_Buf  ) ! BEMT
  IF(ALLOCATED(Int_BEMT_Buf))Int_BufSz = Int_BufSz + SIZE( Int_BEMT_Buf ) ! BEMT
  IF(ALLOCATED(Re_BEMT_Buf))  DEALLOCATE(Re_BEMT_Buf)
  IF(ALLOCATED(Db_BEMT_Buf))  DEALLOCATE(Db_BEMT_Buf)
  IF(ALLOCATED(Int_BEMT_Buf)) DEALLOCATE(Int_BEMT_Buf)
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  CALL BEMT_PackDiscState( Re_BEMT_Buf, Db_BEMT_Buf, Int_BEMT_Buf, InData%BEMT, ErrStat, ErrMsg, OnlySize ) ! BEMT 
  IF(ALLOCATED(Re_BEMT_Buf)) THEN
    IF ( .NOT. OnlySize ) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_BEMT_Buf)-1 ) = Re_BEMT_Buf
    Re_Xferred = Re_Xferred + SIZE(Re_BEMT_Buf)
  ENDIF
  IF(ALLOCATED(Db_BEMT_Buf)) THEN
    IF ( .NOT. OnlySize ) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_BEMT_Buf)-1 ) = Db_BEMT_Buf
    Db_Xferred = Db_Xferred + SIZE(Db_BEMT_Buf)
  ENDIF
  IF(ALLOCATED(Int_BEMT_Buf)) THEN
    IF ( .NOT. OnlySize ) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_BEMT_Buf)-1 ) = Int_BEMT_Buf
    Int_Xferred = Int_Xferred + SIZE(Int_BEMT_Buf)
  ENDIF
  IF( ALLOCATED(Re_BEMT_Buf) )  DEALLOCATE(Re_BEMT_Buf)
  IF( ALLOCATED(Db_BEMT_Buf) )  DEALLOCATE(Db_BEMT_Buf)
  IF( ALLOCATED(Int_BEMT_Buf) ) DEALLOCATE(Int_BEMT_Buf)
 END SUBROUTINE AD_PackDiscState

 SUBROUTINE AD_UnPackDiscState( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(AD_DiscreteStateType), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
  REAL(ReKi),    ALLOCATABLE :: Re_BEMT_Buf(:)
  REAL(DbKi),    ALLOCATABLE :: Db_BEMT_Buf(:)
  INTEGER(IntKi),    ALLOCATABLE :: Int_BEMT_Buf(:)
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
 ! first call BEMT_PackDiscState to get correctly sized buffers for unpacking
  CALL BEMT_PackDiscState( Re_BEMT_Buf, Db_BEMT_Buf, Int_BEMT_Buf, OutData%BEMT, ErrStat, ErrMsg, .TRUE. ) ! BEMT 
  IF(ALLOCATED(Re_BEMT_Buf)) THEN
    Re_BEMT_Buf = ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_BEMT_Buf)-1 )
    Re_Xferred = Re_Xferred + SIZE(Re_BEMT_Buf)
  ENDIF
  IF(ALLOCATED(Db_BEMT_Buf)) THEN
    Db_BEMT_Buf = DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_BEMT_Buf)-1 )
    Db_Xferred = Db_Xferred + SIZE(Db_BEMT_Buf)
  ENDIF
  IF(ALLOCATED(Int_BEMT_Buf)) THEN
    Int_BEMT_Buf = IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_BEMT_Buf)-1 )
    Int_Xferred = Int_Xferred + SIZE(Int_BEMT_Buf)
  ENDIF
  CALL BEMT_UnPackDiscState( Re_BEMT_Buf, Db_BEMT_Buf, Int_BEMT_Buf, OutData%BEMT, ErrStat, ErrMsg ) ! BEMT 
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE AD_UnPackDiscState

 SUBROUTINE AD_CopyConstrState( SrcConstrStateData, DstConstrStateData, CtrlCode, ErrStat, ErrMsg )
   TYPE(AD_ConstraintStateType), INTENT(IN) :: SrcConstrStateData
   TYPE(AD_ConstraintStateType), INTENT(INOUT) :: DstConstrStateData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: i2, i2_l, i2_u  !  bounds (upper/lower) for an array dimension 2
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(1024)                :: ErrMsg2
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
      CALL BEMT_CopyConstrState( SrcConstrStateData%BEMT, DstConstrStateData%BEMT, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,'AD_CopyConstrState:BEMT')
         IF (ErrStat>=AbortErrLev) RETURN
 END SUBROUTINE AD_CopyConstrState

 SUBROUTINE AD_DestroyConstrState( ConstrStateData, ErrStat, ErrMsg )
  TYPE(AD_ConstraintStateType), INTENT(INOUT) :: ConstrStateData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
  CALL BEMT_DestroyConstrState( ConstrStateData%BEMT, ErrStat, ErrMsg )
 END SUBROUTINE AD_DestroyConstrState

 SUBROUTINE AD_PackConstrState( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(AD_ConstraintStateType),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  REAL(ReKi),     ALLOCATABLE :: Re_BEMT_Buf(:)
  REAL(DbKi),     ALLOCATABLE :: Db_BEMT_Buf(:)
  INTEGER(IntKi), ALLOCATABLE :: Int_BEMT_Buf(:)
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  CALL BEMT_PackConstrState( Re_BEMT_Buf, Db_BEMT_Buf, Int_BEMT_Buf, InData%BEMT, ErrStat, ErrMsg, .TRUE. ) ! BEMT 
  IF(ALLOCATED(Re_BEMT_Buf)) Re_BufSz  = Re_BufSz  + SIZE( Re_BEMT_Buf  ) ! BEMT
  IF(ALLOCATED(Db_BEMT_Buf)) Db_BufSz  = Db_BufSz  + SIZE( Db_BEMT_Buf  ) ! BEMT
  IF(ALLOCATED(Int_BEMT_Buf))Int_BufSz = Int_BufSz + SIZE( Int_BEMT_Buf ) ! BEMT
  IF(ALLOCATED(Re_BEMT_Buf))  DEALLOCATE(Re_BEMT_Buf)
  IF(ALLOCATED(Db_BEMT_Buf))  DEALLOCATE(Db_BEMT_Buf)
  IF(ALLOCATED(Int_BEMT_Buf)) DEALLOCATE(Int_BEMT_Buf)
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  CALL BEMT_PackConstrState( Re_BEMT_Buf, Db_BEMT_Buf, Int_BEMT_Buf, InData%BEMT, ErrStat, ErrMsg, OnlySize ) ! BEMT 
  IF(ALLOCATED(Re_BEMT_Buf)) THEN
    IF ( .NOT. OnlySize ) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_BEMT_Buf)-1 ) = Re_BEMT_Buf
    Re_Xferred = Re_Xferred + SIZE(Re_BEMT_Buf)
  ENDIF
  IF(ALLOCATED(Db_BEMT_Buf)) THEN
    IF ( .NOT. OnlySize ) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_BEMT_Buf)-1 ) = Db_BEMT_Buf
    Db_Xferred = Db_Xferred + SIZE(Db_BEMT_Buf)
  ENDIF
  IF(ALLOCATED(Int_BEMT_Buf)) THEN
    IF ( .NOT. OnlySize ) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_BEMT_Buf)-1 ) = Int_BEMT_Buf
    Int_Xferred = Int_Xferred + SIZE(Int_BEMT_Buf)
  ENDIF
  IF( ALLOCATED(Re_BEMT_Buf) )  DEALLOCATE(Re_BEMT_Buf)
  IF( ALLOCATED(Db_BEMT_Buf) )  DEALLOCATE(Db_BEMT_Buf)
  IF( ALLOCATED(Int_BEMT_Buf) ) DEALLOCATE(Int_BEMT_Buf)
 END SUBROUTINE AD_PackConstrState

 SUBROUTINE AD_UnPackConstrState( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(AD_ConstraintStateType), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
  REAL(ReKi),    ALLOCATABLE :: Re_BEMT_Buf(:)
  REAL(DbKi),    ALLOCATABLE :: Db_BEMT_Buf(:)
  INTEGER(IntKi),    ALLOCATABLE :: Int_BEMT_Buf(:)
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
 ! first call BEMT_PackConstrState to get correctly sized buffers for unpacking
  CALL BEMT_PackConstrState( Re_BEMT_Buf, Db_BEMT_Buf, Int_BEMT_Buf, OutData%BEMT, ErrStat, ErrMsg, .TRUE. ) ! BEMT 
  IF(ALLOCATED(Re_BEMT_Buf)) THEN
    Re_BEMT_Buf = ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_BEMT_Buf)-1 )
    Re_Xferred = Re_Xferred + SIZE(Re_BEMT_Buf)
  ENDIF
  IF(ALLOCATED(Db_BEMT_Buf)) THEN
    Db_BEMT_Buf = DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_BEMT_Buf)-1 )
    Db_Xferred = Db_Xferred + SIZE(Db_BEMT_Buf)
  ENDIF
  IF(ALLOCATED(Int_BEMT_Buf)) THEN
    Int_BEMT_Buf = IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_BEMT_Buf)-1 )
    Int_Xferred = Int_Xferred + SIZE(Int_BEMT_Buf)
  ENDIF
  CALL BEMT_UnPackConstrState( Re_BEMT_Buf, Db_BEMT_Buf, Int_BEMT_Buf, OutData%BEMT, ErrStat, ErrMsg ) ! BEMT 
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE AD_UnPackConstrState

 SUBROUTINE AD_CopyOtherState( SrcOtherStateData, DstOtherStateData, CtrlCode, ErrStat, ErrMsg )
   TYPE(AD_OtherStateType), INTENT(IN) :: SrcOtherStateData
   TYPE(AD_OtherStateType), INTENT(INOUT) :: DstOtherStateData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: i2, i2_l, i2_u  !  bounds (upper/lower) for an array dimension 2
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(1024)                :: ErrMsg2
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
      CALL BEMT_CopyOtherState( SrcOtherStateData%BEMT, DstOtherStateData%BEMT, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,'AD_CopyOtherState:BEMT')
         IF (ErrStat>=AbortErrLev) RETURN
      CALL BEMT_CopyOutput( SrcOtherStateData%BEMT_y, DstOtherStateData%BEMT_y, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,'AD_CopyOtherState:BEMT_y')
         IF (ErrStat>=AbortErrLev) RETURN
      CALL BEMT_CopyInput( SrcOtherStateData%BEMT_u, DstOtherStateData%BEMT_u, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,'AD_CopyOtherState:BEMT_u')
         IF (ErrStat>=AbortErrLev) RETURN
 END SUBROUTINE AD_CopyOtherState

 SUBROUTINE AD_DestroyOtherState( OtherStateData, ErrStat, ErrMsg )
  TYPE(AD_OtherStateType), INTENT(INOUT) :: OtherStateData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
  CALL BEMT_DestroyOtherState( OtherStateData%BEMT, ErrStat, ErrMsg )
  CALL BEMT_DestroyOutput( OtherStateData%BEMT_y, ErrStat, ErrMsg )
  CALL BEMT_DestroyInput( OtherStateData%BEMT_u, ErrStat, ErrMsg )
 END SUBROUTINE AD_DestroyOtherState

 SUBROUTINE AD_PackOtherState( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(AD_OtherStateType),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  REAL(ReKi),     ALLOCATABLE :: Re_BEMT_Buf(:)
  REAL(DbKi),     ALLOCATABLE :: Db_BEMT_Buf(:)
  INTEGER(IntKi), ALLOCATABLE :: Int_BEMT_Buf(:)
  REAL(ReKi),     ALLOCATABLE :: Re_BEMT_y_Buf(:)
  REAL(DbKi),     ALLOCATABLE :: Db_BEMT_y_Buf(:)
  INTEGER(IntKi), ALLOCATABLE :: Int_BEMT_y_Buf(:)
  REAL(ReKi),     ALLOCATABLE :: Re_BEMT_u_Buf(:)
  REAL(DbKi),     ALLOCATABLE :: Db_BEMT_u_Buf(:)
  INTEGER(IntKi), ALLOCATABLE :: Int_BEMT_u_Buf(:)
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  CALL BEMT_PackOtherState( Re_BEMT_Buf, Db_BEMT_Buf, Int_BEMT_Buf, InData%BEMT, ErrStat, ErrMsg, .TRUE. ) ! BEMT 
  IF(ALLOCATED(Re_BEMT_Buf)) Re_BufSz  = Re_BufSz  + SIZE( Re_BEMT_Buf  ) ! BEMT
  IF(ALLOCATED(Db_BEMT_Buf)) Db_BufSz  = Db_BufSz  + SIZE( Db_BEMT_Buf  ) ! BEMT
  IF(ALLOCATED(Int_BEMT_Buf))Int_BufSz = Int_BufSz + SIZE( Int_BEMT_Buf ) ! BEMT
  IF(ALLOCATED(Re_BEMT_Buf))  DEALLOCATE(Re_BEMT_Buf)
  IF(ALLOCATED(Db_BEMT_Buf))  DEALLOCATE(Db_BEMT_Buf)
  IF(ALLOCATED(Int_BEMT_Buf)) DEALLOCATE(Int_BEMT_Buf)
  CALL BEMT_PackOutput( Re_BEMT_y_Buf, Db_BEMT_y_Buf, Int_BEMT_y_Buf, InData%BEMT_y, ErrStat, ErrMsg, .TRUE. ) ! BEMT_y 
  IF(ALLOCATED(Re_BEMT_y_Buf)) Re_BufSz  = Re_BufSz  + SIZE( Re_BEMT_y_Buf  ) ! BEMT_y
  IF(ALLOCATED(Db_BEMT_y_Buf)) Db_BufSz  = Db_BufSz  + SIZE( Db_BEMT_y_Buf  ) ! BEMT_y
  IF(ALLOCATED(Int_BEMT_y_Buf))Int_BufSz = Int_BufSz + SIZE( Int_BEMT_y_Buf ) ! BEMT_y
  IF(ALLOCATED(Re_BEMT_y_Buf))  DEALLOCATE(Re_BEMT_y_Buf)
  IF(ALLOCATED(Db_BEMT_y_Buf))  DEALLOCATE(Db_BEMT_y_Buf)
  IF(ALLOCATED(Int_BEMT_y_Buf)) DEALLOCATE(Int_BEMT_y_Buf)
  CALL BEMT_PackInput( Re_BEMT_u_Buf, Db_BEMT_u_Buf, Int_BEMT_u_Buf, InData%BEMT_u, ErrStat, ErrMsg, .TRUE. ) ! BEMT_u 
  IF(ALLOCATED(Re_BEMT_u_Buf)) Re_BufSz  = Re_BufSz  + SIZE( Re_BEMT_u_Buf  ) ! BEMT_u
  IF(ALLOCATED(Db_BEMT_u_Buf)) Db_BufSz  = Db_BufSz  + SIZE( Db_BEMT_u_Buf  ) ! BEMT_u
  IF(ALLOCATED(Int_BEMT_u_Buf))Int_BufSz = Int_BufSz + SIZE( Int_BEMT_u_Buf ) ! BEMT_u
  IF(ALLOCATED(Re_BEMT_u_Buf))  DEALLOCATE(Re_BEMT_u_Buf)
  IF(ALLOCATED(Db_BEMT_u_Buf))  DEALLOCATE(Db_BEMT_u_Buf)
  IF(ALLOCATED(Int_BEMT_u_Buf)) DEALLOCATE(Int_BEMT_u_Buf)
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  CALL BEMT_PackOtherState( Re_BEMT_Buf, Db_BEMT_Buf, Int_BEMT_Buf, InData%BEMT, ErrStat, ErrMsg, OnlySize ) ! BEMT 
  IF(ALLOCATED(Re_BEMT_Buf)) THEN
    IF ( .NOT. OnlySize ) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_BEMT_Buf)-1 ) = Re_BEMT_Buf
    Re_Xferred = Re_Xferred + SIZE(Re_BEMT_Buf)
  ENDIF
  IF(ALLOCATED(Db_BEMT_Buf)) THEN
    IF ( .NOT. OnlySize ) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_BEMT_Buf)-1 ) = Db_BEMT_Buf
    Db_Xferred = Db_Xferred + SIZE(Db_BEMT_Buf)
  ENDIF
  IF(ALLOCATED(Int_BEMT_Buf)) THEN
    IF ( .NOT. OnlySize ) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_BEMT_Buf)-1 ) = Int_BEMT_Buf
    Int_Xferred = Int_Xferred + SIZE(Int_BEMT_Buf)
  ENDIF
  IF( ALLOCATED(Re_BEMT_Buf) )  DEALLOCATE(Re_BEMT_Buf)
  IF( ALLOCATED(Db_BEMT_Buf) )  DEALLOCATE(Db_BEMT_Buf)
  IF( ALLOCATED(Int_BEMT_Buf) ) DEALLOCATE(Int_BEMT_Buf)
  CALL BEMT_PackOutput( Re_BEMT_y_Buf, Db_BEMT_y_Buf, Int_BEMT_y_Buf, InData%BEMT_y, ErrStat, ErrMsg, OnlySize ) ! BEMT_y 
  IF(ALLOCATED(Re_BEMT_y_Buf)) THEN
    IF ( .NOT. OnlySize ) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_BEMT_y_Buf)-1 ) = Re_BEMT_y_Buf
    Re_Xferred = Re_Xferred + SIZE(Re_BEMT_y_Buf)
  ENDIF
  IF(ALLOCATED(Db_BEMT_y_Buf)) THEN
    IF ( .NOT. OnlySize ) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_BEMT_y_Buf)-1 ) = Db_BEMT_y_Buf
    Db_Xferred = Db_Xferred + SIZE(Db_BEMT_y_Buf)
  ENDIF
  IF(ALLOCATED(Int_BEMT_y_Buf)) THEN
    IF ( .NOT. OnlySize ) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_BEMT_y_Buf)-1 ) = Int_BEMT_y_Buf
    Int_Xferred = Int_Xferred + SIZE(Int_BEMT_y_Buf)
  ENDIF
  IF( ALLOCATED(Re_BEMT_y_Buf) )  DEALLOCATE(Re_BEMT_y_Buf)
  IF( ALLOCATED(Db_BEMT_y_Buf) )  DEALLOCATE(Db_BEMT_y_Buf)
  IF( ALLOCATED(Int_BEMT_y_Buf) ) DEALLOCATE(Int_BEMT_y_Buf)
  CALL BEMT_PackInput( Re_BEMT_u_Buf, Db_BEMT_u_Buf, Int_BEMT_u_Buf, InData%BEMT_u, ErrStat, ErrMsg, OnlySize ) ! BEMT_u 
  IF(ALLOCATED(Re_BEMT_u_Buf)) THEN
    IF ( .NOT. OnlySize ) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_BEMT_u_Buf)-1 ) = Re_BEMT_u_Buf
    Re_Xferred = Re_Xferred + SIZE(Re_BEMT_u_Buf)
  ENDIF
  IF(ALLOCATED(Db_BEMT_u_Buf)) THEN
    IF ( .NOT. OnlySize ) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_BEMT_u_Buf)-1 ) = Db_BEMT_u_Buf
    Db_Xferred = Db_Xferred + SIZE(Db_BEMT_u_Buf)
  ENDIF
  IF(ALLOCATED(Int_BEMT_u_Buf)) THEN
    IF ( .NOT. OnlySize ) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_BEMT_u_Buf)-1 ) = Int_BEMT_u_Buf
    Int_Xferred = Int_Xferred + SIZE(Int_BEMT_u_Buf)
  ENDIF
  IF( ALLOCATED(Re_BEMT_u_Buf) )  DEALLOCATE(Re_BEMT_u_Buf)
  IF( ALLOCATED(Db_BEMT_u_Buf) )  DEALLOCATE(Db_BEMT_u_Buf)
  IF( ALLOCATED(Int_BEMT_u_Buf) ) DEALLOCATE(Int_BEMT_u_Buf)
 END SUBROUTINE AD_PackOtherState

 SUBROUTINE AD_UnPackOtherState( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(AD_OtherStateType), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
  REAL(ReKi),    ALLOCATABLE :: Re_BEMT_Buf(:)
  REAL(DbKi),    ALLOCATABLE :: Db_BEMT_Buf(:)
  INTEGER(IntKi),    ALLOCATABLE :: Int_BEMT_Buf(:)
  REAL(ReKi),    ALLOCATABLE :: Re_BEMT_y_Buf(:)
  REAL(DbKi),    ALLOCATABLE :: Db_BEMT_y_Buf(:)
  INTEGER(IntKi),    ALLOCATABLE :: Int_BEMT_y_Buf(:)
  REAL(ReKi),    ALLOCATABLE :: Re_BEMT_u_Buf(:)
  REAL(DbKi),    ALLOCATABLE :: Db_BEMT_u_Buf(:)
  INTEGER(IntKi),    ALLOCATABLE :: Int_BEMT_u_Buf(:)
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
 ! first call BEMT_PackOtherState to get correctly sized buffers for unpacking
  CALL BEMT_PackOtherState( Re_BEMT_Buf, Db_BEMT_Buf, Int_BEMT_Buf, OutData%BEMT, ErrStat, ErrMsg, .TRUE. ) ! BEMT 
  IF(ALLOCATED(Re_BEMT_Buf)) THEN
    Re_BEMT_Buf = ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_BEMT_Buf)-1 )
    Re_Xferred = Re_Xferred + SIZE(Re_BEMT_Buf)
  ENDIF
  IF(ALLOCATED(Db_BEMT_Buf)) THEN
    Db_BEMT_Buf = DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_BEMT_Buf)-1 )
    Db_Xferred = Db_Xferred + SIZE(Db_BEMT_Buf)
  ENDIF
  IF(ALLOCATED(Int_BEMT_Buf)) THEN
    Int_BEMT_Buf = IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_BEMT_Buf)-1 )
    Int_Xferred = Int_Xferred + SIZE(Int_BEMT_Buf)
  ENDIF
  CALL BEMT_UnPackOtherState( Re_BEMT_Buf, Db_BEMT_Buf, Int_BEMT_Buf, OutData%BEMT, ErrStat, ErrMsg ) ! BEMT 
 ! first call BEMT_PackOutput to get correctly sized buffers for unpacking
  CALL BEMT_PackOutput( Re_BEMT_y_Buf, Db_BEMT_y_Buf, Int_BEMT_y_Buf, OutData%BEMT_y, ErrStat, ErrMsg, .TRUE. ) ! BEMT_y 
  IF(ALLOCATED(Re_BEMT_y_Buf)) THEN
    Re_BEMT_y_Buf = ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_BEMT_y_Buf)-1 )
    Re_Xferred = Re_Xferred + SIZE(Re_BEMT_y_Buf)
  ENDIF
  IF(ALLOCATED(Db_BEMT_y_Buf)) THEN
    Db_BEMT_y_Buf = DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_BEMT_y_Buf)-1 )
    Db_Xferred = Db_Xferred + SIZE(Db_BEMT_y_Buf)
  ENDIF
  IF(ALLOCATED(Int_BEMT_y_Buf)) THEN
    Int_BEMT_y_Buf = IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_BEMT_y_Buf)-1 )
    Int_Xferred = Int_Xferred + SIZE(Int_BEMT_y_Buf)
  ENDIF
  CALL BEMT_UnPackOutput( Re_BEMT_y_Buf, Db_BEMT_y_Buf, Int_BEMT_y_Buf, OutData%BEMT_y, ErrStat, ErrMsg ) ! BEMT_y 
 ! first call BEMT_PackInput to get correctly sized buffers for unpacking
  CALL BEMT_PackInput( Re_BEMT_u_Buf, Db_BEMT_u_Buf, Int_BEMT_u_Buf, OutData%BEMT_u, ErrStat, ErrMsg, .TRUE. ) ! BEMT_u 
  IF(ALLOCATED(Re_BEMT_u_Buf)) THEN
    Re_BEMT_u_Buf = ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_BEMT_u_Buf)-1 )
    Re_Xferred = Re_Xferred + SIZE(Re_BEMT_u_Buf)
  ENDIF
  IF(ALLOCATED(Db_BEMT_u_Buf)) THEN
    Db_BEMT_u_Buf = DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_BEMT_u_Buf)-1 )
    Db_Xferred = Db_Xferred + SIZE(Db_BEMT_u_Buf)
  ENDIF
  IF(ALLOCATED(Int_BEMT_u_Buf)) THEN
    Int_BEMT_u_Buf = IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_BEMT_u_Buf)-1 )
    Int_Xferred = Int_Xferred + SIZE(Int_BEMT_u_Buf)
  ENDIF
  CALL BEMT_UnPackInput( Re_BEMT_u_Buf, Db_BEMT_u_Buf, Int_BEMT_u_Buf, OutData%BEMT_u, ErrStat, ErrMsg ) ! BEMT_u 
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE AD_UnPackOtherState

 SUBROUTINE AD_CopyParam( SrcParamData, DstParamData, CtrlCode, ErrStat, ErrMsg )
   TYPE(AD_ParameterType), INTENT(IN) :: SrcParamData
   TYPE(AD_ParameterType), INTENT(INOUT) :: DstParamData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: i2, i2_l, i2_u  !  bounds (upper/lower) for an array dimension 2
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(1024)                :: ErrMsg2
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
   DstParamData%DT = SrcParamData%DT
IF (ALLOCATED(SrcParamData%chord)) THEN
   i1_l = LBOUND(SrcParamData%chord,1)
   i1_u = UBOUND(SrcParamData%chord,1)
   i2_l = LBOUND(SrcParamData%chord,2)
   i2_u = UBOUND(SrcParamData%chord,2)
   IF (.NOT. ALLOCATED(DstParamData%chord)) THEN 
      ALLOCATE(DstParamData%chord(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%chord.', ErrStat, ErrMsg,'AD_CopyParam')
         RETURN
      END IF
   END IF
   DstParamData%chord = SrcParamData%chord
ENDIF
   DstParamData%numBlades = SrcParamData%numBlades
   DstParamData%airDens = SrcParamData%airDens
   DstParamData%kinVisc = SrcParamData%kinVisc
   DstParamData%skewWakeMod = SrcParamData%skewWakeMod
   DstParamData%useTipLoss = SrcParamData%useTipLoss
   DstParamData%useHubLoss = SrcParamData%useHubLoss
   DstParamData%useTanInd = SrcParamData%useTanInd
   DstParamData%useAIDrag = SrcParamData%useAIDrag
   DstParamData%useTIDrag = SrcParamData%useTIDrag
   DstParamData%numBladeNodes = SrcParamData%numBladeNodes
   DstParamData%numReIterations = SrcParamData%numReIterations
   DstParamData%maxIndIterations = SrcParamData%maxIndIterations
IF (ALLOCATED(SrcParamData%AFindx)) THEN
   i1_l = LBOUND(SrcParamData%AFindx,1)
   i1_u = UBOUND(SrcParamData%AFindx,1)
   IF (.NOT. ALLOCATED(DstParamData%AFindx)) THEN 
      ALLOCATE(DstParamData%AFindx(i1_l:i1_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%AFindx.', ErrStat, ErrMsg,'AD_CopyParam')
         RETURN
      END IF
   END IF
   DstParamData%AFindx = SrcParamData%AFindx
ENDIF
IF (ALLOCATED(SrcParamData%tipLossConst)) THEN
   i1_l = LBOUND(SrcParamData%tipLossConst,1)
   i1_u = UBOUND(SrcParamData%tipLossConst,1)
   i2_l = LBOUND(SrcParamData%tipLossConst,2)
   i2_u = UBOUND(SrcParamData%tipLossConst,2)
   IF (.NOT. ALLOCATED(DstParamData%tipLossConst)) THEN 
      ALLOCATE(DstParamData%tipLossConst(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%tipLossConst.', ErrStat, ErrMsg,'AD_CopyParam')
         RETURN
      END IF
   END IF
   DstParamData%tipLossConst = SrcParamData%tipLossConst
ENDIF
IF (ALLOCATED(SrcParamData%hubLossConst)) THEN
   i1_l = LBOUND(SrcParamData%hubLossConst,1)
   i1_u = UBOUND(SrcParamData%hubLossConst,1)
   i2_l = LBOUND(SrcParamData%hubLossConst,2)
   i2_u = UBOUND(SrcParamData%hubLossConst,2)
   IF (.NOT. ALLOCATED(DstParamData%hubLossConst)) THEN 
      ALLOCATE(DstParamData%hubLossConst(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%hubLossConst.', ErrStat, ErrMsg,'AD_CopyParam')
         RETURN
      END IF
   END IF
   DstParamData%hubLossConst = SrcParamData%hubLossConst
ENDIF
IF (ALLOCATED(SrcParamData%AFInfo)) THEN
   i1_l = LBOUND(SrcParamData%AFInfo,1)
   i1_u = UBOUND(SrcParamData%AFInfo,1)
   IF (.NOT. ALLOCATED(DstParamData%AFInfo)) THEN 
      ALLOCATE(DstParamData%AFInfo(i1_l:i1_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%AFInfo.', ErrStat, ErrMsg,'AD_CopyParam')
         RETURN
      END IF
   END IF
   DO i1 = LBOUND(SrcParamData%AFInfo,1), UBOUND(SrcParamData%AFInfo,1)
      CALL AFI_Copyafinfotype( SrcParamData%AFInfo(i1), DstParamData%AFInfo(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,'AD_CopyParam:AFInfo(i1)')
         IF (ErrStat>=AbortErrLev) RETURN
   ENDDO
ENDIF
      CALL BEMT_CopyParam( SrcParamData%BEMT, DstParamData%BEMT, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,'AD_CopyParam:BEMT')
         IF (ErrStat>=AbortErrLev) RETURN
   DstParamData%NumAF = SrcParamData%NumAF
IF (ALLOCATED(SrcParamData%AF_File)) THEN
   i1_l = LBOUND(SrcParamData%AF_File,1)
   i1_u = UBOUND(SrcParamData%AF_File,1)
   IF (.NOT. ALLOCATED(DstParamData%AF_File)) THEN 
      ALLOCATE(DstParamData%AF_File(i1_l:i1_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%AF_File.', ErrStat, ErrMsg,'AD_CopyParam')
         RETURN
      END IF
   END IF
   DstParamData%AF_File = SrcParamData%AF_File
ENDIF
      CALL AFI_CopyParam( SrcParamData%AFI_Params, DstParamData%AFI_Params, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,'AD_CopyParam:AFI_Params')
         IF (ErrStat>=AbortErrLev) RETURN
   DstParamData%NumOuts = SrcParamData%NumOuts
   DstParamData%BEMT_SkewWakeMod = SrcParamData%BEMT_SkewWakeMod
 END SUBROUTINE AD_CopyParam

 SUBROUTINE AD_DestroyParam( ParamData, ErrStat, ErrMsg )
  TYPE(AD_ParameterType), INTENT(INOUT) :: ParamData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
IF (ALLOCATED(ParamData%chord)) THEN
   DEALLOCATE(ParamData%chord)
ENDIF
IF (ALLOCATED(ParamData%AFindx)) THEN
   DEALLOCATE(ParamData%AFindx)
ENDIF
IF (ALLOCATED(ParamData%tipLossConst)) THEN
   DEALLOCATE(ParamData%tipLossConst)
ENDIF
IF (ALLOCATED(ParamData%hubLossConst)) THEN
   DEALLOCATE(ParamData%hubLossConst)
ENDIF
IF (ALLOCATED(ParamData%AFInfo)) THEN
DO i1 = LBOUND(ParamData%AFInfo,1), UBOUND(ParamData%AFInfo,1)
  CALL AFI_Destroyafinfotype( ParamData%AFInfo(i1), ErrStat, ErrMsg )
ENDDO
   DEALLOCATE(ParamData%AFInfo)
ENDIF
  CALL BEMT_DestroyParam( ParamData%BEMT, ErrStat, ErrMsg )
IF (ALLOCATED(ParamData%AF_File)) THEN
   DEALLOCATE(ParamData%AF_File)
ENDIF
  CALL AFI_DestroyParam( ParamData%AFI_Params, ErrStat, ErrMsg )
 END SUBROUTINE AD_DestroyParam

 SUBROUTINE AD_PackParam( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(AD_ParameterType),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  REAL(ReKi),     ALLOCATABLE :: Re_AFInfo_Buf(:)
  REAL(DbKi),     ALLOCATABLE :: Db_AFInfo_Buf(:)
  INTEGER(IntKi), ALLOCATABLE :: Int_AFInfo_Buf(:)
  REAL(ReKi),     ALLOCATABLE :: Re_BEMT_Buf(:)
  REAL(DbKi),     ALLOCATABLE :: Db_BEMT_Buf(:)
  INTEGER(IntKi), ALLOCATABLE :: Int_BEMT_Buf(:)
  REAL(ReKi),     ALLOCATABLE :: Re_AFI_Params_Buf(:)
  REAL(DbKi),     ALLOCATABLE :: Db_AFI_Params_Buf(:)
  INTEGER(IntKi), ALLOCATABLE :: Int_AFI_Params_Buf(:)
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  Db_BufSz   = Db_BufSz   + 1  ! DT
  IF ( ALLOCATED(InData%chord) )   Re_BufSz    = Re_BufSz    + SIZE( InData%chord )  ! chord 
  Int_BufSz  = Int_BufSz  + 1  ! numBlades
  Re_BufSz   = Re_BufSz   + 1  ! airDens
  Re_BufSz   = Re_BufSz   + 1  ! kinVisc
  Int_BufSz  = Int_BufSz  + 1  ! skewWakeMod
  Int_BufSz  = Int_BufSz  + 1  ! useTipLoss
  Int_BufSz  = Int_BufSz  + 1  ! useHubLoss
  Int_BufSz  = Int_BufSz  + 1  ! useTanInd
  Int_BufSz  = Int_BufSz  + 1  ! useAIDrag
  Int_BufSz  = Int_BufSz  + 1  ! useTIDrag
  Int_BufSz  = Int_BufSz  + 1  ! numBladeNodes
  Int_BufSz  = Int_BufSz  + 1  ! numReIterations
  Int_BufSz  = Int_BufSz  + 1  ! maxIndIterations
  IF ( ALLOCATED(InData%AFindx) )   Int_BufSz   = Int_BufSz   + SIZE( InData%AFindx )  ! AFindx 
  IF ( ALLOCATED(InData%tipLossConst) )   Re_BufSz    = Re_BufSz    + SIZE( InData%tipLossConst )  ! tipLossConst 
  IF ( ALLOCATED(InData%hubLossConst) )   Re_BufSz    = Re_BufSz    + SIZE( InData%hubLossConst )  ! hubLossConst 
DO i1 = LBOUND(InData%AFInfo,1), UBOUND(InData%AFInfo,1)
  CALL AFI_Packafinfotype( Re_AFInfo_Buf, Db_AFInfo_Buf, Int_AFInfo_Buf, InData%AFInfo(i1), ErrStat, ErrMsg, .TRUE. ) ! AFInfo 
  IF(ALLOCATED(Re_AFInfo_Buf)) Re_BufSz  = Re_BufSz  + SIZE( Re_AFInfo_Buf  ) ! AFInfo
  IF(ALLOCATED(Db_AFInfo_Buf)) Db_BufSz  = Db_BufSz  + SIZE( Db_AFInfo_Buf  ) ! AFInfo
  IF(ALLOCATED(Int_AFInfo_Buf))Int_BufSz = Int_BufSz + SIZE( Int_AFInfo_Buf ) ! AFInfo
  IF(ALLOCATED(Re_AFInfo_Buf))  DEALLOCATE(Re_AFInfo_Buf)
  IF(ALLOCATED(Db_AFInfo_Buf))  DEALLOCATE(Db_AFInfo_Buf)
  IF(ALLOCATED(Int_AFInfo_Buf)) DEALLOCATE(Int_AFInfo_Buf)
ENDDO
  CALL BEMT_PackParam( Re_BEMT_Buf, Db_BEMT_Buf, Int_BEMT_Buf, InData%BEMT, ErrStat, ErrMsg, .TRUE. ) ! BEMT 
  IF(ALLOCATED(Re_BEMT_Buf)) Re_BufSz  = Re_BufSz  + SIZE( Re_BEMT_Buf  ) ! BEMT
  IF(ALLOCATED(Db_BEMT_Buf)) Db_BufSz  = Db_BufSz  + SIZE( Db_BEMT_Buf  ) ! BEMT
  IF(ALLOCATED(Int_BEMT_Buf))Int_BufSz = Int_BufSz + SIZE( Int_BEMT_Buf ) ! BEMT
  IF(ALLOCATED(Re_BEMT_Buf))  DEALLOCATE(Re_BEMT_Buf)
  IF(ALLOCATED(Db_BEMT_Buf))  DEALLOCATE(Db_BEMT_Buf)
  IF(ALLOCATED(Int_BEMT_Buf)) DEALLOCATE(Int_BEMT_Buf)
  Int_BufSz  = Int_BufSz  + 1  ! NumAF
!  missing buffer for AF_File
  CALL AFI_PackParam( Re_AFI_Params_Buf, Db_AFI_Params_Buf, Int_AFI_Params_Buf, InData%AFI_Params, ErrStat, ErrMsg, .TRUE. ) ! AFI_Params 
  IF(ALLOCATED(Re_AFI_Params_Buf)) Re_BufSz  = Re_BufSz  + SIZE( Re_AFI_Params_Buf  ) ! AFI_Params
  IF(ALLOCATED(Db_AFI_Params_Buf)) Db_BufSz  = Db_BufSz  + SIZE( Db_AFI_Params_Buf  ) ! AFI_Params
  IF(ALLOCATED(Int_AFI_Params_Buf))Int_BufSz = Int_BufSz + SIZE( Int_AFI_Params_Buf ) ! AFI_Params
  IF(ALLOCATED(Re_AFI_Params_Buf))  DEALLOCATE(Re_AFI_Params_Buf)
  IF(ALLOCATED(Db_AFI_Params_Buf))  DEALLOCATE(Db_AFI_Params_Buf)
  IF(ALLOCATED(Int_AFI_Params_Buf)) DEALLOCATE(Int_AFI_Params_Buf)
  Int_BufSz  = Int_BufSz  + 1  ! NumOuts
  Int_BufSz  = Int_BufSz  + 1  ! BEMT_SkewWakeMod
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  IF ( .NOT. OnlySize ) DbKiBuf ( Db_Xferred:Db_Xferred+(1)-1 ) =  (InData%DT )
  Db_Xferred   = Db_Xferred   + 1
  IF ( ALLOCATED(InData%chord) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%chord))-1 ) =  PACK(InData%chord ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%chord)
  ENDIF
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%numBlades )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%airDens )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%kinVisc )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%skewWakeMod )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = TRANSFER( (InData%useTipLoss ), IntKiBuf(1), 1)
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = TRANSFER( (InData%useHubLoss ), IntKiBuf(1), 1)
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = TRANSFER( (InData%useTanInd ), IntKiBuf(1), 1)
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = TRANSFER( (InData%useAIDrag ), IntKiBuf(1), 1)
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = TRANSFER( (InData%useTIDrag ), IntKiBuf(1), 1)
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%numBladeNodes )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%numReIterations )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%maxIndIterations )
  Int_Xferred   = Int_Xferred   + 1
  IF ( ALLOCATED(InData%AFindx) ) THEN
    IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(SIZE(InData%AFindx))-1 ) = PACK(InData%AFindx ,.TRUE.)
    Int_Xferred   = Int_Xferred   + SIZE(InData%AFindx)
  ENDIF
  IF ( ALLOCATED(InData%tipLossConst) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%tipLossConst))-1 ) =  PACK(InData%tipLossConst ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%tipLossConst)
  ENDIF
  IF ( ALLOCATED(InData%hubLossConst) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%hubLossConst))-1 ) =  PACK(InData%hubLossConst ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%hubLossConst)
  ENDIF
DO i1 = LBOUND(InData%AFInfo,1), UBOUND(InData%AFInfo,1)
  CALL AFI_Packafinfotype( Re_AFInfo_Buf, Db_AFInfo_Buf, Int_AFInfo_Buf, InData%AFInfo(i1), ErrStat, ErrMsg, OnlySize ) ! AFInfo 
  IF(ALLOCATED(Re_AFInfo_Buf)) THEN
    IF ( .NOT. OnlySize ) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_AFInfo_Buf)-1 ) = Re_AFInfo_Buf
    Re_Xferred = Re_Xferred + SIZE(Re_AFInfo_Buf)
  ENDIF
  IF(ALLOCATED(Db_AFInfo_Buf)) THEN
    IF ( .NOT. OnlySize ) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_AFInfo_Buf)-1 ) = Db_AFInfo_Buf
    Db_Xferred = Db_Xferred + SIZE(Db_AFInfo_Buf)
  ENDIF
  IF(ALLOCATED(Int_AFInfo_Buf)) THEN
    IF ( .NOT. OnlySize ) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_AFInfo_Buf)-1 ) = Int_AFInfo_Buf
    Int_Xferred = Int_Xferred + SIZE(Int_AFInfo_Buf)
  ENDIF
  IF( ALLOCATED(Re_AFInfo_Buf) )  DEALLOCATE(Re_AFInfo_Buf)
  IF( ALLOCATED(Db_AFInfo_Buf) )  DEALLOCATE(Db_AFInfo_Buf)
  IF( ALLOCATED(Int_AFInfo_Buf) ) DEALLOCATE(Int_AFInfo_Buf)
ENDDO
  CALL BEMT_PackParam( Re_BEMT_Buf, Db_BEMT_Buf, Int_BEMT_Buf, InData%BEMT, ErrStat, ErrMsg, OnlySize ) ! BEMT 
  IF(ALLOCATED(Re_BEMT_Buf)) THEN
    IF ( .NOT. OnlySize ) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_BEMT_Buf)-1 ) = Re_BEMT_Buf
    Re_Xferred = Re_Xferred + SIZE(Re_BEMT_Buf)
  ENDIF
  IF(ALLOCATED(Db_BEMT_Buf)) THEN
    IF ( .NOT. OnlySize ) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_BEMT_Buf)-1 ) = Db_BEMT_Buf
    Db_Xferred = Db_Xferred + SIZE(Db_BEMT_Buf)
  ENDIF
  IF(ALLOCATED(Int_BEMT_Buf)) THEN
    IF ( .NOT. OnlySize ) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_BEMT_Buf)-1 ) = Int_BEMT_Buf
    Int_Xferred = Int_Xferred + SIZE(Int_BEMT_Buf)
  ENDIF
  IF( ALLOCATED(Re_BEMT_Buf) )  DEALLOCATE(Re_BEMT_Buf)
  IF( ALLOCATED(Db_BEMT_Buf) )  DEALLOCATE(Db_BEMT_Buf)
  IF( ALLOCATED(Int_BEMT_Buf) ) DEALLOCATE(Int_BEMT_Buf)
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%NumAF )
  Int_Xferred   = Int_Xferred   + 1
  CALL AFI_PackParam( Re_AFI_Params_Buf, Db_AFI_Params_Buf, Int_AFI_Params_Buf, InData%AFI_Params, ErrStat, ErrMsg, OnlySize ) ! AFI_Params 
  IF(ALLOCATED(Re_AFI_Params_Buf)) THEN
    IF ( .NOT. OnlySize ) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_AFI_Params_Buf)-1 ) = Re_AFI_Params_Buf
    Re_Xferred = Re_Xferred + SIZE(Re_AFI_Params_Buf)
  ENDIF
  IF(ALLOCATED(Db_AFI_Params_Buf)) THEN
    IF ( .NOT. OnlySize ) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_AFI_Params_Buf)-1 ) = Db_AFI_Params_Buf
    Db_Xferred = Db_Xferred + SIZE(Db_AFI_Params_Buf)
  ENDIF
  IF(ALLOCATED(Int_AFI_Params_Buf)) THEN
    IF ( .NOT. OnlySize ) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_AFI_Params_Buf)-1 ) = Int_AFI_Params_Buf
    Int_Xferred = Int_Xferred + SIZE(Int_AFI_Params_Buf)
  ENDIF
  IF( ALLOCATED(Re_AFI_Params_Buf) )  DEALLOCATE(Re_AFI_Params_Buf)
  IF( ALLOCATED(Db_AFI_Params_Buf) )  DEALLOCATE(Db_AFI_Params_Buf)
  IF( ALLOCATED(Int_AFI_Params_Buf) ) DEALLOCATE(Int_AFI_Params_Buf)
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%NumOuts )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%BEMT_SkewWakeMod )
  Int_Xferred   = Int_Xferred   + 1
 END SUBROUTINE AD_PackParam

 SUBROUTINE AD_UnPackParam( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(AD_ParameterType), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
  REAL(ReKi),    ALLOCATABLE :: Re_AFInfo_Buf(:)
  REAL(DbKi),    ALLOCATABLE :: Db_AFInfo_Buf(:)
  INTEGER(IntKi),    ALLOCATABLE :: Int_AFInfo_Buf(:)
  REAL(ReKi),    ALLOCATABLE :: Re_BEMT_Buf(:)
  REAL(DbKi),    ALLOCATABLE :: Db_BEMT_Buf(:)
  INTEGER(IntKi),    ALLOCATABLE :: Int_BEMT_Buf(:)
  REAL(ReKi),    ALLOCATABLE :: Re_AFI_Params_Buf(:)
  REAL(DbKi),    ALLOCATABLE :: Db_AFI_Params_Buf(:)
  INTEGER(IntKi),    ALLOCATABLE :: Int_AFI_Params_Buf(:)
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  OutData%DT = DbKiBuf ( Db_Xferred )
  Db_Xferred   = Db_Xferred   + 1
  IF ( ALLOCATED(OutData%chord) ) THEN
  ALLOCATE(mask2(SIZE(OutData%chord,1),SIZE(OutData%chord,2)))
  mask2 = .TRUE.
    OutData%chord = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%chord))-1 ),mask2,OutData%chord)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%chord)
  ENDIF
  OutData%numBlades = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%airDens = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%kinVisc = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%skewWakeMod = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%numBladeNodes = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%numReIterations = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%maxIndIterations = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  IF ( ALLOCATED(OutData%AFindx) ) THEN
  ALLOCATE(mask1(SIZE(OutData%AFindx,1)))
  mask1 = .TRUE.
    OutData%AFindx = UNPACK(IntKiBuf( Int_Xferred:Re_Xferred+(SIZE(OutData%AFindx))-1 ),mask1,OutData%AFindx)
  DEALLOCATE(mask1)
    Int_Xferred   = Int_Xferred   + SIZE(OutData%AFindx)
  ENDIF
  IF ( ALLOCATED(OutData%tipLossConst) ) THEN
  ALLOCATE(mask2(SIZE(OutData%tipLossConst,1),SIZE(OutData%tipLossConst,2)))
  mask2 = .TRUE.
    OutData%tipLossConst = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%tipLossConst))-1 ),mask2,OutData%tipLossConst)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%tipLossConst)
  ENDIF
  IF ( ALLOCATED(OutData%hubLossConst) ) THEN
  ALLOCATE(mask2(SIZE(OutData%hubLossConst,1),SIZE(OutData%hubLossConst,2)))
  mask2 = .TRUE.
    OutData%hubLossConst = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%hubLossConst))-1 ),mask2,OutData%hubLossConst)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%hubLossConst)
  ENDIF
DO i1 = LBOUND(OutData%AFInfo,1), UBOUND(OutData%AFInfo,1)
 ! first call AFI_Packafinfotype to get correctly sized buffers for unpacking
  CALL AFI_Packafinfotype( Re_AFInfo_Buf, Db_AFInfo_Buf, Int_AFInfo_Buf, OutData%AFInfo(i1), ErrStat, ErrMsg, .TRUE. ) ! AFInfo 
  IF(ALLOCATED(Re_AFInfo_Buf)) THEN
    Re_AFInfo_Buf = ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_AFInfo_Buf)-1 )
    Re_Xferred = Re_Xferred + SIZE(Re_AFInfo_Buf)
  ENDIF
  IF(ALLOCATED(Db_AFInfo_Buf)) THEN
    Db_AFInfo_Buf = DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_AFInfo_Buf)-1 )
    Db_Xferred = Db_Xferred + SIZE(Db_AFInfo_Buf)
  ENDIF
  IF(ALLOCATED(Int_AFInfo_Buf)) THEN
    Int_AFInfo_Buf = IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_AFInfo_Buf)-1 )
    Int_Xferred = Int_Xferred + SIZE(Int_AFInfo_Buf)
  ENDIF
  CALL AFI_UnPackafinfotype( Re_AFInfo_Buf, Db_AFInfo_Buf, Int_AFInfo_Buf, OutData%AFInfo(i1), ErrStat, ErrMsg ) ! AFInfo 
ENDDO
 ! first call BEMT_PackParam to get correctly sized buffers for unpacking
  CALL BEMT_PackParam( Re_BEMT_Buf, Db_BEMT_Buf, Int_BEMT_Buf, OutData%BEMT, ErrStat, ErrMsg, .TRUE. ) ! BEMT 
  IF(ALLOCATED(Re_BEMT_Buf)) THEN
    Re_BEMT_Buf = ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_BEMT_Buf)-1 )
    Re_Xferred = Re_Xferred + SIZE(Re_BEMT_Buf)
  ENDIF
  IF(ALLOCATED(Db_BEMT_Buf)) THEN
    Db_BEMT_Buf = DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_BEMT_Buf)-1 )
    Db_Xferred = Db_Xferred + SIZE(Db_BEMT_Buf)
  ENDIF
  IF(ALLOCATED(Int_BEMT_Buf)) THEN
    Int_BEMT_Buf = IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_BEMT_Buf)-1 )
    Int_Xferred = Int_Xferred + SIZE(Int_BEMT_Buf)
  ENDIF
  CALL BEMT_UnPackParam( Re_BEMT_Buf, Db_BEMT_Buf, Int_BEMT_Buf, OutData%BEMT, ErrStat, ErrMsg ) ! BEMT 
  OutData%NumAF = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
 ! first call AFI_PackParam to get correctly sized buffers for unpacking
  CALL AFI_PackParam( Re_AFI_Params_Buf, Db_AFI_Params_Buf, Int_AFI_Params_Buf, OutData%AFI_Params, ErrStat, ErrMsg, .TRUE. ) ! AFI_Params 
  IF(ALLOCATED(Re_AFI_Params_Buf)) THEN
    Re_AFI_Params_Buf = ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_AFI_Params_Buf)-1 )
    Re_Xferred = Re_Xferred + SIZE(Re_AFI_Params_Buf)
  ENDIF
  IF(ALLOCATED(Db_AFI_Params_Buf)) THEN
    Db_AFI_Params_Buf = DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_AFI_Params_Buf)-1 )
    Db_Xferred = Db_Xferred + SIZE(Db_AFI_Params_Buf)
  ENDIF
  IF(ALLOCATED(Int_AFI_Params_Buf)) THEN
    Int_AFI_Params_Buf = IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_AFI_Params_Buf)-1 )
    Int_Xferred = Int_Xferred + SIZE(Int_AFI_Params_Buf)
  ENDIF
  CALL AFI_UnPackParam( Re_AFI_Params_Buf, Db_AFI_Params_Buf, Int_AFI_Params_Buf, OutData%AFI_Params, ErrStat, ErrMsg ) ! AFI_Params 
  OutData%NumOuts = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%BEMT_SkewWakeMod = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE AD_UnPackParam

 SUBROUTINE AD_CopyInput( SrcInputData, DstInputData, CtrlCode, ErrStat, ErrMsg )
   TYPE(AD_InputType), INTENT(IN) :: SrcInputData
   TYPE(AD_InputType), INTENT(INOUT) :: DstInputData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: i2, i2_l, i2_u  !  bounds (upper/lower) for an array dimension 2
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(1024)                :: ErrMsg2
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
IF (ALLOCATED(SrcInputData%theta)) THEN
   i1_l = LBOUND(SrcInputData%theta,1)
   i1_u = UBOUND(SrcInputData%theta,1)
   i2_l = LBOUND(SrcInputData%theta,2)
   i2_u = UBOUND(SrcInputData%theta,2)
   IF (.NOT. ALLOCATED(DstInputData%theta)) THEN 
      ALLOCATE(DstInputData%theta(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInputData%theta.', ErrStat, ErrMsg,'AD_CopyInput')
         RETURN
      END IF
   END IF
   DstInputData%theta = SrcInputData%theta
ENDIF
   DstInputData%gamma = SrcInputData%gamma
IF (ALLOCATED(SrcInputData%psi)) THEN
   i1_l = LBOUND(SrcInputData%psi,1)
   i1_u = UBOUND(SrcInputData%psi,1)
   IF (.NOT. ALLOCATED(DstInputData%psi)) THEN 
      ALLOCATE(DstInputData%psi(i1_l:i1_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInputData%psi.', ErrStat, ErrMsg,'AD_CopyInput')
         RETURN
      END IF
   END IF
   DstInputData%psi = SrcInputData%psi
ENDIF
   DstInputData%omega = SrcInputData%omega
IF (ALLOCATED(SrcInputData%Vx)) THEN
   i1_l = LBOUND(SrcInputData%Vx,1)
   i1_u = UBOUND(SrcInputData%Vx,1)
   i2_l = LBOUND(SrcInputData%Vx,2)
   i2_u = UBOUND(SrcInputData%Vx,2)
   IF (.NOT. ALLOCATED(DstInputData%Vx)) THEN 
      ALLOCATE(DstInputData%Vx(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInputData%Vx.', ErrStat, ErrMsg,'AD_CopyInput')
         RETURN
      END IF
   END IF
   DstInputData%Vx = SrcInputData%Vx
ENDIF
IF (ALLOCATED(SrcInputData%Vy)) THEN
   i1_l = LBOUND(SrcInputData%Vy,1)
   i1_u = UBOUND(SrcInputData%Vy,1)
   i2_l = LBOUND(SrcInputData%Vy,2)
   i2_u = UBOUND(SrcInputData%Vy,2)
   IF (.NOT. ALLOCATED(DstInputData%Vy)) THEN 
      ALLOCATE(DstInputData%Vy(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInputData%Vy.', ErrStat, ErrMsg,'AD_CopyInput')
         RETURN
      END IF
   END IF
   DstInputData%Vy = SrcInputData%Vy
ENDIF
IF (ALLOCATED(SrcInputData%Vinf)) THEN
   i1_l = LBOUND(SrcInputData%Vinf,1)
   i1_u = UBOUND(SrcInputData%Vinf,1)
   i2_l = LBOUND(SrcInputData%Vinf,2)
   i2_u = UBOUND(SrcInputData%Vinf,2)
   IF (.NOT. ALLOCATED(DstInputData%Vinf)) THEN 
      ALLOCATE(DstInputData%Vinf(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInputData%Vinf.', ErrStat, ErrMsg,'AD_CopyInput')
         RETURN
      END IF
   END IF
   DstInputData%Vinf = SrcInputData%Vinf
ENDIF
   DstInputData%lambda = SrcInputData%lambda
IF (ALLOCATED(SrcInputData%rTip)) THEN
   i1_l = LBOUND(SrcInputData%rTip,1)
   i1_u = UBOUND(SrcInputData%rTip,1)
   IF (.NOT. ALLOCATED(DstInputData%rTip)) THEN 
      ALLOCATE(DstInputData%rTip(i1_l:i1_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInputData%rTip.', ErrStat, ErrMsg,'AD_CopyInput')
         RETURN
      END IF
   END IF
   DstInputData%rTip = SrcInputData%rTip
ENDIF
IF (ALLOCATED(SrcInputData%rLocal)) THEN
   i1_l = LBOUND(SrcInputData%rLocal,1)
   i1_u = UBOUND(SrcInputData%rLocal,1)
   i2_l = LBOUND(SrcInputData%rLocal,2)
   i2_u = UBOUND(SrcInputData%rLocal,2)
   IF (.NOT. ALLOCATED(DstInputData%rLocal)) THEN 
      ALLOCATE(DstInputData%rLocal(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInputData%rLocal.', ErrStat, ErrMsg,'AD_CopyInput')
         RETURN
      END IF
   END IF
   DstInputData%rLocal = SrcInputData%rLocal
ENDIF
 END SUBROUTINE AD_CopyInput

 SUBROUTINE AD_DestroyInput( InputData, ErrStat, ErrMsg )
  TYPE(AD_InputType), INTENT(INOUT) :: InputData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
IF (ALLOCATED(InputData%theta)) THEN
   DEALLOCATE(InputData%theta)
ENDIF
IF (ALLOCATED(InputData%psi)) THEN
   DEALLOCATE(InputData%psi)
ENDIF
IF (ALLOCATED(InputData%Vx)) THEN
   DEALLOCATE(InputData%Vx)
ENDIF
IF (ALLOCATED(InputData%Vy)) THEN
   DEALLOCATE(InputData%Vy)
ENDIF
IF (ALLOCATED(InputData%Vinf)) THEN
   DEALLOCATE(InputData%Vinf)
ENDIF
IF (ALLOCATED(InputData%rTip)) THEN
   DEALLOCATE(InputData%rTip)
ENDIF
IF (ALLOCATED(InputData%rLocal)) THEN
   DEALLOCATE(InputData%rLocal)
ENDIF
 END SUBROUTINE AD_DestroyInput

 SUBROUTINE AD_PackInput( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(AD_InputType),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  IF ( ALLOCATED(InData%theta) )   Re_BufSz    = Re_BufSz    + SIZE( InData%theta )  ! theta 
  Re_BufSz   = Re_BufSz   + 1  ! gamma
  IF ( ALLOCATED(InData%psi) )   Re_BufSz    = Re_BufSz    + SIZE( InData%psi )  ! psi 
  Re_BufSz   = Re_BufSz   + 1  ! omega
  IF ( ALLOCATED(InData%Vx) )   Re_BufSz    = Re_BufSz    + SIZE( InData%Vx )  ! Vx 
  IF ( ALLOCATED(InData%Vy) )   Re_BufSz    = Re_BufSz    + SIZE( InData%Vy )  ! Vy 
  IF ( ALLOCATED(InData%Vinf) )   Re_BufSz    = Re_BufSz    + SIZE( InData%Vinf )  ! Vinf 
  Re_BufSz   = Re_BufSz   + 1  ! lambda
  IF ( ALLOCATED(InData%rTip) )   Re_BufSz    = Re_BufSz    + SIZE( InData%rTip )  ! rTip 
  IF ( ALLOCATED(InData%rLocal) )   Re_BufSz    = Re_BufSz    + SIZE( InData%rLocal )  ! rLocal 
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  IF ( ALLOCATED(InData%theta) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%theta))-1 ) =  PACK(InData%theta ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%theta)
  ENDIF
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%gamma )
  Re_Xferred   = Re_Xferred   + 1
  IF ( ALLOCATED(InData%psi) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%psi))-1 ) =  PACK(InData%psi ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%psi)
  ENDIF
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%omega )
  Re_Xferred   = Re_Xferred   + 1
  IF ( ALLOCATED(InData%Vx) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%Vx))-1 ) =  PACK(InData%Vx ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%Vx)
  ENDIF
  IF ( ALLOCATED(InData%Vy) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%Vy))-1 ) =  PACK(InData%Vy ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%Vy)
  ENDIF
  IF ( ALLOCATED(InData%Vinf) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%Vinf))-1 ) =  PACK(InData%Vinf ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%Vinf)
  ENDIF
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%lambda )
  Re_Xferred   = Re_Xferred   + 1
  IF ( ALLOCATED(InData%rTip) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%rTip))-1 ) =  PACK(InData%rTip ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%rTip)
  ENDIF
  IF ( ALLOCATED(InData%rLocal) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%rLocal))-1 ) =  PACK(InData%rLocal ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%rLocal)
  ENDIF
 END SUBROUTINE AD_PackInput

 SUBROUTINE AD_UnPackInput( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(AD_InputType), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  IF ( ALLOCATED(OutData%theta) ) THEN
  ALLOCATE(mask2(SIZE(OutData%theta,1),SIZE(OutData%theta,2)))
  mask2 = .TRUE.
    OutData%theta = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%theta))-1 ),mask2,OutData%theta)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%theta)
  ENDIF
  OutData%gamma = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  IF ( ALLOCATED(OutData%psi) ) THEN
  ALLOCATE(mask1(SIZE(OutData%psi,1)))
  mask1 = .TRUE.
    OutData%psi = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%psi))-1 ),mask1,OutData%psi)
  DEALLOCATE(mask1)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%psi)
  ENDIF
  OutData%omega = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  IF ( ALLOCATED(OutData%Vx) ) THEN
  ALLOCATE(mask2(SIZE(OutData%Vx,1),SIZE(OutData%Vx,2)))
  mask2 = .TRUE.
    OutData%Vx = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%Vx))-1 ),mask2,OutData%Vx)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%Vx)
  ENDIF
  IF ( ALLOCATED(OutData%Vy) ) THEN
  ALLOCATE(mask2(SIZE(OutData%Vy,1),SIZE(OutData%Vy,2)))
  mask2 = .TRUE.
    OutData%Vy = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%Vy))-1 ),mask2,OutData%Vy)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%Vy)
  ENDIF
  IF ( ALLOCATED(OutData%Vinf) ) THEN
  ALLOCATE(mask2(SIZE(OutData%Vinf,1),SIZE(OutData%Vinf,2)))
  mask2 = .TRUE.
    OutData%Vinf = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%Vinf))-1 ),mask2,OutData%Vinf)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%Vinf)
  ENDIF
  OutData%lambda = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  IF ( ALLOCATED(OutData%rTip) ) THEN
  ALLOCATE(mask1(SIZE(OutData%rTip,1)))
  mask1 = .TRUE.
    OutData%rTip = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%rTip))-1 ),mask1,OutData%rTip)
  DEALLOCATE(mask1)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%rTip)
  ENDIF
  IF ( ALLOCATED(OutData%rLocal) ) THEN
  ALLOCATE(mask2(SIZE(OutData%rLocal,1),SIZE(OutData%rLocal,2)))
  mask2 = .TRUE.
    OutData%rLocal = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%rLocal))-1 ),mask2,OutData%rLocal)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%rLocal)
  ENDIF
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE AD_UnPackInput

 SUBROUTINE AD_CopyOutput( SrcOutputData, DstOutputData, CtrlCode, ErrStat, ErrMsg )
   TYPE(AD_OutputType), INTENT(IN) :: SrcOutputData
   TYPE(AD_OutputType), INTENT(INOUT) :: DstOutputData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: i2, i2_l, i2_u  !  bounds (upper/lower) for an array dimension 2
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(1024)                :: ErrMsg2
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
IF (ALLOCATED(SrcOutputData%inducedVel)) THEN
   i1_l = LBOUND(SrcOutputData%inducedVel,1)
   i1_u = UBOUND(SrcOutputData%inducedVel,1)
   i2_l = LBOUND(SrcOutputData%inducedVel,2)
   i2_u = UBOUND(SrcOutputData%inducedVel,2)
   IF (.NOT. ALLOCATED(DstOutputData%inducedVel)) THEN 
      ALLOCATE(DstOutputData%inducedVel(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstOutputData%inducedVel.', ErrStat, ErrMsg,'AD_CopyOutput')
         RETURN
      END IF
   END IF
   DstOutputData%inducedVel = SrcOutputData%inducedVel
ENDIF
IF (ALLOCATED(SrcOutputData%phi)) THEN
   i1_l = LBOUND(SrcOutputData%phi,1)
   i1_u = UBOUND(SrcOutputData%phi,1)
   i2_l = LBOUND(SrcOutputData%phi,2)
   i2_u = UBOUND(SrcOutputData%phi,2)
   IF (.NOT. ALLOCATED(DstOutputData%phi)) THEN 
      ALLOCATE(DstOutputData%phi(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstOutputData%phi.', ErrStat, ErrMsg,'AD_CopyOutput')
         RETURN
      END IF
   END IF
   DstOutputData%phi = SrcOutputData%phi
ENDIF
IF (ALLOCATED(SrcOutputData%WriteOutput)) THEN
   i1_l = LBOUND(SrcOutputData%WriteOutput,1)
   i1_u = UBOUND(SrcOutputData%WriteOutput,1)
   IF (.NOT. ALLOCATED(DstOutputData%WriteOutput)) THEN 
      ALLOCATE(DstOutputData%WriteOutput(i1_l:i1_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstOutputData%WriteOutput.', ErrStat, ErrMsg,'AD_CopyOutput')
         RETURN
      END IF
   END IF
   DstOutputData%WriteOutput = SrcOutputData%WriteOutput
ENDIF
 END SUBROUTINE AD_CopyOutput

 SUBROUTINE AD_DestroyOutput( OutputData, ErrStat, ErrMsg )
  TYPE(AD_OutputType), INTENT(INOUT) :: OutputData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
IF (ALLOCATED(OutputData%inducedVel)) THEN
   DEALLOCATE(OutputData%inducedVel)
ENDIF
IF (ALLOCATED(OutputData%phi)) THEN
   DEALLOCATE(OutputData%phi)
ENDIF
IF (ALLOCATED(OutputData%WriteOutput)) THEN
   DEALLOCATE(OutputData%WriteOutput)
ENDIF
 END SUBROUTINE AD_DestroyOutput

 SUBROUTINE AD_PackOutput( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(AD_OutputType),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  IF ( ALLOCATED(InData%inducedVel) )   Re_BufSz    = Re_BufSz    + SIZE( InData%inducedVel )  ! inducedVel 
  IF ( ALLOCATED(InData%phi) )   Re_BufSz    = Re_BufSz    + SIZE( InData%phi )  ! phi 
  IF ( ALLOCATED(InData%WriteOutput) )   Re_BufSz    = Re_BufSz    + SIZE( InData%WriteOutput )  ! WriteOutput 
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  IF ( ALLOCATED(InData%inducedVel) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%inducedVel))-1 ) =  PACK(InData%inducedVel ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%inducedVel)
  ENDIF
  IF ( ALLOCATED(InData%phi) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%phi))-1 ) =  PACK(InData%phi ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%phi)
  ENDIF
  IF ( ALLOCATED(InData%WriteOutput) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%WriteOutput))-1 ) =  PACK(InData%WriteOutput ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%WriteOutput)
  ENDIF
 END SUBROUTINE AD_PackOutput

 SUBROUTINE AD_UnPackOutput( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(AD_OutputType), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  IF ( ALLOCATED(OutData%inducedVel) ) THEN
  ALLOCATE(mask2(SIZE(OutData%inducedVel,1),SIZE(OutData%inducedVel,2)))
  mask2 = .TRUE.
    OutData%inducedVel = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%inducedVel))-1 ),mask2,OutData%inducedVel)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%inducedVel)
  ENDIF
  IF ( ALLOCATED(OutData%phi) ) THEN
  ALLOCATE(mask2(SIZE(OutData%phi,1),SIZE(OutData%phi,2)))
  mask2 = .TRUE.
    OutData%phi = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%phi))-1 ),mask2,OutData%phi)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%phi)
  ENDIF
  IF ( ALLOCATED(OutData%WriteOutput) ) THEN
  ALLOCATE(mask1(SIZE(OutData%WriteOutput,1)))
  mask1 = .TRUE.
    OutData%WriteOutput = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%WriteOutput))-1 ),mask1,OutData%WriteOutput)
  DEALLOCATE(mask1)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%WriteOutput)
  ENDIF
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE AD_UnPackOutput


 SUBROUTINE AD_Input_ExtrapInterp(u, tin, u_out, tin_out, ErrStat, ErrMsg )
!
! This subroutine calculates a extrapolated (or interpolated) input u_out at time t_out, from previous/future time
! values of u (which has values associated with times in t).  Order of the interpolation is given by the size of u
!
!  expressions below based on either
!
!  f(t) = a
!  f(t) = a + b * t, or
!  f(t) = a + b * t + c * t**2
!
!  where a, b and c are determined as the solution to
!  f(t1) = u1, f(t2) = u2, f(t3) = u3  (as appropriate)
!
!..................................................................................................................................

 TYPE(AD_inputtype), INTENT(INOUT)  :: u(:)      ! Inputs at t1 > t2 > t3
 REAL(DbKi),         INTENT(IN   )  :: tin(:)      ! Times associated with the inputs
 TYPE(AD_inputtype), INTENT(INOUT)  :: u_out     ! Inputs at tin_out
 REAL(DbKi),         INTENT(IN   )  :: tin_out     ! time to be extrap/interp'd to
 INTEGER(IntKi),     INTENT(  OUT)  :: ErrStat   ! Error status of the operation
 CHARACTER(*),       INTENT(  OUT)  :: ErrMsg    ! Error message if ErrStat /= ErrID_None
   ! local variables
 REAL(DbKi) :: t(SIZE(tin))    ! Times associated with the inputs
 REAL(DbKi) :: t_out           ! Time to which to be extrap/interpd
 INTEGER(IntKi)                 :: order    ! order of polynomial fit (max 2)
 REAL(DbKi)                                 :: b0       ! temporary for extrapolation/interpolation
 REAL(DbKi)                                 :: c0       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:)        :: b1       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:)        :: c1       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:,:)      :: b2       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:,:)      :: c2       ! temporary for extrapolation/interpolation
 INTEGER(IntKi)                             :: ErrStat2 ! local errors
 CHARACTER(1024)                            :: ErrMsg2  ! local errors
    ! Initialize ErrStat
 ErrStat = ErrID_None
 ErrMsg  = ""
    ! we'll subtract a constant from the times to resolve some 
    ! numerical issues when t gets large (and to simplify the equations)
 t = tin - tin(1)
 t_out = tin_out - tin(1)

 if ( size(t) .ne. size(u)) then
    ErrStat = ErrID_Fatal
    ErrMsg = ' Error in AD_Input_ExtrapInterp: size(t) must equal size(u) '
    RETURN
 endif
 if (size(u) .gt. 3) then
    ErrStat = ErrID_Fatal
    ErrMsg  = ' Error in AD_Input_ExtrapInterp: size(u) must be less than 4 '
    RETURN
 endif
 order = SIZE(u) - 1
 IF ( order .eq. 0 ) THEN
IF (ALLOCATED(u_out%theta) .AND. ALLOCATED(u(1)%theta)) THEN
  u_out%theta = u(1)%theta
END IF ! check if allocated
  u_out%gamma = u(1)%gamma
IF (ALLOCATED(u_out%psi) .AND. ALLOCATED(u(1)%psi)) THEN
  u_out%psi = u(1)%psi
END IF ! check if allocated
  u_out%omega = u(1)%omega
IF (ALLOCATED(u_out%Vx) .AND. ALLOCATED(u(1)%Vx)) THEN
  u_out%Vx = u(1)%Vx
END IF ! check if allocated
IF (ALLOCATED(u_out%Vy) .AND. ALLOCATED(u(1)%Vy)) THEN
  u_out%Vy = u(1)%Vy
END IF ! check if allocated
IF (ALLOCATED(u_out%Vinf) .AND. ALLOCATED(u(1)%Vinf)) THEN
  u_out%Vinf = u(1)%Vinf
END IF ! check if allocated
  u_out%lambda = u(1)%lambda
IF (ALLOCATED(u_out%rTip) .AND. ALLOCATED(u(1)%rTip)) THEN
  u_out%rTip = u(1)%rTip
END IF ! check if allocated
IF (ALLOCATED(u_out%rLocal) .AND. ALLOCATED(u(1)%rLocal)) THEN
  u_out%rLocal = u(1)%rLocal
END IF ! check if allocated
 ELSE IF ( order .eq. 1 ) THEN
  IF ( EqualRealNos( t(1), t(2) ) ) THEN
    ErrStat = ErrID_Fatal
    ErrMsg  = ' Error in AD_Input_ExtrapInterp: t(1) must not equal t(2) to avoid a division-by-zero error.'
    RETURN
  END IF
IF (ALLOCATED(u_out%theta) .AND. ALLOCATED(u(1)%theta)) THEN
  ALLOCATE(b2(SIZE(u_out%theta,1),SIZE(u_out%theta,2) ))
  ALLOCATE(c2(SIZE(u_out%theta,1),SIZE(u_out%theta,2) ))
  b2 = -(u(1)%theta - u(2)%theta)/t(2)
  u_out%theta = u(1)%theta + b2 * t_out
  DEALLOCATE(b2)
  DEALLOCATE(c2)
END IF ! check if allocated
  b0 = -(u(1)%gamma - u(2)%gamma)/t(2)
  u_out%gamma = u(1)%gamma + b0 * t_out
IF (ALLOCATED(u_out%psi) .AND. ALLOCATED(u(1)%psi)) THEN
  ALLOCATE(b1(SIZE(u_out%psi,1)))
  ALLOCATE(c1(SIZE(u_out%psi,1)))
  b1 = -(u(1)%psi - u(2)%psi)/t(2)
  u_out%psi = u(1)%psi + b1 * t_out
  DEALLOCATE(b1)
  DEALLOCATE(c1)
END IF ! check if allocated
  b0 = -(u(1)%omega - u(2)%omega)/t(2)
  u_out%omega = u(1)%omega + b0 * t_out
IF (ALLOCATED(u_out%Vx) .AND. ALLOCATED(u(1)%Vx)) THEN
  ALLOCATE(b2(SIZE(u_out%Vx,1),SIZE(u_out%Vx,2) ))
  ALLOCATE(c2(SIZE(u_out%Vx,1),SIZE(u_out%Vx,2) ))
  b2 = -(u(1)%Vx - u(2)%Vx)/t(2)
  u_out%Vx = u(1)%Vx + b2 * t_out
  DEALLOCATE(b2)
  DEALLOCATE(c2)
END IF ! check if allocated
IF (ALLOCATED(u_out%Vy) .AND. ALLOCATED(u(1)%Vy)) THEN
  ALLOCATE(b2(SIZE(u_out%Vy,1),SIZE(u_out%Vy,2) ))
  ALLOCATE(c2(SIZE(u_out%Vy,1),SIZE(u_out%Vy,2) ))
  b2 = -(u(1)%Vy - u(2)%Vy)/t(2)
  u_out%Vy = u(1)%Vy + b2 * t_out
  DEALLOCATE(b2)
  DEALLOCATE(c2)
END IF ! check if allocated
IF (ALLOCATED(u_out%Vinf) .AND. ALLOCATED(u(1)%Vinf)) THEN
  ALLOCATE(b2(SIZE(u_out%Vinf,1),SIZE(u_out%Vinf,2) ))
  ALLOCATE(c2(SIZE(u_out%Vinf,1),SIZE(u_out%Vinf,2) ))
  b2 = -(u(1)%Vinf - u(2)%Vinf)/t(2)
  u_out%Vinf = u(1)%Vinf + b2 * t_out
  DEALLOCATE(b2)
  DEALLOCATE(c2)
END IF ! check if allocated
  b0 = -(u(1)%lambda - u(2)%lambda)/t(2)
  u_out%lambda = u(1)%lambda + b0 * t_out
IF (ALLOCATED(u_out%rTip) .AND. ALLOCATED(u(1)%rTip)) THEN
  ALLOCATE(b1(SIZE(u_out%rTip,1)))
  ALLOCATE(c1(SIZE(u_out%rTip,1)))
  b1 = -(u(1)%rTip - u(2)%rTip)/t(2)
  u_out%rTip = u(1)%rTip + b1 * t_out
  DEALLOCATE(b1)
  DEALLOCATE(c1)
END IF ! check if allocated
IF (ALLOCATED(u_out%rLocal) .AND. ALLOCATED(u(1)%rLocal)) THEN
  ALLOCATE(b2(SIZE(u_out%rLocal,1),SIZE(u_out%rLocal,2) ))
  ALLOCATE(c2(SIZE(u_out%rLocal,1),SIZE(u_out%rLocal,2) ))
  b2 = -(u(1)%rLocal - u(2)%rLocal)/t(2)
  u_out%rLocal = u(1)%rLocal + b2 * t_out
  DEALLOCATE(b2)
  DEALLOCATE(c2)
END IF ! check if allocated
 ELSE IF ( order .eq. 2 ) THEN
  IF ( EqualRealNos( t(1), t(2) ) ) THEN
    ErrStat = ErrID_Fatal
    ErrMsg  = ' Error in AD_Input_ExtrapInterp: t(1) must not equal t(2) to avoid a division-by-zero error.'
    RETURN
  END IF
  IF ( EqualRealNos( t(2), t(3) ) ) THEN
    ErrStat = ErrID_Fatal
    ErrMsg  = ' Error in AD_Input_ExtrapInterp: t(2) must not equal t(3) to avoid a division-by-zero error.'
    RETURN
  END IF
  IF ( EqualRealNos( t(1), t(3) ) ) THEN
    ErrStat = ErrID_Fatal
    ErrMsg  = ' Error in AD_Input_ExtrapInterp: t(1) must not equal t(3) to avoid a division-by-zero error.'
    RETURN
  END IF
IF (ALLOCATED(u_out%theta) .AND. ALLOCATED(u(1)%theta)) THEN
  ALLOCATE(b2(SIZE(u_out%theta,1),SIZE(u_out%theta,2) ))
  ALLOCATE(c2(SIZE(u_out%theta,1),SIZE(u_out%theta,2) ))
  b2 = (t(3)**2*(u(1)%theta - u(2)%theta) + t(2)**2*(-u(1)%theta + u(3)%theta))/(t(2)*t(3)*(t(2) - t(3)))
  c2 = ( (t(2)-t(3))*u(1)%theta + t(3)*u(2)%theta - t(2)*u(3)%theta ) / (t(2)*t(3)*(t(2) - t(3)))
  u_out%theta = u(1)%theta + b2 * t_out + c2 * t_out**2
  DEALLOCATE(b2)
  DEALLOCATE(c2)
END IF ! check if allocated
  b0 = (t(3)**2*(u(1)%gamma - u(2)%gamma) + t(2)**2*(-u(1)%gamma + u(3)%gamma))/(t(2)*t(3)*(t(2) - t(3)))
  c0 = ( (t(2)-t(3))*u(1)%gamma + t(3)*u(2)%gamma - t(2)*u(3)%gamma ) / (t(2)*t(3)*(t(2) - t(3)))
  u_out%gamma = u(1)%gamma + b0 * t_out + c0 * t_out**2
IF (ALLOCATED(u_out%psi) .AND. ALLOCATED(u(1)%psi)) THEN
  ALLOCATE(b1(SIZE(u_out%psi,1)))
  ALLOCATE(c1(SIZE(u_out%psi,1)))
  b1 = (t(3)**2*(u(1)%psi - u(2)%psi) + t(2)**2*(-u(1)%psi + u(3)%psi))/(t(2)*t(3)*(t(2) - t(3)))
  c1 = ( (t(2)-t(3))*u(1)%psi + t(3)*u(2)%psi - t(2)*u(3)%psi ) / (t(2)*t(3)*(t(2) - t(3)))
  u_out%psi = u(1)%psi + b1 * t_out + c1 * t_out**2
  DEALLOCATE(b1)
  DEALLOCATE(c1)
END IF ! check if allocated
  b0 = (t(3)**2*(u(1)%omega - u(2)%omega) + t(2)**2*(-u(1)%omega + u(3)%omega))/(t(2)*t(3)*(t(2) - t(3)))
  c0 = ( (t(2)-t(3))*u(1)%omega + t(3)*u(2)%omega - t(2)*u(3)%omega ) / (t(2)*t(3)*(t(2) - t(3)))
  u_out%omega = u(1)%omega + b0 * t_out + c0 * t_out**2
IF (ALLOCATED(u_out%Vx) .AND. ALLOCATED(u(1)%Vx)) THEN
  ALLOCATE(b2(SIZE(u_out%Vx,1),SIZE(u_out%Vx,2) ))
  ALLOCATE(c2(SIZE(u_out%Vx,1),SIZE(u_out%Vx,2) ))
  b2 = (t(3)**2*(u(1)%Vx - u(2)%Vx) + t(2)**2*(-u(1)%Vx + u(3)%Vx))/(t(2)*t(3)*(t(2) - t(3)))
  c2 = ( (t(2)-t(3))*u(1)%Vx + t(3)*u(2)%Vx - t(2)*u(3)%Vx ) / (t(2)*t(3)*(t(2) - t(3)))
  u_out%Vx = u(1)%Vx + b2 * t_out + c2 * t_out**2
  DEALLOCATE(b2)
  DEALLOCATE(c2)
END IF ! check if allocated
IF (ALLOCATED(u_out%Vy) .AND. ALLOCATED(u(1)%Vy)) THEN
  ALLOCATE(b2(SIZE(u_out%Vy,1),SIZE(u_out%Vy,2) ))
  ALLOCATE(c2(SIZE(u_out%Vy,1),SIZE(u_out%Vy,2) ))
  b2 = (t(3)**2*(u(1)%Vy - u(2)%Vy) + t(2)**2*(-u(1)%Vy + u(3)%Vy))/(t(2)*t(3)*(t(2) - t(3)))
  c2 = ( (t(2)-t(3))*u(1)%Vy + t(3)*u(2)%Vy - t(2)*u(3)%Vy ) / (t(2)*t(3)*(t(2) - t(3)))
  u_out%Vy = u(1)%Vy + b2 * t_out + c2 * t_out**2
  DEALLOCATE(b2)
  DEALLOCATE(c2)
END IF ! check if allocated
IF (ALLOCATED(u_out%Vinf) .AND. ALLOCATED(u(1)%Vinf)) THEN
  ALLOCATE(b2(SIZE(u_out%Vinf,1),SIZE(u_out%Vinf,2) ))
  ALLOCATE(c2(SIZE(u_out%Vinf,1),SIZE(u_out%Vinf,2) ))
  b2 = (t(3)**2*(u(1)%Vinf - u(2)%Vinf) + t(2)**2*(-u(1)%Vinf + u(3)%Vinf))/(t(2)*t(3)*(t(2) - t(3)))
  c2 = ( (t(2)-t(3))*u(1)%Vinf + t(3)*u(2)%Vinf - t(2)*u(3)%Vinf ) / (t(2)*t(3)*(t(2) - t(3)))
  u_out%Vinf = u(1)%Vinf + b2 * t_out + c2 * t_out**2
  DEALLOCATE(b2)
  DEALLOCATE(c2)
END IF ! check if allocated
  b0 = (t(3)**2*(u(1)%lambda - u(2)%lambda) + t(2)**2*(-u(1)%lambda + u(3)%lambda))/(t(2)*t(3)*(t(2) - t(3)))
  c0 = ( (t(2)-t(3))*u(1)%lambda + t(3)*u(2)%lambda - t(2)*u(3)%lambda ) / (t(2)*t(3)*(t(2) - t(3)))
  u_out%lambda = u(1)%lambda + b0 * t_out + c0 * t_out**2
IF (ALLOCATED(u_out%rTip) .AND. ALLOCATED(u(1)%rTip)) THEN
  ALLOCATE(b1(SIZE(u_out%rTip,1)))
  ALLOCATE(c1(SIZE(u_out%rTip,1)))
  b1 = (t(3)**2*(u(1)%rTip - u(2)%rTip) + t(2)**2*(-u(1)%rTip + u(3)%rTip))/(t(2)*t(3)*(t(2) - t(3)))
  c1 = ( (t(2)-t(3))*u(1)%rTip + t(3)*u(2)%rTip - t(2)*u(3)%rTip ) / (t(2)*t(3)*(t(2) - t(3)))
  u_out%rTip = u(1)%rTip + b1 * t_out + c1 * t_out**2
  DEALLOCATE(b1)
  DEALLOCATE(c1)
END IF ! check if allocated
IF (ALLOCATED(u_out%rLocal) .AND. ALLOCATED(u(1)%rLocal)) THEN
  ALLOCATE(b2(SIZE(u_out%rLocal,1),SIZE(u_out%rLocal,2) ))
  ALLOCATE(c2(SIZE(u_out%rLocal,1),SIZE(u_out%rLocal,2) ))
  b2 = (t(3)**2*(u(1)%rLocal - u(2)%rLocal) + t(2)**2*(-u(1)%rLocal + u(3)%rLocal))/(t(2)*t(3)*(t(2) - t(3)))
  c2 = ( (t(2)-t(3))*u(1)%rLocal + t(3)*u(2)%rLocal - t(2)*u(3)%rLocal ) / (t(2)*t(3)*(t(2) - t(3)))
  u_out%rLocal = u(1)%rLocal + b2 * t_out + c2 * t_out**2
  DEALLOCATE(b2)
  DEALLOCATE(c2)
END IF ! check if allocated
 ELSE 
   ErrStat = ErrID_Fatal
   ErrMsg = ' order must be less than 3 in AD_Input_ExtrapInterp '
   RETURN
 ENDIF 
 END SUBROUTINE AD_Input_ExtrapInterp


 SUBROUTINE AD_Output_ExtrapInterp(u, tin, u_out, tin_out, ErrStat, ErrMsg )
!
! This subroutine calculates a extrapolated (or interpolated) input u_out at time t_out, from previous/future time
! values of u (which has values associated with times in t).  Order of the interpolation is given by the size of u
!
!  expressions below based on either
!
!  f(t) = a
!  f(t) = a + b * t, or
!  f(t) = a + b * t + c * t**2
!
!  where a, b and c are determined as the solution to
!  f(t1) = u1, f(t2) = u2, f(t3) = u3  (as appropriate)
!
!..................................................................................................................................

 TYPE(AD_outputtype), INTENT(INOUT)  :: u(:)      ! Inputs at t1 > t2 > t3
 REAL(DbKi),         INTENT(IN   )  :: tin(:)      ! Times associated with the inputs
 TYPE(AD_outputtype), INTENT(INOUT)  :: u_out     ! Inputs at tin_out
 REAL(DbKi),         INTENT(IN   )  :: tin_out     ! time to be extrap/interp'd to
 INTEGER(IntKi),     INTENT(  OUT)  :: ErrStat   ! Error status of the operation
 CHARACTER(*),       INTENT(  OUT)  :: ErrMsg    ! Error message if ErrStat /= ErrID_None
   ! local variables
 REAL(DbKi) :: t(SIZE(tin))    ! Times associated with the inputs
 REAL(DbKi) :: t_out           ! Time to which to be extrap/interpd
 INTEGER(IntKi)                 :: order    ! order of polynomial fit (max 2)
 REAL(DbKi)                                 :: b0       ! temporary for extrapolation/interpolation
 REAL(DbKi)                                 :: c0       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:)        :: b1       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:)        :: c1       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:,:)      :: b2       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:,:)      :: c2       ! temporary for extrapolation/interpolation
 INTEGER(IntKi)                             :: ErrStat2 ! local errors
 CHARACTER(1024)                            :: ErrMsg2  ! local errors
    ! Initialize ErrStat
 ErrStat = ErrID_None
 ErrMsg  = ""
    ! we'll subtract a constant from the times to resolve some 
    ! numerical issues when t gets large (and to simplify the equations)
 t = tin - tin(1)
 t_out = tin_out - tin(1)

 if ( size(t) .ne. size(u)) then
    ErrStat = ErrID_Fatal
    ErrMsg = ' Error in AD_Output_ExtrapInterp: size(t) must equal size(u) '
    RETURN
 endif
 if (size(u) .gt. 3) then
    ErrStat = ErrID_Fatal
    ErrMsg  = ' Error in AD_Output_ExtrapInterp: size(u) must be less than 4 '
    RETURN
 endif
 order = SIZE(u) - 1
 IF ( order .eq. 0 ) THEN
IF (ALLOCATED(u_out%inducedVel) .AND. ALLOCATED(u(1)%inducedVel)) THEN
  u_out%inducedVel = u(1)%inducedVel
END IF ! check if allocated
IF (ALLOCATED(u_out%phi) .AND. ALLOCATED(u(1)%phi)) THEN
  u_out%phi = u(1)%phi
END IF ! check if allocated
IF (ALLOCATED(u_out%WriteOutput) .AND. ALLOCATED(u(1)%WriteOutput)) THEN
  u_out%WriteOutput = u(1)%WriteOutput
END IF ! check if allocated
 ELSE IF ( order .eq. 1 ) THEN
  IF ( EqualRealNos( t(1), t(2) ) ) THEN
    ErrStat = ErrID_Fatal
    ErrMsg  = ' Error in AD_Output_ExtrapInterp: t(1) must not equal t(2) to avoid a division-by-zero error.'
    RETURN
  END IF
IF (ALLOCATED(u_out%inducedVel) .AND. ALLOCATED(u(1)%inducedVel)) THEN
  ALLOCATE(b2(SIZE(u_out%inducedVel,1),SIZE(u_out%inducedVel,2) ))
  ALLOCATE(c2(SIZE(u_out%inducedVel,1),SIZE(u_out%inducedVel,2) ))
  b2 = -(u(1)%inducedVel - u(2)%inducedVel)/t(2)
  u_out%inducedVel = u(1)%inducedVel + b2 * t_out
  DEALLOCATE(b2)
  DEALLOCATE(c2)
END IF ! check if allocated
IF (ALLOCATED(u_out%phi) .AND. ALLOCATED(u(1)%phi)) THEN
  ALLOCATE(b2(SIZE(u_out%phi,1),SIZE(u_out%phi,2) ))
  ALLOCATE(c2(SIZE(u_out%phi,1),SIZE(u_out%phi,2) ))
  b2 = -(u(1)%phi - u(2)%phi)/t(2)
  u_out%phi = u(1)%phi + b2 * t_out
  DEALLOCATE(b2)
  DEALLOCATE(c2)
END IF ! check if allocated
IF (ALLOCATED(u_out%WriteOutput) .AND. ALLOCATED(u(1)%WriteOutput)) THEN
  ALLOCATE(b1(SIZE(u_out%WriteOutput,1)))
  ALLOCATE(c1(SIZE(u_out%WriteOutput,1)))
  b1 = -(u(1)%WriteOutput - u(2)%WriteOutput)/t(2)
  u_out%WriteOutput = u(1)%WriteOutput + b1 * t_out
  DEALLOCATE(b1)
  DEALLOCATE(c1)
END IF ! check if allocated
 ELSE IF ( order .eq. 2 ) THEN
  IF ( EqualRealNos( t(1), t(2) ) ) THEN
    ErrStat = ErrID_Fatal
    ErrMsg  = ' Error in AD_Output_ExtrapInterp: t(1) must not equal t(2) to avoid a division-by-zero error.'
    RETURN
  END IF
  IF ( EqualRealNos( t(2), t(3) ) ) THEN
    ErrStat = ErrID_Fatal
    ErrMsg  = ' Error in AD_Output_ExtrapInterp: t(2) must not equal t(3) to avoid a division-by-zero error.'
    RETURN
  END IF
  IF ( EqualRealNos( t(1), t(3) ) ) THEN
    ErrStat = ErrID_Fatal
    ErrMsg  = ' Error in AD_Output_ExtrapInterp: t(1) must not equal t(3) to avoid a division-by-zero error.'
    RETURN
  END IF
IF (ALLOCATED(u_out%inducedVel) .AND. ALLOCATED(u(1)%inducedVel)) THEN
  ALLOCATE(b2(SIZE(u_out%inducedVel,1),SIZE(u_out%inducedVel,2) ))
  ALLOCATE(c2(SIZE(u_out%inducedVel,1),SIZE(u_out%inducedVel,2) ))
  b2 = (t(3)**2*(u(1)%inducedVel - u(2)%inducedVel) + t(2)**2*(-u(1)%inducedVel + u(3)%inducedVel))/(t(2)*t(3)*(t(2) - t(3)))
  c2 = ( (t(2)-t(3))*u(1)%inducedVel + t(3)*u(2)%inducedVel - t(2)*u(3)%inducedVel ) / (t(2)*t(3)*(t(2) - t(3)))
  u_out%inducedVel = u(1)%inducedVel + b2 * t_out + c2 * t_out**2
  DEALLOCATE(b2)
  DEALLOCATE(c2)
END IF ! check if allocated
IF (ALLOCATED(u_out%phi) .AND. ALLOCATED(u(1)%phi)) THEN
  ALLOCATE(b2(SIZE(u_out%phi,1),SIZE(u_out%phi,2) ))
  ALLOCATE(c2(SIZE(u_out%phi,1),SIZE(u_out%phi,2) ))
  b2 = (t(3)**2*(u(1)%phi - u(2)%phi) + t(2)**2*(-u(1)%phi + u(3)%phi))/(t(2)*t(3)*(t(2) - t(3)))
  c2 = ( (t(2)-t(3))*u(1)%phi + t(3)*u(2)%phi - t(2)*u(3)%phi ) / (t(2)*t(3)*(t(2) - t(3)))
  u_out%phi = u(1)%phi + b2 * t_out + c2 * t_out**2
  DEALLOCATE(b2)
  DEALLOCATE(c2)
END IF ! check if allocated
IF (ALLOCATED(u_out%WriteOutput) .AND. ALLOCATED(u(1)%WriteOutput)) THEN
  ALLOCATE(b1(SIZE(u_out%WriteOutput,1)))
  ALLOCATE(c1(SIZE(u_out%WriteOutput,1)))
  b1 = (t(3)**2*(u(1)%WriteOutput - u(2)%WriteOutput) + t(2)**2*(-u(1)%WriteOutput + u(3)%WriteOutput))/(t(2)*t(3)*(t(2) - t(3)))
  c1 = ( (t(2)-t(3))*u(1)%WriteOutput + t(3)*u(2)%WriteOutput - t(2)*u(3)%WriteOutput ) / (t(2)*t(3)*(t(2) - t(3)))
  u_out%WriteOutput = u(1)%WriteOutput + b1 * t_out + c1 * t_out**2
  DEALLOCATE(b1)
  DEALLOCATE(c1)
END IF ! check if allocated
 ELSE 
   ErrStat = ErrID_Fatal
   ErrMsg = ' order must be less than 3 in AD_Output_ExtrapInterp '
   RETURN
 ENDIF 
 END SUBROUTINE AD_Output_ExtrapInterp

END MODULE AeroDyn_Types
!ENDOFREGISTRYGENERATEDFILE
