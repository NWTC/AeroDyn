!STARTOFREGISTRYGENERATEDFILE './BEM_Types.f90'
!
! WARNING This file is generated automatically by the FAST registry
! Do not edit.  Your changes to this file will be lost.
!
! FAST Registry (v2.03.01, 18-June-2014)
!*********************************************************************************************************************************
! BEM_Types
!.................................................................................................................................
! This file is part of BEM.
!
! Copyright (C) 2012-2014 National Renewable Energy Laboratory
!
! Licensed under the Apache License, Version 2.0 (the "License");
! you may not use this file except in compliance with the License.
! You may obtain a copy of the License at
!
!     http://www.apache.org/licenses/LICENSE-2.0
!
! Unless required by applicable law or agreed to in writing, software
! distributed under the License is distributed on an "AS IS" BASIS,
! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
! See the License for the specific language governing permissions and
! limitations under the License.
!
!
! W A R N I N G : This file was automatically generated from the FAST registry.  Changes made to this file may be lost.
!
!*********************************************************************************************************************************
MODULE BEM_Types
! This module contains all of the user-defined types needed in BEM. It also contains copy, destroy, pack, and
! unpack routines associated with each defined data type. This code will be generated by the FAST Registry.
!---------------------------------------------------------------------------------------------------------------------------------
USE AirfoilInfo_Types
USE NWTC_Library
IMPLICIT NONE
! =========  BEM_InitInputType  =======
  TYPE, PUBLIC :: BEM_InitInputType
    REAL(DbKi)  :: DT      ! time step [s]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: chord      ! Chord length at node [m]
    INTEGER(IntKi)  :: numBlades      ! Number of blades [-]
    REAL(ReKi)  :: airDens      ! Air density [kg/m^3]
    REAL(ReKi)  :: kinVisc      ! Kinematic air viscosity [m^2/s]
    INTEGER(IntKi)  :: skewWakeMod      ! Skewed-wake correction model [switch] {0: no correction, 1: Pitt and Peters, 2: Teknikgruppen AB, 3: Coupled model} [-]
    LOGICAL  :: useTipLoss      ! Use the Prandtl tip-loss model?  [flag] [-]
    LOGICAL  :: useHubLoss      ! Use the Prandtl hub-loss model?  [flag] [-]
    LOGICAL  :: useInduction      ! Include induction in BEM calculations [flag] { If FALSE then useTanInd will be set to FALSE} [-]
    LOGICAL  :: useTanInd      ! Include tangential induction in BEM calculations [flag] [-]
    LOGICAL  :: useAIDrag      ! Include the drag term in the axial-induction calculation?  [flag] [-]
    LOGICAL  :: useTIDrag      ! Include the drag term in the tangential-induction calculation?  Ignored if TanInd is False.  [flag] [-]
    INTEGER(IntKi)  :: numBladeNodes      ! Number of blade nodes used in the analysis [-]
    INTEGER(IntKi)  :: numReIterations      ! Number of iterations for finding the Reynolds number [-]
    INTEGER(IntKi)  :: maxIndIterations      ! Maximum number of iterations of induction factor solve [-]
    INTEGER(IntKi) , DIMENSION(:), ALLOCATABLE  :: AFindx      ! Index of airfoil data file for blade node location [array of numBladeNodes] [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: zHub      ! Distance to hub for each blade [m]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: zLocal      ! Distance to blade node, measured along the blade [m]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: zTip      ! Distance to blade tip, measured along the blade [m]
    TYPE(AFInfoType) , DIMENSION(:), ALLOCATABLE  :: AFInfo      ! Parameters for the airfoils [-]
    INTEGER(IntKi)  :: NumAF      ! Parameters for the BEMT module [-]
    CHARACTER(1024) , DIMENSION(:), ALLOCATABLE  :: AF_File      ! Parameters for the BEMT module [-]
  END TYPE BEM_InitInputType
! =======================
! =========  BEM_InitOutputType  =======
  TYPE, PUBLIC :: BEM_InitOutputType
    TYPE(ProgDesc)  :: Version      !  [-]
  END TYPE BEM_InitOutputType
! =======================
! =========  BEM_ContinuousStateType  =======
  TYPE, PUBLIC :: BEM_ContinuousStateType
    REAL(ReKi)  :: DummyContState      ! Remove this variable if you have continuous states [-]
  END TYPE BEM_ContinuousStateType
! =======================
! =========  BEM_DiscreteStateType  =======
  TYPE, PUBLIC :: BEM_DiscreteStateType
    REAL(ReKi)  :: DummyDiscState      !  [-]
  END TYPE BEM_DiscreteStateType
! =======================
! =========  BEM_ConstraintStateType  =======
  TYPE, PUBLIC :: BEM_ConstraintStateType
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: phi      ! angle between the plane of rotation and the direction of the local wind [rad]
  END TYPE BEM_ConstraintStateType
! =======================
! =========  BEM_OtherStateType  =======
  TYPE, PUBLIC :: BEM_OtherStateType
    REAL(ReKi)  :: DummyOtherState      !  [-]
  END TYPE BEM_OtherStateType
! =======================
! =========  BEM_ParameterType  =======
  TYPE, PUBLIC :: BEM_ParameterType
    REAL(DbKi)  :: DT      ! time step [s]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: chord      ! Chord length at node [m]
    INTEGER(IntKi)  :: numBlades      ! Number of blades [-]
    REAL(ReKi)  :: airDens      ! Air density [kg/m^3]
    REAL(ReKi)  :: kinVisc      ! Kinematic air viscosity [m^2/s]
    INTEGER(IntKi)  :: skewWakeMod      ! Skewed-wake correction model [switch] {0: no correction, 1: Pitt and Peters, 2: Teknikgruppen AB, 3: Coupled model} [-]
    LOGICAL  :: useTipLoss      ! Use the Prandtl tip-loss model?  [flag] [-]
    LOGICAL  :: useHubLoss      ! Use the Prandtl hub-loss model?  [flag] [-]
    LOGICAL  :: useTanInd      ! Include tangential induction in BEM calculations [flag] [-]
    LOGICAL  :: useAIDrag      ! Include the drag term in the axial-induction calculation?  [flag] [-]
    LOGICAL  :: useTIDrag      ! Include the drag term in the tangential-induction calculation?  Ignored if TanInd is False.  [flag] [-]
    INTEGER(IntKi)  :: numBladeNodes      ! Number of blade nodes used in the analysis [-]
    INTEGER(IntKi)  :: numReIterations      ! Number of iterations for finding the Reynolds number [-]
    INTEGER(IntKi)  :: maxIndIterations      ! Maximum number of iterations of induction factor solve [-]
    INTEGER(IntKi) , DIMENSION(:), ALLOCATABLE  :: AFindx      ! Index of airfoil data file for blade node location [array of numBladeNodes] [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: tipLossConst      ! A constant computed during initialization based on B*(zTip-zLocal)/(2*zLocal) [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: hubLossConst      ! A constant computed during initialization based on B*(zLocal-zHub)/(2*zHub) [-]
    TYPE(AFInfoType) , DIMENSION(:), ALLOCATABLE  :: AFInfo      ! Parameters for the airfoils [-]
  END TYPE BEM_ParameterType
! =======================
! =========  BEM_InputType  =======
  TYPE, PUBLIC :: BEM_InputType
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: theta      ! Twist angle (includes all sources of twist)  [Array of size (numBlades, NumBlNds)] [rad]
    REAL(ReKi)  :: gamma      ! Yaw angle [rad]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: psi      ! Azimuth angle [rad]
    REAL(ReKi)  :: omega      ! Angular velocity of rotor [rad/s]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: Vx      ! Local axial velocity at node [m/s]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: Vy      ! Local tangential velocity at node [m/s]
    REAL(ReKi)  :: lambda      ! Average tip speed ratio for rotor disk [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: rTip      ! Radial distance from center-of-rotation to blade tip [m]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: rLocal      ! Radial distance from center-of-rotation to node [m]
  END TYPE BEM_InputType
! =======================
! =========  BEM_OutputType  =======
  TYPE, PUBLIC :: BEM_OutputType
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: inducedVel      ! Total local induced velocity [m/s]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: phi      ! angle between the plane of rotation and the direction of the local wind [rad]
  END TYPE BEM_OutputType
! =======================
CONTAINS
 SUBROUTINE BEM_CopyInitInput( SrcInitInputData, DstInitInputData, CtrlCode, ErrStat, ErrMsg )
   TYPE(BEM_initinputtype), INTENT(INOUT) :: SrcInitInputData
   TYPE(BEM_initinputtype), INTENT(INOUT) :: DstInitInputData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5,j,k
   INTEGER(IntKi)                 :: i1_l,i2_l,i3_l,i4_l,i5_l  ! lower bounds for an array dimension
   INTEGER(IntKi)                 :: i1_u,i2_u,i3_u,i4_u,i5_u  ! upper bounds for an array dimension
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
   DstInitInputData%DT = SrcInitInputData%DT
IF (ALLOCATED(SrcInitInputData%chord)) THEN
   i1_l = LBOUND(SrcInitInputData%chord,1)
   i1_u = UBOUND(SrcInitInputData%chord,1)
   i2_l = LBOUND(SrcInitInputData%chord,2)
   i2_u = UBOUND(SrcInitInputData%chord,2)
   IF (.NOT. ALLOCATED(DstInitInputData%chord)) THEN 
      ALLOCATE(DstInitInputData%chord(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'BEM_CopyInitInput: Error allocating DstInitInputData%chord.'
         RETURN
      END IF
   END IF
   DstInitInputData%chord = SrcInitInputData%chord
ENDIF
   DstInitInputData%numBlades = SrcInitInputData%numBlades
   DstInitInputData%airDens = SrcInitInputData%airDens
   DstInitInputData%kinVisc = SrcInitInputData%kinVisc
   DstInitInputData%skewWakeMod = SrcInitInputData%skewWakeMod
   DstInitInputData%useTipLoss = SrcInitInputData%useTipLoss
   DstInitInputData%useHubLoss = SrcInitInputData%useHubLoss
   DstInitInputData%useInduction = SrcInitInputData%useInduction
   DstInitInputData%useTanInd = SrcInitInputData%useTanInd
   DstInitInputData%useAIDrag = SrcInitInputData%useAIDrag
   DstInitInputData%useTIDrag = SrcInitInputData%useTIDrag
   DstInitInputData%numBladeNodes = SrcInitInputData%numBladeNodes
   DstInitInputData%numReIterations = SrcInitInputData%numReIterations
   DstInitInputData%maxIndIterations = SrcInitInputData%maxIndIterations
IF (ALLOCATED(SrcInitInputData%AFindx)) THEN
   i1_l = LBOUND(SrcInitInputData%AFindx,1)
   i1_u = UBOUND(SrcInitInputData%AFindx,1)
   IF (.NOT. ALLOCATED(DstInitInputData%AFindx)) THEN 
      ALLOCATE(DstInitInputData%AFindx(i1_l:i1_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'BEM_CopyInitInput: Error allocating DstInitInputData%AFindx.'
         RETURN
      END IF
   END IF
   DstInitInputData%AFindx = SrcInitInputData%AFindx
ENDIF
IF (ALLOCATED(SrcInitInputData%zHub)) THEN
   i1_l = LBOUND(SrcInitInputData%zHub,1)
   i1_u = UBOUND(SrcInitInputData%zHub,1)
   IF (.NOT. ALLOCATED(DstInitInputData%zHub)) THEN 
      ALLOCATE(DstInitInputData%zHub(i1_l:i1_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'BEM_CopyInitInput: Error allocating DstInitInputData%zHub.'
         RETURN
      END IF
   END IF
   DstInitInputData%zHub = SrcInitInputData%zHub
ENDIF
IF (ALLOCATED(SrcInitInputData%zLocal)) THEN
   i1_l = LBOUND(SrcInitInputData%zLocal,1)
   i1_u = UBOUND(SrcInitInputData%zLocal,1)
   i2_l = LBOUND(SrcInitInputData%zLocal,2)
   i2_u = UBOUND(SrcInitInputData%zLocal,2)
   IF (.NOT. ALLOCATED(DstInitInputData%zLocal)) THEN 
      ALLOCATE(DstInitInputData%zLocal(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'BEM_CopyInitInput: Error allocating DstInitInputData%zLocal.'
         RETURN
      END IF
   END IF
   DstInitInputData%zLocal = SrcInitInputData%zLocal
ENDIF
IF (ALLOCATED(SrcInitInputData%zTip)) THEN
   i1_l = LBOUND(SrcInitInputData%zTip,1)
   i1_u = UBOUND(SrcInitInputData%zTip,1)
   IF (.NOT. ALLOCATED(DstInitInputData%zTip)) THEN 
      ALLOCATE(DstInitInputData%zTip(i1_l:i1_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'BEM_CopyInitInput: Error allocating DstInitInputData%zTip.'
         RETURN
      END IF
   END IF
   DstInitInputData%zTip = SrcInitInputData%zTip
ENDIF
IF (ALLOCATED(SrcInitInputData%AFInfo)) THEN
   i1_l = LBOUND(SrcInitInputData%AFInfo,1)
   i1_u = UBOUND(SrcInitInputData%AFInfo,1)
   IF (.NOT. ALLOCATED(DstInitInputData%AFInfo)) THEN 
      ALLOCATE(DstInitInputData%AFInfo(i1_l:i1_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'BEM_CopyInitInput: Error allocating DstInitInputData%AFInfo.'
         RETURN
      END IF
   END IF
   DO i1 = LBOUND(SrcInitInputData%AFInfo,1), UBOUND(SrcInitInputData%AFInfo,1)
      CALL AFI_Copyafinfotype( SrcInitInputData%AFInfo(i1), DstInitInputData%AFInfo(i1), CtrlCode, ErrStat, ErrMsg )
   ENDDO
ENDIF
   DstInitInputData%NumAF = SrcInitInputData%NumAF
IF (ALLOCATED(SrcInitInputData%AF_File)) THEN
   i1_l = LBOUND(SrcInitInputData%AF_File,1)
   i1_u = UBOUND(SrcInitInputData%AF_File,1)
   IF (.NOT. ALLOCATED(DstInitInputData%AF_File)) THEN 
      ALLOCATE(DstInitInputData%AF_File(i1_l:i1_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'BEM_CopyInitInput: Error allocating DstInitInputData%AF_File.'
         RETURN
      END IF
   END IF
   DstInitInputData%AF_File = SrcInitInputData%AF_File
ENDIF
 END SUBROUTINE BEM_CopyInitInput

 SUBROUTINE BEM_DestroyInitInput( InitInputData, ErrStat, ErrMsg )
  TYPE(BEM_initinputtype), INTENT(INOUT) :: InitInputData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
IF (ALLOCATED(InitInputData%chord)) THEN
   DEALLOCATE(InitInputData%chord)
ENDIF
IF (ALLOCATED(InitInputData%AFindx)) THEN
   DEALLOCATE(InitInputData%AFindx)
ENDIF
IF (ALLOCATED(InitInputData%zHub)) THEN
   DEALLOCATE(InitInputData%zHub)
ENDIF
IF (ALLOCATED(InitInputData%zLocal)) THEN
   DEALLOCATE(InitInputData%zLocal)
ENDIF
IF (ALLOCATED(InitInputData%zTip)) THEN
   DEALLOCATE(InitInputData%zTip)
ENDIF
IF (ALLOCATED(InitInputData%AFInfo)) THEN
DO i1 = LBOUND(InitInputData%AFInfo,1), UBOUND(InitInputData%AFInfo,1)
  CALL AFI_Destroyafinfotype( InitInputData%AFInfo(i1), ErrStat, ErrMsg )
ENDDO
   DEALLOCATE(InitInputData%AFInfo)
ENDIF
IF (ALLOCATED(InitInputData%AF_File)) THEN
   DEALLOCATE(InitInputData%AF_File)
ENDIF
 END SUBROUTINE BEM_DestroyInitInput

 SUBROUTINE BEM_PackInitInput( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(BEM_initinputtype),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  REAL(ReKi),     ALLOCATABLE :: Re_AFInfo_Buf(:)
  REAL(DbKi),     ALLOCATABLE :: Db_AFInfo_Buf(:)
  INTEGER(IntKi), ALLOCATABLE :: Int_AFInfo_Buf(:)
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  Db_BufSz   = Db_BufSz   + 1  ! DT
  Re_BufSz    = Re_BufSz    + SIZE( InData%chord )  ! chord 
  Int_BufSz  = Int_BufSz  + 1  ! numBlades
  Re_BufSz   = Re_BufSz   + 1  ! airDens
  Re_BufSz   = Re_BufSz   + 1  ! kinVisc
  Int_BufSz  = Int_BufSz  + 1  ! skewWakeMod
  Int_BufSz  = Int_BufSz  + 1  ! numBladeNodes
  Int_BufSz  = Int_BufSz  + 1  ! numReIterations
  Int_BufSz  = Int_BufSz  + 1  ! maxIndIterations
  Int_BufSz   = Int_BufSz   + SIZE( InData%AFindx )  ! AFindx 
  Re_BufSz    = Re_BufSz    + SIZE( InData%zHub )  ! zHub 
  Re_BufSz    = Re_BufSz    + SIZE( InData%zLocal )  ! zLocal 
  Re_BufSz    = Re_BufSz    + SIZE( InData%zTip )  ! zTip 
DO i1 = LBOUND(InData%AFInfo,1), UBOUND(InData%AFInfo,1)
  CALL AFI_Packafinfotype( Re_AFInfo_Buf, Db_AFInfo_Buf, Int_AFInfo_Buf, InData%AFInfo(i1), ErrStat, ErrMsg, .TRUE. ) ! AFInfo 
  IF(ALLOCATED(Re_AFInfo_Buf)) Re_BufSz  = Re_BufSz  + SIZE( Re_AFInfo_Buf  ) ! AFInfo
  IF(ALLOCATED(Db_AFInfo_Buf)) Db_BufSz  = Db_BufSz  + SIZE( Db_AFInfo_Buf  ) ! AFInfo
  IF(ALLOCATED(Int_AFInfo_Buf))Int_BufSz = Int_BufSz + SIZE( Int_AFInfo_Buf ) ! AFInfo
  IF(ALLOCATED(Re_AFInfo_Buf))  DEALLOCATE(Re_AFInfo_Buf)
  IF(ALLOCATED(Db_AFInfo_Buf))  DEALLOCATE(Db_AFInfo_Buf)
  IF(ALLOCATED(Int_AFInfo_Buf)) DEALLOCATE(Int_AFInfo_Buf)
ENDDO
  Int_BufSz  = Int_BufSz  + 1  ! NumAF
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  IF ( .NOT. OnlySize ) DbKiBuf ( Db_Xferred:Db_Xferred+(1)-1 ) =  (InData%DT )
  Db_Xferred   = Db_Xferred   + 1
  IF ( ALLOCATED(InData%chord) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%chord))-1 ) =  PACK(InData%chord ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%chord)
  ENDIF
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%numBlades )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%airDens )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%kinVisc )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%skewWakeMod )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%numBladeNodes )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%numReIterations )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%maxIndIterations )
  Int_Xferred   = Int_Xferred   + 1
  IF ( ALLOCATED(InData%AFindx) ) THEN
    IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(SIZE(InData%AFindx))-1 ) = PACK(InData%AFindx ,.TRUE.)
    Int_Xferred   = Int_Xferred   + SIZE(InData%AFindx)
  ENDIF
  IF ( ALLOCATED(InData%zHub) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%zHub))-1 ) =  PACK(InData%zHub ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%zHub)
  ENDIF
  IF ( ALLOCATED(InData%zLocal) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%zLocal))-1 ) =  PACK(InData%zLocal ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%zLocal)
  ENDIF
  IF ( ALLOCATED(InData%zTip) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%zTip))-1 ) =  PACK(InData%zTip ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%zTip)
  ENDIF
DO i1 = LBOUND(InData%AFInfo,1), UBOUND(InData%AFInfo,1)
  CALL AFI_Packafinfotype( Re_AFInfo_Buf, Db_AFInfo_Buf, Int_AFInfo_Buf, InData%AFInfo(i1), ErrStat, ErrMsg, OnlySize ) ! AFInfo 
  IF(ALLOCATED(Re_AFInfo_Buf)) THEN
    IF ( .NOT. OnlySize ) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_AFInfo_Buf)-1 ) = Re_AFInfo_Buf
    Re_Xferred = Re_Xferred + SIZE(Re_AFInfo_Buf)
  ENDIF
  IF(ALLOCATED(Db_AFInfo_Buf)) THEN
    IF ( .NOT. OnlySize ) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_AFInfo_Buf)-1 ) = Db_AFInfo_Buf
    Db_Xferred = Db_Xferred + SIZE(Db_AFInfo_Buf)
  ENDIF
  IF(ALLOCATED(Int_AFInfo_Buf)) THEN
    IF ( .NOT. OnlySize ) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_AFInfo_Buf)-1 ) = Int_AFInfo_Buf
    Int_Xferred = Int_Xferred + SIZE(Int_AFInfo_Buf)
  ENDIF
  IF( ALLOCATED(Re_AFInfo_Buf) )  DEALLOCATE(Re_AFInfo_Buf)
  IF( ALLOCATED(Db_AFInfo_Buf) )  DEALLOCATE(Db_AFInfo_Buf)
  IF( ALLOCATED(Int_AFInfo_Buf) ) DEALLOCATE(Int_AFInfo_Buf)
ENDDO
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%NumAF )
  Int_Xferred   = Int_Xferred   + 1
 END SUBROUTINE BEM_PackInitInput

 SUBROUTINE BEM_UnPackInitInput( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(BEM_initinputtype), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
  REAL(ReKi),    ALLOCATABLE :: Re_AFInfo_Buf(:)
  REAL(DbKi),    ALLOCATABLE :: Db_AFInfo_Buf(:)
  INTEGER(IntKi),    ALLOCATABLE :: Int_AFInfo_Buf(:)
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  OutData%DT = DbKiBuf ( Db_Xferred )
  Db_Xferred   = Db_Xferred   + 1
  IF ( ALLOCATED(OutData%chord) ) THEN
  ALLOCATE(mask2(SIZE(OutData%chord,1),SIZE(OutData%chord,2))); mask2 = .TRUE.
    OutData%chord = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%chord))-1 ),mask2,OutData%chord)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%chord)
  ENDIF
  OutData%numBlades = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%airDens = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%kinVisc = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%skewWakeMod = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%numBladeNodes = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%numReIterations = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%maxIndIterations = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  IF ( ALLOCATED(OutData%AFindx) ) THEN
  ALLOCATE(mask1(SIZE(OutData%AFindx,1))); mask1 = .TRUE.
    OutData%AFindx = UNPACK(IntKiBuf( Int_Xferred:Re_Xferred+(SIZE(OutData%AFindx))-1 ),mask1,OutData%AFindx)
  DEALLOCATE(mask1)
    Int_Xferred   = Int_Xferred   + SIZE(OutData%AFindx)
  ENDIF
  IF ( ALLOCATED(OutData%zHub) ) THEN
  ALLOCATE(mask1(SIZE(OutData%zHub,1))); mask1 = .TRUE.
    OutData%zHub = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%zHub))-1 ),mask1,OutData%zHub)
  DEALLOCATE(mask1)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%zHub)
  ENDIF
  IF ( ALLOCATED(OutData%zLocal) ) THEN
  ALLOCATE(mask2(SIZE(OutData%zLocal,1),SIZE(OutData%zLocal,2))); mask2 = .TRUE.
    OutData%zLocal = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%zLocal))-1 ),mask2,OutData%zLocal)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%zLocal)
  ENDIF
  IF ( ALLOCATED(OutData%zTip) ) THEN
  ALLOCATE(mask1(SIZE(OutData%zTip,1))); mask1 = .TRUE.
    OutData%zTip = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%zTip))-1 ),mask1,OutData%zTip)
  DEALLOCATE(mask1)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%zTip)
  ENDIF
DO i1 = LBOUND(OutData%AFInfo,1), UBOUND(OutData%AFInfo,1)
 ! first call AFI_Packafinfotype to get correctly sized buffers for unpacking
  CALL AFI_Packafinfotype( Re_AFInfo_Buf, Db_AFInfo_Buf, Int_AFInfo_Buf, OutData%AFInfo(i1), ErrStat, ErrMsg, .TRUE. ) ! AFInfo 
  IF(ALLOCATED(Re_AFInfo_Buf)) THEN
    Re_AFInfo_Buf = ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_AFInfo_Buf)-1 )
    Re_Xferred = Re_Xferred + SIZE(Re_AFInfo_Buf)
  ENDIF
  IF(ALLOCATED(Db_AFInfo_Buf)) THEN
    Db_AFInfo_Buf = DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_AFInfo_Buf)-1 )
    Db_Xferred = Db_Xferred + SIZE(Db_AFInfo_Buf)
  ENDIF
  IF(ALLOCATED(Int_AFInfo_Buf)) THEN
    Int_AFInfo_Buf = IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_AFInfo_Buf)-1 )
    Int_Xferred = Int_Xferred + SIZE(Int_AFInfo_Buf)
  ENDIF
  CALL AFI_UnPackafinfotype( Re_AFInfo_Buf, Db_AFInfo_Buf, Int_AFInfo_Buf, OutData%AFInfo(i1), ErrStat, ErrMsg ) ! AFInfo 
ENDDO
  OutData%NumAF = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE BEM_UnPackInitInput

 SUBROUTINE BEM_CopyInitOutput( SrcInitOutputData, DstInitOutputData, CtrlCode, ErrStat, ErrMsg )
   TYPE(BEM_initoutputtype), INTENT(INOUT) :: SrcInitOutputData
   TYPE(BEM_initoutputtype), INTENT(INOUT) :: DstInitOutputData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5,j,k
   INTEGER(IntKi)                 :: i1_l,i2_l,i3_l,i4_l,i5_l  ! lower bounds for an array dimension
   INTEGER(IntKi)                 :: i1_u,i2_u,i3_u,i4_u,i5_u  ! upper bounds for an array dimension
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
      CALL NWTC_Library_Copyprogdesc( SrcInitOutputData%Version, DstInitOutputData%Version, CtrlCode, ErrStat, ErrMsg )
 END SUBROUTINE BEM_CopyInitOutput

 SUBROUTINE BEM_DestroyInitOutput( InitOutputData, ErrStat, ErrMsg )
  TYPE(BEM_initoutputtype), INTENT(INOUT) :: InitOutputData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
  CALL NWTC_Library_Destroyprogdesc( InitOutputData%Version, ErrStat, ErrMsg )
 END SUBROUTINE BEM_DestroyInitOutput

 SUBROUTINE BEM_PackInitOutput( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(BEM_initoutputtype),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  REAL(ReKi),     ALLOCATABLE :: Re_Version_Buf(:)
  REAL(DbKi),     ALLOCATABLE :: Db_Version_Buf(:)
  INTEGER(IntKi), ALLOCATABLE :: Int_Version_Buf(:)
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  CALL NWTC_Library_Packprogdesc( Re_Version_Buf, Db_Version_Buf, Int_Version_Buf, InData%Version, ErrStat, ErrMsg, .TRUE. ) ! Version 
  IF(ALLOCATED(Re_Version_Buf)) Re_BufSz  = Re_BufSz  + SIZE( Re_Version_Buf  ) ! Version
  IF(ALLOCATED(Db_Version_Buf)) Db_BufSz  = Db_BufSz  + SIZE( Db_Version_Buf  ) ! Version
  IF(ALLOCATED(Int_Version_Buf))Int_BufSz = Int_BufSz + SIZE( Int_Version_Buf ) ! Version
  IF(ALLOCATED(Re_Version_Buf))  DEALLOCATE(Re_Version_Buf)
  IF(ALLOCATED(Db_Version_Buf))  DEALLOCATE(Db_Version_Buf)
  IF(ALLOCATED(Int_Version_Buf)) DEALLOCATE(Int_Version_Buf)
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  CALL NWTC_Library_Packprogdesc( Re_Version_Buf, Db_Version_Buf, Int_Version_Buf, InData%Version, ErrStat, ErrMsg, OnlySize ) ! Version 
  IF(ALLOCATED(Re_Version_Buf)) THEN
    IF ( .NOT. OnlySize ) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_Version_Buf)-1 ) = Re_Version_Buf
    Re_Xferred = Re_Xferred + SIZE(Re_Version_Buf)
  ENDIF
  IF(ALLOCATED(Db_Version_Buf)) THEN
    IF ( .NOT. OnlySize ) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_Version_Buf)-1 ) = Db_Version_Buf
    Db_Xferred = Db_Xferred + SIZE(Db_Version_Buf)
  ENDIF
  IF(ALLOCATED(Int_Version_Buf)) THEN
    IF ( .NOT. OnlySize ) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_Version_Buf)-1 ) = Int_Version_Buf
    Int_Xferred = Int_Xferred + SIZE(Int_Version_Buf)
  ENDIF
  IF( ALLOCATED(Re_Version_Buf) )  DEALLOCATE(Re_Version_Buf)
  IF( ALLOCATED(Db_Version_Buf) )  DEALLOCATE(Db_Version_Buf)
  IF( ALLOCATED(Int_Version_Buf) ) DEALLOCATE(Int_Version_Buf)
 END SUBROUTINE BEM_PackInitOutput

 SUBROUTINE BEM_UnPackInitOutput( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(BEM_initoutputtype), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
  REAL(ReKi),    ALLOCATABLE :: Re_Version_Buf(:)
  REAL(DbKi),    ALLOCATABLE :: Db_Version_Buf(:)
  INTEGER(IntKi),    ALLOCATABLE :: Int_Version_Buf(:)
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
 ! first call NWTC_Library_Packprogdesc to get correctly sized buffers for unpacking
  CALL NWTC_Library_Packprogdesc( Re_Version_Buf, Db_Version_Buf, Int_Version_Buf, OutData%Version, ErrStat, ErrMsg, .TRUE. ) ! Version 
  IF(ALLOCATED(Re_Version_Buf)) THEN
    Re_Version_Buf = ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_Version_Buf)-1 )
    Re_Xferred = Re_Xferred + SIZE(Re_Version_Buf)
  ENDIF
  IF(ALLOCATED(Db_Version_Buf)) THEN
    Db_Version_Buf = DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_Version_Buf)-1 )
    Db_Xferred = Db_Xferred + SIZE(Db_Version_Buf)
  ENDIF
  IF(ALLOCATED(Int_Version_Buf)) THEN
    Int_Version_Buf = IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_Version_Buf)-1 )
    Int_Xferred = Int_Xferred + SIZE(Int_Version_Buf)
  ENDIF
  CALL NWTC_Library_UnPackprogdesc( Re_Version_Buf, Db_Version_Buf, Int_Version_Buf, OutData%Version, ErrStat, ErrMsg ) ! Version 
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE BEM_UnPackInitOutput

 SUBROUTINE BEM_CopyContState( SrcContStateData, DstContStateData, CtrlCode, ErrStat, ErrMsg )
   TYPE(BEM_continuousstatetype), INTENT(INOUT) :: SrcContStateData
   TYPE(BEM_continuousstatetype), INTENT(INOUT) :: DstContStateData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5,j,k
   INTEGER(IntKi)                 :: i1_l,i2_l,i3_l,i4_l,i5_l  ! lower bounds for an array dimension
   INTEGER(IntKi)                 :: i1_u,i2_u,i3_u,i4_u,i5_u  ! upper bounds for an array dimension
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
   DstContStateData%DummyContState = SrcContStateData%DummyContState
 END SUBROUTINE BEM_CopyContState

 SUBROUTINE BEM_DestroyContState( ContStateData, ErrStat, ErrMsg )
  TYPE(BEM_continuousstatetype), INTENT(INOUT) :: ContStateData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
 END SUBROUTINE BEM_DestroyContState

 SUBROUTINE BEM_PackContState( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(BEM_continuousstatetype),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  Re_BufSz   = Re_BufSz   + 1  ! DummyContState
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%DummyContState )
  Re_Xferred   = Re_Xferred   + 1
 END SUBROUTINE BEM_PackContState

 SUBROUTINE BEM_UnPackContState( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(BEM_continuousstatetype), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  OutData%DummyContState = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE BEM_UnPackContState

 SUBROUTINE BEM_CopyDiscState( SrcDiscStateData, DstDiscStateData, CtrlCode, ErrStat, ErrMsg )
   TYPE(BEM_discretestatetype), INTENT(INOUT) :: SrcDiscStateData
   TYPE(BEM_discretestatetype), INTENT(INOUT) :: DstDiscStateData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5,j,k
   INTEGER(IntKi)                 :: i1_l,i2_l,i3_l,i4_l,i5_l  ! lower bounds for an array dimension
   INTEGER(IntKi)                 :: i1_u,i2_u,i3_u,i4_u,i5_u  ! upper bounds for an array dimension
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
   DstDiscStateData%DummyDiscState = SrcDiscStateData%DummyDiscState
 END SUBROUTINE BEM_CopyDiscState

 SUBROUTINE BEM_DestroyDiscState( DiscStateData, ErrStat, ErrMsg )
  TYPE(BEM_discretestatetype), INTENT(INOUT) :: DiscStateData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
 END SUBROUTINE BEM_DestroyDiscState

 SUBROUTINE BEM_PackDiscState( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(BEM_discretestatetype),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  Re_BufSz   = Re_BufSz   + 1  ! DummyDiscState
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%DummyDiscState )
  Re_Xferred   = Re_Xferred   + 1
 END SUBROUTINE BEM_PackDiscState

 SUBROUTINE BEM_UnPackDiscState( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(BEM_discretestatetype), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  OutData%DummyDiscState = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE BEM_UnPackDiscState

 SUBROUTINE BEM_CopyConstrState( SrcConstrStateData, DstConstrStateData, CtrlCode, ErrStat, ErrMsg )
   TYPE(BEM_constraintstatetype), INTENT(INOUT) :: SrcConstrStateData
   TYPE(BEM_constraintstatetype), INTENT(INOUT) :: DstConstrStateData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5,j,k
   INTEGER(IntKi)                 :: i1_l,i2_l,i3_l,i4_l,i5_l  ! lower bounds for an array dimension
   INTEGER(IntKi)                 :: i1_u,i2_u,i3_u,i4_u,i5_u  ! upper bounds for an array dimension
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
IF (ALLOCATED(SrcConstrStateData%phi)) THEN
   i1_l = LBOUND(SrcConstrStateData%phi,1)
   i1_u = UBOUND(SrcConstrStateData%phi,1)
   i2_l = LBOUND(SrcConstrStateData%phi,2)
   i2_u = UBOUND(SrcConstrStateData%phi,2)
   IF (.NOT. ALLOCATED(DstConstrStateData%phi)) THEN 
      ALLOCATE(DstConstrStateData%phi(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'BEM_CopyConstrState: Error allocating DstConstrStateData%phi.'
         RETURN
      END IF
   END IF
   DstConstrStateData%phi = SrcConstrStateData%phi
ENDIF
 END SUBROUTINE BEM_CopyConstrState

 SUBROUTINE BEM_DestroyConstrState( ConstrStateData, ErrStat, ErrMsg )
  TYPE(BEM_constraintstatetype), INTENT(INOUT) :: ConstrStateData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
IF (ALLOCATED(ConstrStateData%phi)) THEN
   DEALLOCATE(ConstrStateData%phi)
ENDIF
 END SUBROUTINE BEM_DestroyConstrState

 SUBROUTINE BEM_PackConstrState( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(BEM_constraintstatetype),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  Re_BufSz    = Re_BufSz    + SIZE( InData%phi )  ! phi 
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  IF ( ALLOCATED(InData%phi) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%phi))-1 ) =  PACK(InData%phi ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%phi)
  ENDIF
 END SUBROUTINE BEM_PackConstrState

 SUBROUTINE BEM_UnPackConstrState( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(BEM_constraintstatetype), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  IF ( ALLOCATED(OutData%phi) ) THEN
  ALLOCATE(mask2(SIZE(OutData%phi,1),SIZE(OutData%phi,2))); mask2 = .TRUE.
    OutData%phi = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%phi))-1 ),mask2,OutData%phi)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%phi)
  ENDIF
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE BEM_UnPackConstrState

 SUBROUTINE BEM_CopyOtherState( SrcOtherStateData, DstOtherStateData, CtrlCode, ErrStat, ErrMsg )
   TYPE(BEM_otherstatetype), INTENT(INOUT) :: SrcOtherStateData
   TYPE(BEM_otherstatetype), INTENT(INOUT) :: DstOtherStateData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5,j,k
   INTEGER(IntKi)                 :: i1_l,i2_l,i3_l,i4_l,i5_l  ! lower bounds for an array dimension
   INTEGER(IntKi)                 :: i1_u,i2_u,i3_u,i4_u,i5_u  ! upper bounds for an array dimension
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
   DstOtherStateData%DummyOtherState = SrcOtherStateData%DummyOtherState
 END SUBROUTINE BEM_CopyOtherState

 SUBROUTINE BEM_DestroyOtherState( OtherStateData, ErrStat, ErrMsg )
  TYPE(BEM_otherstatetype), INTENT(INOUT) :: OtherStateData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
 END SUBROUTINE BEM_DestroyOtherState

 SUBROUTINE BEM_PackOtherState( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(BEM_otherstatetype),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  Re_BufSz   = Re_BufSz   + 1  ! DummyOtherState
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%DummyOtherState )
  Re_Xferred   = Re_Xferred   + 1
 END SUBROUTINE BEM_PackOtherState

 SUBROUTINE BEM_UnPackOtherState( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(BEM_otherstatetype), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  OutData%DummyOtherState = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE BEM_UnPackOtherState

 SUBROUTINE BEM_CopyParam( SrcParamData, DstParamData, CtrlCode, ErrStat, ErrMsg )
   TYPE(BEM_parametertype), INTENT(INOUT) :: SrcParamData
   TYPE(BEM_parametertype), INTENT(INOUT) :: DstParamData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5,j,k
   INTEGER(IntKi)                 :: i1_l,i2_l,i3_l,i4_l,i5_l  ! lower bounds for an array dimension
   INTEGER(IntKi)                 :: i1_u,i2_u,i3_u,i4_u,i5_u  ! upper bounds for an array dimension
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
   DstParamData%DT = SrcParamData%DT
IF (ALLOCATED(SrcParamData%chord)) THEN
   i1_l = LBOUND(SrcParamData%chord,1)
   i1_u = UBOUND(SrcParamData%chord,1)
   i2_l = LBOUND(SrcParamData%chord,2)
   i2_u = UBOUND(SrcParamData%chord,2)
   IF (.NOT. ALLOCATED(DstParamData%chord)) THEN 
      ALLOCATE(DstParamData%chord(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'BEM_CopyParam: Error allocating DstParamData%chord.'
         RETURN
      END IF
   END IF
   DstParamData%chord = SrcParamData%chord
ENDIF
   DstParamData%numBlades = SrcParamData%numBlades
   DstParamData%airDens = SrcParamData%airDens
   DstParamData%kinVisc = SrcParamData%kinVisc
   DstParamData%skewWakeMod = SrcParamData%skewWakeMod
   DstParamData%useTipLoss = SrcParamData%useTipLoss
   DstParamData%useHubLoss = SrcParamData%useHubLoss
   DstParamData%useTanInd = SrcParamData%useTanInd
   DstParamData%useAIDrag = SrcParamData%useAIDrag
   DstParamData%useTIDrag = SrcParamData%useTIDrag
   DstParamData%numBladeNodes = SrcParamData%numBladeNodes
   DstParamData%numReIterations = SrcParamData%numReIterations
   DstParamData%maxIndIterations = SrcParamData%maxIndIterations
IF (ALLOCATED(SrcParamData%AFindx)) THEN
   i1_l = LBOUND(SrcParamData%AFindx,1)
   i1_u = UBOUND(SrcParamData%AFindx,1)
   IF (.NOT. ALLOCATED(DstParamData%AFindx)) THEN 
      ALLOCATE(DstParamData%AFindx(i1_l:i1_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'BEM_CopyParam: Error allocating DstParamData%AFindx.'
         RETURN
      END IF
   END IF
   DstParamData%AFindx = SrcParamData%AFindx
ENDIF
IF (ALLOCATED(SrcParamData%tipLossConst)) THEN
   i1_l = LBOUND(SrcParamData%tipLossConst,1)
   i1_u = UBOUND(SrcParamData%tipLossConst,1)
   i2_l = LBOUND(SrcParamData%tipLossConst,2)
   i2_u = UBOUND(SrcParamData%tipLossConst,2)
   IF (.NOT. ALLOCATED(DstParamData%tipLossConst)) THEN 
      ALLOCATE(DstParamData%tipLossConst(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'BEM_CopyParam: Error allocating DstParamData%tipLossConst.'
         RETURN
      END IF
   END IF
   DstParamData%tipLossConst = SrcParamData%tipLossConst
ENDIF
IF (ALLOCATED(SrcParamData%hubLossConst)) THEN
   i1_l = LBOUND(SrcParamData%hubLossConst,1)
   i1_u = UBOUND(SrcParamData%hubLossConst,1)
   i2_l = LBOUND(SrcParamData%hubLossConst,2)
   i2_u = UBOUND(SrcParamData%hubLossConst,2)
   IF (.NOT. ALLOCATED(DstParamData%hubLossConst)) THEN 
      ALLOCATE(DstParamData%hubLossConst(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'BEM_CopyParam: Error allocating DstParamData%hubLossConst.'
         RETURN
      END IF
   END IF
   DstParamData%hubLossConst = SrcParamData%hubLossConst
ENDIF
IF (ALLOCATED(SrcParamData%AFInfo)) THEN
   i1_l = LBOUND(SrcParamData%AFInfo,1)
   i1_u = UBOUND(SrcParamData%AFInfo,1)
   IF (.NOT. ALLOCATED(DstParamData%AFInfo)) THEN 
      ALLOCATE(DstParamData%AFInfo(i1_l:i1_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'BEM_CopyParam: Error allocating DstParamData%AFInfo.'
         RETURN
      END IF
   END IF
   DO i1 = LBOUND(SrcParamData%AFInfo,1), UBOUND(SrcParamData%AFInfo,1)
      CALL AFI_Copyafinfotype( SrcParamData%AFInfo(i1), DstParamData%AFInfo(i1), CtrlCode, ErrStat, ErrMsg )
   ENDDO
ENDIF
 END SUBROUTINE BEM_CopyParam

 SUBROUTINE BEM_DestroyParam( ParamData, ErrStat, ErrMsg )
  TYPE(BEM_parametertype), INTENT(INOUT) :: ParamData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
IF (ALLOCATED(ParamData%chord)) THEN
   DEALLOCATE(ParamData%chord)
ENDIF
IF (ALLOCATED(ParamData%AFindx)) THEN
   DEALLOCATE(ParamData%AFindx)
ENDIF
IF (ALLOCATED(ParamData%tipLossConst)) THEN
   DEALLOCATE(ParamData%tipLossConst)
ENDIF
IF (ALLOCATED(ParamData%hubLossConst)) THEN
   DEALLOCATE(ParamData%hubLossConst)
ENDIF
IF (ALLOCATED(ParamData%AFInfo)) THEN
DO i1 = LBOUND(ParamData%AFInfo,1), UBOUND(ParamData%AFInfo,1)
  CALL AFI_Destroyafinfotype( ParamData%AFInfo(i1), ErrStat, ErrMsg )
ENDDO
   DEALLOCATE(ParamData%AFInfo)
ENDIF
 END SUBROUTINE BEM_DestroyParam

 SUBROUTINE BEM_PackParam( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(BEM_parametertype),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  REAL(ReKi),     ALLOCATABLE :: Re_AFInfo_Buf(:)
  REAL(DbKi),     ALLOCATABLE :: Db_AFInfo_Buf(:)
  INTEGER(IntKi), ALLOCATABLE :: Int_AFInfo_Buf(:)
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  Db_BufSz   = Db_BufSz   + 1  ! DT
  Re_BufSz    = Re_BufSz    + SIZE( InData%chord )  ! chord 
  Int_BufSz  = Int_BufSz  + 1  ! numBlades
  Re_BufSz   = Re_BufSz   + 1  ! airDens
  Re_BufSz   = Re_BufSz   + 1  ! kinVisc
  Int_BufSz  = Int_BufSz  + 1  ! skewWakeMod
  Int_BufSz  = Int_BufSz  + 1  ! numBladeNodes
  Int_BufSz  = Int_BufSz  + 1  ! numReIterations
  Int_BufSz  = Int_BufSz  + 1  ! maxIndIterations
  Int_BufSz   = Int_BufSz   + SIZE( InData%AFindx )  ! AFindx 
  Re_BufSz    = Re_BufSz    + SIZE( InData%tipLossConst )  ! tipLossConst 
  Re_BufSz    = Re_BufSz    + SIZE( InData%hubLossConst )  ! hubLossConst 
DO i1 = LBOUND(InData%AFInfo,1), UBOUND(InData%AFInfo,1)
  CALL AFI_Packafinfotype( Re_AFInfo_Buf, Db_AFInfo_Buf, Int_AFInfo_Buf, InData%AFInfo(i1), ErrStat, ErrMsg, .TRUE. ) ! AFInfo 
  IF(ALLOCATED(Re_AFInfo_Buf)) Re_BufSz  = Re_BufSz  + SIZE( Re_AFInfo_Buf  ) ! AFInfo
  IF(ALLOCATED(Db_AFInfo_Buf)) Db_BufSz  = Db_BufSz  + SIZE( Db_AFInfo_Buf  ) ! AFInfo
  IF(ALLOCATED(Int_AFInfo_Buf))Int_BufSz = Int_BufSz + SIZE( Int_AFInfo_Buf ) ! AFInfo
  IF(ALLOCATED(Re_AFInfo_Buf))  DEALLOCATE(Re_AFInfo_Buf)
  IF(ALLOCATED(Db_AFInfo_Buf))  DEALLOCATE(Db_AFInfo_Buf)
  IF(ALLOCATED(Int_AFInfo_Buf)) DEALLOCATE(Int_AFInfo_Buf)
ENDDO
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  IF ( .NOT. OnlySize ) DbKiBuf ( Db_Xferred:Db_Xferred+(1)-1 ) =  (InData%DT )
  Db_Xferred   = Db_Xferred   + 1
  IF ( ALLOCATED(InData%chord) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%chord))-1 ) =  PACK(InData%chord ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%chord)
  ENDIF
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%numBlades )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%airDens )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%kinVisc )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%skewWakeMod )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%numBladeNodes )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%numReIterations )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%maxIndIterations )
  Int_Xferred   = Int_Xferred   + 1
  IF ( ALLOCATED(InData%AFindx) ) THEN
    IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(SIZE(InData%AFindx))-1 ) = PACK(InData%AFindx ,.TRUE.)
    Int_Xferred   = Int_Xferred   + SIZE(InData%AFindx)
  ENDIF
  IF ( ALLOCATED(InData%tipLossConst) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%tipLossConst))-1 ) =  PACK(InData%tipLossConst ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%tipLossConst)
  ENDIF
  IF ( ALLOCATED(InData%hubLossConst) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%hubLossConst))-1 ) =  PACK(InData%hubLossConst ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%hubLossConst)
  ENDIF
DO i1 = LBOUND(InData%AFInfo,1), UBOUND(InData%AFInfo,1)
  CALL AFI_Packafinfotype( Re_AFInfo_Buf, Db_AFInfo_Buf, Int_AFInfo_Buf, InData%AFInfo(i1), ErrStat, ErrMsg, OnlySize ) ! AFInfo 
  IF(ALLOCATED(Re_AFInfo_Buf)) THEN
    IF ( .NOT. OnlySize ) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_AFInfo_Buf)-1 ) = Re_AFInfo_Buf
    Re_Xferred = Re_Xferred + SIZE(Re_AFInfo_Buf)
  ENDIF
  IF(ALLOCATED(Db_AFInfo_Buf)) THEN
    IF ( .NOT. OnlySize ) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_AFInfo_Buf)-1 ) = Db_AFInfo_Buf
    Db_Xferred = Db_Xferred + SIZE(Db_AFInfo_Buf)
  ENDIF
  IF(ALLOCATED(Int_AFInfo_Buf)) THEN
    IF ( .NOT. OnlySize ) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_AFInfo_Buf)-1 ) = Int_AFInfo_Buf
    Int_Xferred = Int_Xferred + SIZE(Int_AFInfo_Buf)
  ENDIF
  IF( ALLOCATED(Re_AFInfo_Buf) )  DEALLOCATE(Re_AFInfo_Buf)
  IF( ALLOCATED(Db_AFInfo_Buf) )  DEALLOCATE(Db_AFInfo_Buf)
  IF( ALLOCATED(Int_AFInfo_Buf) ) DEALLOCATE(Int_AFInfo_Buf)
ENDDO
 END SUBROUTINE BEM_PackParam

 SUBROUTINE BEM_UnPackParam( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(BEM_parametertype), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
  REAL(ReKi),    ALLOCATABLE :: Re_AFInfo_Buf(:)
  REAL(DbKi),    ALLOCATABLE :: Db_AFInfo_Buf(:)
  INTEGER(IntKi),    ALLOCATABLE :: Int_AFInfo_Buf(:)
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  OutData%DT = DbKiBuf ( Db_Xferred )
  Db_Xferred   = Db_Xferred   + 1
  IF ( ALLOCATED(OutData%chord) ) THEN
  ALLOCATE(mask2(SIZE(OutData%chord,1),SIZE(OutData%chord,2))); mask2 = .TRUE.
    OutData%chord = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%chord))-1 ),mask2,OutData%chord)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%chord)
  ENDIF
  OutData%numBlades = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%airDens = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%kinVisc = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%skewWakeMod = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%numBladeNodes = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%numReIterations = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%maxIndIterations = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  IF ( ALLOCATED(OutData%AFindx) ) THEN
  ALLOCATE(mask1(SIZE(OutData%AFindx,1))); mask1 = .TRUE.
    OutData%AFindx = UNPACK(IntKiBuf( Int_Xferred:Re_Xferred+(SIZE(OutData%AFindx))-1 ),mask1,OutData%AFindx)
  DEALLOCATE(mask1)
    Int_Xferred   = Int_Xferred   + SIZE(OutData%AFindx)
  ENDIF
  IF ( ALLOCATED(OutData%tipLossConst) ) THEN
  ALLOCATE(mask2(SIZE(OutData%tipLossConst,1),SIZE(OutData%tipLossConst,2))); mask2 = .TRUE.
    OutData%tipLossConst = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%tipLossConst))-1 ),mask2,OutData%tipLossConst)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%tipLossConst)
  ENDIF
  IF ( ALLOCATED(OutData%hubLossConst) ) THEN
  ALLOCATE(mask2(SIZE(OutData%hubLossConst,1),SIZE(OutData%hubLossConst,2))); mask2 = .TRUE.
    OutData%hubLossConst = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%hubLossConst))-1 ),mask2,OutData%hubLossConst)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%hubLossConst)
  ENDIF
DO i1 = LBOUND(OutData%AFInfo,1), UBOUND(OutData%AFInfo,1)
 ! first call AFI_Packafinfotype to get correctly sized buffers for unpacking
  CALL AFI_Packafinfotype( Re_AFInfo_Buf, Db_AFInfo_Buf, Int_AFInfo_Buf, OutData%AFInfo(i1), ErrStat, ErrMsg, .TRUE. ) ! AFInfo 
  IF(ALLOCATED(Re_AFInfo_Buf)) THEN
    Re_AFInfo_Buf = ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_AFInfo_Buf)-1 )
    Re_Xferred = Re_Xferred + SIZE(Re_AFInfo_Buf)
  ENDIF
  IF(ALLOCATED(Db_AFInfo_Buf)) THEN
    Db_AFInfo_Buf = DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_AFInfo_Buf)-1 )
    Db_Xferred = Db_Xferred + SIZE(Db_AFInfo_Buf)
  ENDIF
  IF(ALLOCATED(Int_AFInfo_Buf)) THEN
    Int_AFInfo_Buf = IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_AFInfo_Buf)-1 )
    Int_Xferred = Int_Xferred + SIZE(Int_AFInfo_Buf)
  ENDIF
  CALL AFI_UnPackafinfotype( Re_AFInfo_Buf, Db_AFInfo_Buf, Int_AFInfo_Buf, OutData%AFInfo(i1), ErrStat, ErrMsg ) ! AFInfo 
ENDDO
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE BEM_UnPackParam

 SUBROUTINE BEM_CopyInput( SrcInputData, DstInputData, CtrlCode, ErrStat, ErrMsg )
   TYPE(BEM_inputtype), INTENT(INOUT) :: SrcInputData
   TYPE(BEM_inputtype), INTENT(INOUT) :: DstInputData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5,j,k
   INTEGER(IntKi)                 :: i1_l,i2_l,i3_l,i4_l,i5_l  ! lower bounds for an array dimension
   INTEGER(IntKi)                 :: i1_u,i2_u,i3_u,i4_u,i5_u  ! upper bounds for an array dimension
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
IF (ALLOCATED(SrcInputData%theta)) THEN
   i1_l = LBOUND(SrcInputData%theta,1)
   i1_u = UBOUND(SrcInputData%theta,1)
   i2_l = LBOUND(SrcInputData%theta,2)
   i2_u = UBOUND(SrcInputData%theta,2)
   IF (.NOT. ALLOCATED(DstInputData%theta)) THEN 
      ALLOCATE(DstInputData%theta(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'BEM_CopyInput: Error allocating DstInputData%theta.'
         RETURN
      END IF
   END IF
   DstInputData%theta = SrcInputData%theta
ENDIF
   DstInputData%gamma = SrcInputData%gamma
IF (ALLOCATED(SrcInputData%psi)) THEN
   i1_l = LBOUND(SrcInputData%psi,1)
   i1_u = UBOUND(SrcInputData%psi,1)
   IF (.NOT. ALLOCATED(DstInputData%psi)) THEN 
      ALLOCATE(DstInputData%psi(i1_l:i1_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'BEM_CopyInput: Error allocating DstInputData%psi.'
         RETURN
      END IF
   END IF
   DstInputData%psi = SrcInputData%psi
ENDIF
   DstInputData%omega = SrcInputData%omega
IF (ALLOCATED(SrcInputData%Vx)) THEN
   i1_l = LBOUND(SrcInputData%Vx,1)
   i1_u = UBOUND(SrcInputData%Vx,1)
   i2_l = LBOUND(SrcInputData%Vx,2)
   i2_u = UBOUND(SrcInputData%Vx,2)
   IF (.NOT. ALLOCATED(DstInputData%Vx)) THEN 
      ALLOCATE(DstInputData%Vx(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'BEM_CopyInput: Error allocating DstInputData%Vx.'
         RETURN
      END IF
   END IF
   DstInputData%Vx = SrcInputData%Vx
ENDIF
IF (ALLOCATED(SrcInputData%Vy)) THEN
   i1_l = LBOUND(SrcInputData%Vy,1)
   i1_u = UBOUND(SrcInputData%Vy,1)
   i2_l = LBOUND(SrcInputData%Vy,2)
   i2_u = UBOUND(SrcInputData%Vy,2)
   IF (.NOT. ALLOCATED(DstInputData%Vy)) THEN 
      ALLOCATE(DstInputData%Vy(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'BEM_CopyInput: Error allocating DstInputData%Vy.'
         RETURN
      END IF
   END IF
   DstInputData%Vy = SrcInputData%Vy
ENDIF
   DstInputData%lambda = SrcInputData%lambda
IF (ALLOCATED(SrcInputData%rTip)) THEN
   i1_l = LBOUND(SrcInputData%rTip,1)
   i1_u = UBOUND(SrcInputData%rTip,1)
   IF (.NOT. ALLOCATED(DstInputData%rTip)) THEN 
      ALLOCATE(DstInputData%rTip(i1_l:i1_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'BEM_CopyInput: Error allocating DstInputData%rTip.'
         RETURN
      END IF
   END IF
   DstInputData%rTip = SrcInputData%rTip
ENDIF
IF (ALLOCATED(SrcInputData%rLocal)) THEN
   i1_l = LBOUND(SrcInputData%rLocal,1)
   i1_u = UBOUND(SrcInputData%rLocal,1)
   i2_l = LBOUND(SrcInputData%rLocal,2)
   i2_u = UBOUND(SrcInputData%rLocal,2)
   IF (.NOT. ALLOCATED(DstInputData%rLocal)) THEN 
      ALLOCATE(DstInputData%rLocal(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'BEM_CopyInput: Error allocating DstInputData%rLocal.'
         RETURN
      END IF
   END IF
   DstInputData%rLocal = SrcInputData%rLocal
ENDIF
 END SUBROUTINE BEM_CopyInput

 SUBROUTINE BEM_DestroyInput( InputData, ErrStat, ErrMsg )
  TYPE(BEM_inputtype), INTENT(INOUT) :: InputData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
IF (ALLOCATED(InputData%theta)) THEN
   DEALLOCATE(InputData%theta)
ENDIF
IF (ALLOCATED(InputData%psi)) THEN
   DEALLOCATE(InputData%psi)
ENDIF
IF (ALLOCATED(InputData%Vx)) THEN
   DEALLOCATE(InputData%Vx)
ENDIF
IF (ALLOCATED(InputData%Vy)) THEN
   DEALLOCATE(InputData%Vy)
ENDIF
IF (ALLOCATED(InputData%rTip)) THEN
   DEALLOCATE(InputData%rTip)
ENDIF
IF (ALLOCATED(InputData%rLocal)) THEN
   DEALLOCATE(InputData%rLocal)
ENDIF
 END SUBROUTINE BEM_DestroyInput

 SUBROUTINE BEM_PackInput( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(BEM_inputtype),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  Re_BufSz    = Re_BufSz    + SIZE( InData%theta )  ! theta 
  Re_BufSz   = Re_BufSz   + 1  ! gamma
  Re_BufSz    = Re_BufSz    + SIZE( InData%psi )  ! psi 
  Re_BufSz   = Re_BufSz   + 1  ! omega
  Re_BufSz    = Re_BufSz    + SIZE( InData%Vx )  ! Vx 
  Re_BufSz    = Re_BufSz    + SIZE( InData%Vy )  ! Vy 
  Re_BufSz   = Re_BufSz   + 1  ! lambda
  Re_BufSz    = Re_BufSz    + SIZE( InData%rTip )  ! rTip 
  Re_BufSz    = Re_BufSz    + SIZE( InData%rLocal )  ! rLocal 
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  IF ( ALLOCATED(InData%theta) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%theta))-1 ) =  PACK(InData%theta ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%theta)
  ENDIF
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%gamma )
  Re_Xferred   = Re_Xferred   + 1
  IF ( ALLOCATED(InData%psi) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%psi))-1 ) =  PACK(InData%psi ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%psi)
  ENDIF
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%omega )
  Re_Xferred   = Re_Xferred   + 1
  IF ( ALLOCATED(InData%Vx) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%Vx))-1 ) =  PACK(InData%Vx ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%Vx)
  ENDIF
  IF ( ALLOCATED(InData%Vy) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%Vy))-1 ) =  PACK(InData%Vy ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%Vy)
  ENDIF
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%lambda )
  Re_Xferred   = Re_Xferred   + 1
  IF ( ALLOCATED(InData%rTip) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%rTip))-1 ) =  PACK(InData%rTip ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%rTip)
  ENDIF
  IF ( ALLOCATED(InData%rLocal) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%rLocal))-1 ) =  PACK(InData%rLocal ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%rLocal)
  ENDIF
 END SUBROUTINE BEM_PackInput

 SUBROUTINE BEM_UnPackInput( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(BEM_inputtype), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  IF ( ALLOCATED(OutData%theta) ) THEN
  ALLOCATE(mask2(SIZE(OutData%theta,1),SIZE(OutData%theta,2))); mask2 = .TRUE.
    OutData%theta = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%theta))-1 ),mask2,OutData%theta)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%theta)
  ENDIF
  OutData%gamma = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  IF ( ALLOCATED(OutData%psi) ) THEN
  ALLOCATE(mask1(SIZE(OutData%psi,1))); mask1 = .TRUE.
    OutData%psi = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%psi))-1 ),mask1,OutData%psi)
  DEALLOCATE(mask1)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%psi)
  ENDIF
  OutData%omega = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  IF ( ALLOCATED(OutData%Vx) ) THEN
  ALLOCATE(mask2(SIZE(OutData%Vx,1),SIZE(OutData%Vx,2))); mask2 = .TRUE.
    OutData%Vx = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%Vx))-1 ),mask2,OutData%Vx)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%Vx)
  ENDIF
  IF ( ALLOCATED(OutData%Vy) ) THEN
  ALLOCATE(mask2(SIZE(OutData%Vy,1),SIZE(OutData%Vy,2))); mask2 = .TRUE.
    OutData%Vy = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%Vy))-1 ),mask2,OutData%Vy)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%Vy)
  ENDIF
  OutData%lambda = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  IF ( ALLOCATED(OutData%rTip) ) THEN
  ALLOCATE(mask1(SIZE(OutData%rTip,1))); mask1 = .TRUE.
    OutData%rTip = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%rTip))-1 ),mask1,OutData%rTip)
  DEALLOCATE(mask1)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%rTip)
  ENDIF
  IF ( ALLOCATED(OutData%rLocal) ) THEN
  ALLOCATE(mask2(SIZE(OutData%rLocal,1),SIZE(OutData%rLocal,2))); mask2 = .TRUE.
    OutData%rLocal = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%rLocal))-1 ),mask2,OutData%rLocal)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%rLocal)
  ENDIF
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE BEM_UnPackInput

 SUBROUTINE BEM_CopyOutput( SrcOutputData, DstOutputData, CtrlCode, ErrStat, ErrMsg )
   TYPE(BEM_outputtype), INTENT(INOUT) :: SrcOutputData
   TYPE(BEM_outputtype), INTENT(INOUT) :: DstOutputData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5,j,k
   INTEGER(IntKi)                 :: i1_l,i2_l,i3_l,i4_l,i5_l  ! lower bounds for an array dimension
   INTEGER(IntKi)                 :: i1_u,i2_u,i3_u,i4_u,i5_u  ! upper bounds for an array dimension
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
IF (ALLOCATED(SrcOutputData%inducedVel)) THEN
   i1_l = LBOUND(SrcOutputData%inducedVel,1)
   i1_u = UBOUND(SrcOutputData%inducedVel,1)
   i2_l = LBOUND(SrcOutputData%inducedVel,2)
   i2_u = UBOUND(SrcOutputData%inducedVel,2)
   IF (.NOT. ALLOCATED(DstOutputData%inducedVel)) THEN 
      ALLOCATE(DstOutputData%inducedVel(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'BEM_CopyOutput: Error allocating DstOutputData%inducedVel.'
         RETURN
      END IF
   END IF
   DstOutputData%inducedVel = SrcOutputData%inducedVel
ENDIF
IF (ALLOCATED(SrcOutputData%phi)) THEN
   i1_l = LBOUND(SrcOutputData%phi,1)
   i1_u = UBOUND(SrcOutputData%phi,1)
   i2_l = LBOUND(SrcOutputData%phi,2)
   i2_u = UBOUND(SrcOutputData%phi,2)
   IF (.NOT. ALLOCATED(DstOutputData%phi)) THEN 
      ALLOCATE(DstOutputData%phi(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat)
      IF (ErrStat /= 0) THEN 
         ErrStat = ErrID_Fatal 
         ErrMsg = 'BEM_CopyOutput: Error allocating DstOutputData%phi.'
         RETURN
      END IF
   END IF
   DstOutputData%phi = SrcOutputData%phi
ENDIF
 END SUBROUTINE BEM_CopyOutput

 SUBROUTINE BEM_DestroyOutput( OutputData, ErrStat, ErrMsg )
  TYPE(BEM_outputtype), INTENT(INOUT) :: OutputData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
IF (ALLOCATED(OutputData%inducedVel)) THEN
   DEALLOCATE(OutputData%inducedVel)
ENDIF
IF (ALLOCATED(OutputData%phi)) THEN
   DEALLOCATE(OutputData%phi)
ENDIF
 END SUBROUTINE BEM_DestroyOutput

 SUBROUTINE BEM_PackOutput( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(BEM_outputtype),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  Re_BufSz    = Re_BufSz    + SIZE( InData%inducedVel )  ! inducedVel 
  Re_BufSz    = Re_BufSz    + SIZE( InData%phi )  ! phi 
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  IF ( ALLOCATED(InData%inducedVel) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%inducedVel))-1 ) =  PACK(InData%inducedVel ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%inducedVel)
  ENDIF
  IF ( ALLOCATED(InData%phi) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%phi))-1 ) =  PACK(InData%phi ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%phi)
  ENDIF
 END SUBROUTINE BEM_PackOutput

 SUBROUTINE BEM_UnPackOutput( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(BEM_outputtype), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  IF ( ALLOCATED(OutData%inducedVel) ) THEN
  ALLOCATE(mask2(SIZE(OutData%inducedVel,1),SIZE(OutData%inducedVel,2))); mask2 = .TRUE.
    OutData%inducedVel = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%inducedVel))-1 ),mask2,OutData%inducedVel)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%inducedVel)
  ENDIF
  IF ( ALLOCATED(OutData%phi) ) THEN
  ALLOCATE(mask2(SIZE(OutData%phi,1),SIZE(OutData%phi,2))); mask2 = .TRUE.
    OutData%phi = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%phi))-1 ),mask2,OutData%phi)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%phi)
  ENDIF
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE BEM_UnPackOutput


 SUBROUTINE BEM_Input_ExtrapInterp(u, tin, u_out, tin_out, ErrStat, ErrMsg )
!
! This subroutine calculates a extrapolated (or interpolated) input u_out at time t_out, from previous/future time
! values of u (which has values associated with times in t).  Order of the interpolation is given by the size of u
!
!  expressions below based on either
!
!  f(t) = a
!  f(t) = a + b * t, or
!  f(t) = a + b * t + c * t**2
!
!  where a, b and c are determined as the solution to
!  f(t1) = u1, f(t2) = u2, f(t3) = u3  (as appropriate)
!
!..................................................................................................................................

 TYPE(BEM_inputtype), INTENT(INOUT)  :: u(:)      ! Inputs at t1 > t2 > t3
 REAL(DbKi),         INTENT(IN   )  :: tin(:)      ! Times associated with the inputs
 TYPE(BEM_inputtype), INTENT(INOUT)  :: u_out     ! Inputs at tin_out
 REAL(DbKi),         INTENT(IN   )  :: tin_out     ! time to be extrap/interp'd to
 INTEGER(IntKi),     INTENT(  OUT)  :: ErrStat   ! Error status of the operation
 CHARACTER(*),       INTENT(  OUT)  :: ErrMsg    ! Error message if ErrStat /= ErrID_None
   ! local variables
 REAL(DbKi) :: t(SIZE(tin))    ! Times associated with the inputs
 REAL(DbKi) :: t_out           ! Time to which to be extrap/interpd
 INTEGER(IntKi)                 :: order    ! order of polynomial fit (max 2)
 REAL(DbKi)                                 :: b0       ! temporary for extrapolation/interpolation
 REAL(DbKi)                                 :: c0       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:)        :: b1       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:)        :: c1       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:,:)      :: b2       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:,:)      :: c2       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:,:,:)    :: b3       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:,:,:)    :: c3       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:,:,:,:)  :: b4       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:,:,:,:)  :: c4       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:,:,:,:,:):: b5       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:,:,:,:,:):: c5       ! temporary for extrapolation/interpolation
 INTEGER                                    :: i01    ! dim1 level 0 counter variable for arrays of ddts
 INTEGER                                    :: i11    ! dim1 level 1 counter variable for arrays of ddts
 INTEGER                                    :: i21    ! dim1 level 2 counter variable for arrays of ddts
 INTEGER                                    :: i31    ! dim1 level 3 counter variable for arrays of ddts
 INTEGER                                    :: i41    ! dim1 level 4 counter variable for arrays of ddts
 INTEGER                                    :: i51    ! dim1 level 5 counter variable for arrays of ddts
 INTEGER                                    :: i61    ! dim1 level 6 counter variable for arrays of ddts
 INTEGER                                    :: i71    ! dim1 level 7 counter variable for arrays of ddts
 INTEGER                                    :: i81    ! dim1 level 8 counter variable for arrays of ddts
 INTEGER                                    :: i91    ! dim1 level 9 counter variable for arrays of ddts
 INTEGER                                    :: i02    ! dim2 level 0 counter variable for arrays of ddts
 INTEGER                                    :: i12    ! dim2 level 1 counter variable for arrays of ddts
 INTEGER                                    :: i22    ! dim2 level 2 counter variable for arrays of ddts
 INTEGER                                    :: i32    ! dim2 level 3 counter variable for arrays of ddts
 INTEGER                                    :: i42    ! dim2 level 4 counter variable for arrays of ddts
 INTEGER                                    :: i52    ! dim2 level 5 counter variable for arrays of ddts
 INTEGER                                    :: i62    ! dim2 level 6 counter variable for arrays of ddts
 INTEGER                                    :: i72    ! dim2 level 7 counter variable for arrays of ddts
 INTEGER                                    :: i82    ! dim2 level 8 counter variable for arrays of ddts
 INTEGER                                    :: i92    ! dim2 level 9 counter variable for arrays of ddts
 INTEGER                                    :: i03    ! dim3 level 0 counter variable for arrays of ddts
 INTEGER                                    :: i13    ! dim3 level 1 counter variable for arrays of ddts
 INTEGER                                    :: i23    ! dim3 level 2 counter variable for arrays of ddts
 INTEGER                                    :: i33    ! dim3 level 3 counter variable for arrays of ddts
 INTEGER                                    :: i43    ! dim3 level 4 counter variable for arrays of ddts
 INTEGER                                    :: i53    ! dim3 level 5 counter variable for arrays of ddts
 INTEGER                                    :: i63    ! dim3 level 6 counter variable for arrays of ddts
 INTEGER                                    :: i73    ! dim3 level 7 counter variable for arrays of ddts
 INTEGER                                    :: i83    ! dim3 level 8 counter variable for arrays of ddts
 INTEGER                                    :: i93    ! dim3 level 9 counter variable for arrays of ddts
 INTEGER                                    :: i04    ! dim4 level 0 counter variable for arrays of ddts
 INTEGER                                    :: i14    ! dim4 level 1 counter variable for arrays of ddts
 INTEGER                                    :: i24    ! dim4 level 2 counter variable for arrays of ddts
 INTEGER                                    :: i34    ! dim4 level 3 counter variable for arrays of ddts
 INTEGER                                    :: i44    ! dim4 level 4 counter variable for arrays of ddts
 INTEGER                                    :: i54    ! dim4 level 5 counter variable for arrays of ddts
 INTEGER                                    :: i64    ! dim4 level 6 counter variable for arrays of ddts
 INTEGER                                    :: i74    ! dim4 level 7 counter variable for arrays of ddts
 INTEGER                                    :: i84    ! dim4 level 8 counter variable for arrays of ddts
 INTEGER                                    :: i94    ! dim4 level 9 counter variable for arrays of ddts
 INTEGER                                    :: i05    ! dim5 level 0 counter variable for arrays of ddts
 INTEGER                                    :: i15    ! dim5 level 1 counter variable for arrays of ddts
 INTEGER                                    :: i25    ! dim5 level 2 counter variable for arrays of ddts
 INTEGER                                    :: i35    ! dim5 level 3 counter variable for arrays of ddts
 INTEGER                                    :: i45    ! dim5 level 4 counter variable for arrays of ddts
 INTEGER                                    :: i55    ! dim5 level 5 counter variable for arrays of ddts
 INTEGER                                    :: i65    ! dim5 level 6 counter variable for arrays of ddts
 INTEGER                                    :: i75    ! dim5 level 7 counter variable for arrays of ddts
 INTEGER                                    :: i85    ! dim5 level 8 counter variable for arrays of ddts
 INTEGER                                    :: i95    ! dim5 level 9 counter variable for arrays of ddts
    ! Initialize ErrStat
 ErrStat = ErrID_None
 ErrMsg  = ""
    ! we'll subtract a constant from the times to resolve some 
    ! numerical issues when t gets large (and to simplify the equations)
 t = tin - tin(1)
 t_out = tin_out - tin(1)

 if ( size(t) .ne. size(u)) then
    ErrStat = ErrID_Fatal
    ErrMsg = ' Error in BEM_Input_ExtrapInterp: size(t) must equal size(u) '
    RETURN
 endif
 if (size(u) .gt. 3) then
    ErrStat = ErrID_Fatal
    ErrMsg  = ' Error in BEM_Input_ExtrapInterp: size(u) must be less than 4 '
    RETURN
 endif
 order = SIZE(u) - 1
 IF ( order .eq. 0 ) THEN
IF (ALLOCATED(u_out%theta) .AND. ALLOCATED(u(1)%theta)) THEN
  u_out%theta = u(1)%theta
END IF ! check if allocated
  u_out%gamma = u(1)%gamma
IF (ALLOCATED(u_out%psi) .AND. ALLOCATED(u(1)%psi)) THEN
  u_out%psi = u(1)%psi
END IF ! check if allocated
  u_out%omega = u(1)%omega
IF (ALLOCATED(u_out%Vx) .AND. ALLOCATED(u(1)%Vx)) THEN
  u_out%Vx = u(1)%Vx
END IF ! check if allocated
IF (ALLOCATED(u_out%Vy) .AND. ALLOCATED(u(1)%Vy)) THEN
  u_out%Vy = u(1)%Vy
END IF ! check if allocated
  u_out%lambda = u(1)%lambda
IF (ALLOCATED(u_out%rTip) .AND. ALLOCATED(u(1)%rTip)) THEN
  u_out%rTip = u(1)%rTip
END IF ! check if allocated
IF (ALLOCATED(u_out%rLocal) .AND. ALLOCATED(u(1)%rLocal)) THEN
  u_out%rLocal = u(1)%rLocal
END IF ! check if allocated
 ELSE IF ( order .eq. 1 ) THEN
  IF ( EqualRealNos( t(1), t(2) ) ) THEN
    ErrStat = ErrID_Fatal
    ErrMsg  = ' Error in BEM_Input_ExtrapInterp: t(1) must not equal t(2) to avoid a division-by-zero error.'
    RETURN
  END IF
IF (ALLOCATED(u_out%theta) .AND. ALLOCATED(u(1)%theta)) THEN
  ALLOCATE(b2(SIZE(u_out%theta,1),SIZE(u_out%theta,2) ))
  ALLOCATE(c2(SIZE(u_out%theta,1),SIZE(u_out%theta,2) ))
  b2 = -(u(1)%theta - u(2)%theta)/t(2)
  u_out%theta = u(1)%theta + b2 * t_out
  DEALLOCATE(b2)
  DEALLOCATE(c2)
END IF ! check if allocated
  b0 = -(u(1)%gamma - u(2)%gamma)/t(2)
  u_out%gamma = u(1)%gamma + b0 * t_out
IF (ALLOCATED(u_out%psi) .AND. ALLOCATED(u(1)%psi)) THEN
  ALLOCATE(b1(SIZE(u_out%psi,1)))
  ALLOCATE(c1(SIZE(u_out%psi,1)))
  b1 = -(u(1)%psi - u(2)%psi)/t(2)
  u_out%psi = u(1)%psi + b1 * t_out
  DEALLOCATE(b1)
  DEALLOCATE(c1)
END IF ! check if allocated
  b0 = -(u(1)%omega - u(2)%omega)/t(2)
  u_out%omega = u(1)%omega + b0 * t_out
IF (ALLOCATED(u_out%Vx) .AND. ALLOCATED(u(1)%Vx)) THEN
  ALLOCATE(b2(SIZE(u_out%Vx,1),SIZE(u_out%Vx,2) ))
  ALLOCATE(c2(SIZE(u_out%Vx,1),SIZE(u_out%Vx,2) ))
  b2 = -(u(1)%Vx - u(2)%Vx)/t(2)
  u_out%Vx = u(1)%Vx + b2 * t_out
  DEALLOCATE(b2)
  DEALLOCATE(c2)
END IF ! check if allocated
IF (ALLOCATED(u_out%Vy) .AND. ALLOCATED(u(1)%Vy)) THEN
  ALLOCATE(b2(SIZE(u_out%Vy,1),SIZE(u_out%Vy,2) ))
  ALLOCATE(c2(SIZE(u_out%Vy,1),SIZE(u_out%Vy,2) ))
  b2 = -(u(1)%Vy - u(2)%Vy)/t(2)
  u_out%Vy = u(1)%Vy + b2 * t_out
  DEALLOCATE(b2)
  DEALLOCATE(c2)
END IF ! check if allocated
  b0 = -(u(1)%lambda - u(2)%lambda)/t(2)
  u_out%lambda = u(1)%lambda + b0 * t_out
IF (ALLOCATED(u_out%rTip) .AND. ALLOCATED(u(1)%rTip)) THEN
  ALLOCATE(b1(SIZE(u_out%rTip,1)))
  ALLOCATE(c1(SIZE(u_out%rTip,1)))
  b1 = -(u(1)%rTip - u(2)%rTip)/t(2)
  u_out%rTip = u(1)%rTip + b1 * t_out
  DEALLOCATE(b1)
  DEALLOCATE(c1)
END IF ! check if allocated
IF (ALLOCATED(u_out%rLocal) .AND. ALLOCATED(u(1)%rLocal)) THEN
  ALLOCATE(b2(SIZE(u_out%rLocal,1),SIZE(u_out%rLocal,2) ))
  ALLOCATE(c2(SIZE(u_out%rLocal,1),SIZE(u_out%rLocal,2) ))
  b2 = -(u(1)%rLocal - u(2)%rLocal)/t(2)
  u_out%rLocal = u(1)%rLocal + b2 * t_out
  DEALLOCATE(b2)
  DEALLOCATE(c2)
END IF ! check if allocated
 ELSE IF ( order .eq. 2 ) THEN
  IF ( EqualRealNos( t(1), t(2) ) ) THEN
    ErrStat = ErrID_Fatal
    ErrMsg  = ' Error in BEM_Input_ExtrapInterp: t(1) must not equal t(2) to avoid a division-by-zero error.'
    RETURN
  END IF
  IF ( EqualRealNos( t(2), t(3) ) ) THEN
    ErrStat = ErrID_Fatal
    ErrMsg  = ' Error in BEM_Input_ExtrapInterp: t(2) must not equal t(3) to avoid a division-by-zero error.'
    RETURN
  END IF
  IF ( EqualRealNos( t(1), t(3) ) ) THEN
    ErrStat = ErrID_Fatal
    ErrMsg  = ' Error in BEM_Input_ExtrapInterp: t(1) must not equal t(3) to avoid a division-by-zero error.'
    RETURN
  END IF
IF (ALLOCATED(u_out%theta) .AND. ALLOCATED(u(1)%theta)) THEN
  ALLOCATE(b2(SIZE(u_out%theta,1),SIZE(u_out%theta,2) ))
  ALLOCATE(c2(SIZE(u_out%theta,1),SIZE(u_out%theta,2) ))
  b2 = (t(3)**2*(u(1)%theta - u(2)%theta) + t(2)**2*(-u(1)%theta + u(3)%theta))/(t(2)*t(3)*(t(2) - t(3)))
  c2 = ( (t(2)-t(3))*u(1)%theta + t(3)*u(2)%theta - t(2)*u(3)%theta ) / (t(2)*t(3)*(t(2) - t(3)))
  u_out%theta = u(1)%theta + b2 * t_out + c2 * t_out**2
  DEALLOCATE(b2)
  DEALLOCATE(c2)
END IF ! check if allocated
  b0 = (t(3)**2*(u(1)%gamma - u(2)%gamma) + t(2)**2*(-u(1)%gamma + u(3)%gamma))/(t(2)*t(3)*(t(2) - t(3)))
  c0 = ( (t(2)-t(3))*u(1)%gamma + t(3)*u(2)%gamma - t(2)*u(3)%gamma ) / (t(2)*t(3)*(t(2) - t(3)))
  u_out%gamma = u(1)%gamma + b0 * t_out + c0 * t_out**2
IF (ALLOCATED(u_out%psi) .AND. ALLOCATED(u(1)%psi)) THEN
  ALLOCATE(b1(SIZE(u_out%psi,1)))
  ALLOCATE(c1(SIZE(u_out%psi,1)))
  b1 = (t(3)**2*(u(1)%psi - u(2)%psi) + t(2)**2*(-u(1)%psi + u(3)%psi))/(t(2)*t(3)*(t(2) - t(3)))
  c1 = ( (t(2)-t(3))*u(1)%psi + t(3)*u(2)%psi - t(2)*u(3)%psi ) / (t(2)*t(3)*(t(2) - t(3)))
  u_out%psi = u(1)%psi + b1 * t_out + c1 * t_out**2
  DEALLOCATE(b1)
  DEALLOCATE(c1)
END IF ! check if allocated
  b0 = (t(3)**2*(u(1)%omega - u(2)%omega) + t(2)**2*(-u(1)%omega + u(3)%omega))/(t(2)*t(3)*(t(2) - t(3)))
  c0 = ( (t(2)-t(3))*u(1)%omega + t(3)*u(2)%omega - t(2)*u(3)%omega ) / (t(2)*t(3)*(t(2) - t(3)))
  u_out%omega = u(1)%omega + b0 * t_out + c0 * t_out**2
IF (ALLOCATED(u_out%Vx) .AND. ALLOCATED(u(1)%Vx)) THEN
  ALLOCATE(b2(SIZE(u_out%Vx,1),SIZE(u_out%Vx,2) ))
  ALLOCATE(c2(SIZE(u_out%Vx,1),SIZE(u_out%Vx,2) ))
  b2 = (t(3)**2*(u(1)%Vx - u(2)%Vx) + t(2)**2*(-u(1)%Vx + u(3)%Vx))/(t(2)*t(3)*(t(2) - t(3)))
  c2 = ( (t(2)-t(3))*u(1)%Vx + t(3)*u(2)%Vx - t(2)*u(3)%Vx ) / (t(2)*t(3)*(t(2) - t(3)))
  u_out%Vx = u(1)%Vx + b2 * t_out + c2 * t_out**2
  DEALLOCATE(b2)
  DEALLOCATE(c2)
END IF ! check if allocated
IF (ALLOCATED(u_out%Vy) .AND. ALLOCATED(u(1)%Vy)) THEN
  ALLOCATE(b2(SIZE(u_out%Vy,1),SIZE(u_out%Vy,2) ))
  ALLOCATE(c2(SIZE(u_out%Vy,1),SIZE(u_out%Vy,2) ))
  b2 = (t(3)**2*(u(1)%Vy - u(2)%Vy) + t(2)**2*(-u(1)%Vy + u(3)%Vy))/(t(2)*t(3)*(t(2) - t(3)))
  c2 = ( (t(2)-t(3))*u(1)%Vy + t(3)*u(2)%Vy - t(2)*u(3)%Vy ) / (t(2)*t(3)*(t(2) - t(3)))
  u_out%Vy = u(1)%Vy + b2 * t_out + c2 * t_out**2
  DEALLOCATE(b2)
  DEALLOCATE(c2)
END IF ! check if allocated
  b0 = (t(3)**2*(u(1)%lambda - u(2)%lambda) + t(2)**2*(-u(1)%lambda + u(3)%lambda))/(t(2)*t(3)*(t(2) - t(3)))
  c0 = ( (t(2)-t(3))*u(1)%lambda + t(3)*u(2)%lambda - t(2)*u(3)%lambda ) / (t(2)*t(3)*(t(2) - t(3)))
  u_out%lambda = u(1)%lambda + b0 * t_out + c0 * t_out**2
IF (ALLOCATED(u_out%rTip) .AND. ALLOCATED(u(1)%rTip)) THEN
  ALLOCATE(b1(SIZE(u_out%rTip,1)))
  ALLOCATE(c1(SIZE(u_out%rTip,1)))
  b1 = (t(3)**2*(u(1)%rTip - u(2)%rTip) + t(2)**2*(-u(1)%rTip + u(3)%rTip))/(t(2)*t(3)*(t(2) - t(3)))
  c1 = ( (t(2)-t(3))*u(1)%rTip + t(3)*u(2)%rTip - t(2)*u(3)%rTip ) / (t(2)*t(3)*(t(2) - t(3)))
  u_out%rTip = u(1)%rTip + b1 * t_out + c1 * t_out**2
  DEALLOCATE(b1)
  DEALLOCATE(c1)
END IF ! check if allocated
IF (ALLOCATED(u_out%rLocal) .AND. ALLOCATED(u(1)%rLocal)) THEN
  ALLOCATE(b2(SIZE(u_out%rLocal,1),SIZE(u_out%rLocal,2) ))
  ALLOCATE(c2(SIZE(u_out%rLocal,1),SIZE(u_out%rLocal,2) ))
  b2 = (t(3)**2*(u(1)%rLocal - u(2)%rLocal) + t(2)**2*(-u(1)%rLocal + u(3)%rLocal))/(t(2)*t(3)*(t(2) - t(3)))
  c2 = ( (t(2)-t(3))*u(1)%rLocal + t(3)*u(2)%rLocal - t(2)*u(3)%rLocal ) / (t(2)*t(3)*(t(2) - t(3)))
  u_out%rLocal = u(1)%rLocal + b2 * t_out + c2 * t_out**2
  DEALLOCATE(b2)
  DEALLOCATE(c2)
END IF ! check if allocated
 ELSE 
   ErrStat = ErrID_Fatal
   ErrMsg = ' order must be less than 3 in BEM_Input_ExtrapInterp '
   RETURN
 ENDIF 
 END SUBROUTINE BEM_Input_ExtrapInterp


 SUBROUTINE BEM_Output_ExtrapInterp(u, tin, u_out, tin_out, ErrStat, ErrMsg )
!
! This subroutine calculates a extrapolated (or interpolated) input u_out at time t_out, from previous/future time
! values of u (which has values associated with times in t).  Order of the interpolation is given by the size of u
!
!  expressions below based on either
!
!  f(t) = a
!  f(t) = a + b * t, or
!  f(t) = a + b * t + c * t**2
!
!  where a, b and c are determined as the solution to
!  f(t1) = u1, f(t2) = u2, f(t3) = u3  (as appropriate)
!
!..................................................................................................................................

 TYPE(BEM_outputtype), INTENT(INOUT)  :: u(:)      ! Inputs at t1 > t2 > t3
 REAL(DbKi),         INTENT(IN   )  :: tin(:)      ! Times associated with the inputs
 TYPE(BEM_outputtype), INTENT(INOUT)  :: u_out     ! Inputs at tin_out
 REAL(DbKi),         INTENT(IN   )  :: tin_out     ! time to be extrap/interp'd to
 INTEGER(IntKi),     INTENT(  OUT)  :: ErrStat   ! Error status of the operation
 CHARACTER(*),       INTENT(  OUT)  :: ErrMsg    ! Error message if ErrStat /= ErrID_None
   ! local variables
 REAL(DbKi) :: t(SIZE(tin))    ! Times associated with the inputs
 REAL(DbKi) :: t_out           ! Time to which to be extrap/interpd
 INTEGER(IntKi)                 :: order    ! order of polynomial fit (max 2)
 REAL(DbKi)                                 :: b0       ! temporary for extrapolation/interpolation
 REAL(DbKi)                                 :: c0       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:)        :: b1       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:)        :: c1       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:,:)      :: b2       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:,:)      :: c2       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:,:,:)    :: b3       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:,:,:)    :: c3       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:,:,:,:)  :: b4       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:,:,:,:)  :: c4       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:,:,:,:,:):: b5       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:,:,:,:,:):: c5       ! temporary for extrapolation/interpolation
 INTEGER                                    :: i01    ! dim1 level 0 counter variable for arrays of ddts
 INTEGER                                    :: i11    ! dim1 level 1 counter variable for arrays of ddts
 INTEGER                                    :: i21    ! dim1 level 2 counter variable for arrays of ddts
 INTEGER                                    :: i31    ! dim1 level 3 counter variable for arrays of ddts
 INTEGER                                    :: i41    ! dim1 level 4 counter variable for arrays of ddts
 INTEGER                                    :: i51    ! dim1 level 5 counter variable for arrays of ddts
 INTEGER                                    :: i61    ! dim1 level 6 counter variable for arrays of ddts
 INTEGER                                    :: i71    ! dim1 level 7 counter variable for arrays of ddts
 INTEGER                                    :: i81    ! dim1 level 8 counter variable for arrays of ddts
 INTEGER                                    :: i91    ! dim1 level 9 counter variable for arrays of ddts
 INTEGER                                    :: i02    ! dim2 level 0 counter variable for arrays of ddts
 INTEGER                                    :: i12    ! dim2 level 1 counter variable for arrays of ddts
 INTEGER                                    :: i22    ! dim2 level 2 counter variable for arrays of ddts
 INTEGER                                    :: i32    ! dim2 level 3 counter variable for arrays of ddts
 INTEGER                                    :: i42    ! dim2 level 4 counter variable for arrays of ddts
 INTEGER                                    :: i52    ! dim2 level 5 counter variable for arrays of ddts
 INTEGER                                    :: i62    ! dim2 level 6 counter variable for arrays of ddts
 INTEGER                                    :: i72    ! dim2 level 7 counter variable for arrays of ddts
 INTEGER                                    :: i82    ! dim2 level 8 counter variable for arrays of ddts
 INTEGER                                    :: i92    ! dim2 level 9 counter variable for arrays of ddts
 INTEGER                                    :: i03    ! dim3 level 0 counter variable for arrays of ddts
 INTEGER                                    :: i13    ! dim3 level 1 counter variable for arrays of ddts
 INTEGER                                    :: i23    ! dim3 level 2 counter variable for arrays of ddts
 INTEGER                                    :: i33    ! dim3 level 3 counter variable for arrays of ddts
 INTEGER                                    :: i43    ! dim3 level 4 counter variable for arrays of ddts
 INTEGER                                    :: i53    ! dim3 level 5 counter variable for arrays of ddts
 INTEGER                                    :: i63    ! dim3 level 6 counter variable for arrays of ddts
 INTEGER                                    :: i73    ! dim3 level 7 counter variable for arrays of ddts
 INTEGER                                    :: i83    ! dim3 level 8 counter variable for arrays of ddts
 INTEGER                                    :: i93    ! dim3 level 9 counter variable for arrays of ddts
 INTEGER                                    :: i04    ! dim4 level 0 counter variable for arrays of ddts
 INTEGER                                    :: i14    ! dim4 level 1 counter variable for arrays of ddts
 INTEGER                                    :: i24    ! dim4 level 2 counter variable for arrays of ddts
 INTEGER                                    :: i34    ! dim4 level 3 counter variable for arrays of ddts
 INTEGER                                    :: i44    ! dim4 level 4 counter variable for arrays of ddts
 INTEGER                                    :: i54    ! dim4 level 5 counter variable for arrays of ddts
 INTEGER                                    :: i64    ! dim4 level 6 counter variable for arrays of ddts
 INTEGER                                    :: i74    ! dim4 level 7 counter variable for arrays of ddts
 INTEGER                                    :: i84    ! dim4 level 8 counter variable for arrays of ddts
 INTEGER                                    :: i94    ! dim4 level 9 counter variable for arrays of ddts
 INTEGER                                    :: i05    ! dim5 level 0 counter variable for arrays of ddts
 INTEGER                                    :: i15    ! dim5 level 1 counter variable for arrays of ddts
 INTEGER                                    :: i25    ! dim5 level 2 counter variable for arrays of ddts
 INTEGER                                    :: i35    ! dim5 level 3 counter variable for arrays of ddts
 INTEGER                                    :: i45    ! dim5 level 4 counter variable for arrays of ddts
 INTEGER                                    :: i55    ! dim5 level 5 counter variable for arrays of ddts
 INTEGER                                    :: i65    ! dim5 level 6 counter variable for arrays of ddts
 INTEGER                                    :: i75    ! dim5 level 7 counter variable for arrays of ddts
 INTEGER                                    :: i85    ! dim5 level 8 counter variable for arrays of ddts
 INTEGER                                    :: i95    ! dim5 level 9 counter variable for arrays of ddts
    ! Initialize ErrStat
 ErrStat = ErrID_None
 ErrMsg  = ""
    ! we'll subtract a constant from the times to resolve some 
    ! numerical issues when t gets large (and to simplify the equations)
 t = tin - tin(1)
 t_out = tin_out - tin(1)

 if ( size(t) .ne. size(u)) then
    ErrStat = ErrID_Fatal
    ErrMsg = ' Error in BEM_Output_ExtrapInterp: size(t) must equal size(u) '
    RETURN
 endif
 if (size(u) .gt. 3) then
    ErrStat = ErrID_Fatal
    ErrMsg  = ' Error in BEM_Output_ExtrapInterp: size(u) must be less than 4 '
    RETURN
 endif
 order = SIZE(u) - 1
 IF ( order .eq. 0 ) THEN
IF (ALLOCATED(u_out%inducedVel) .AND. ALLOCATED(u(1)%inducedVel)) THEN
  u_out%inducedVel = u(1)%inducedVel
END IF ! check if allocated
IF (ALLOCATED(u_out%phi) .AND. ALLOCATED(u(1)%phi)) THEN
  u_out%phi = u(1)%phi
END IF ! check if allocated
 ELSE IF ( order .eq. 1 ) THEN
  IF ( EqualRealNos( t(1), t(2) ) ) THEN
    ErrStat = ErrID_Fatal
    ErrMsg  = ' Error in BEM_Output_ExtrapInterp: t(1) must not equal t(2) to avoid a division-by-zero error.'
    RETURN
  END IF
IF (ALLOCATED(u_out%inducedVel) .AND. ALLOCATED(u(1)%inducedVel)) THEN
  ALLOCATE(b2(SIZE(u_out%inducedVel,1),SIZE(u_out%inducedVel,2) ))
  ALLOCATE(c2(SIZE(u_out%inducedVel,1),SIZE(u_out%inducedVel,2) ))
  b2 = -(u(1)%inducedVel - u(2)%inducedVel)/t(2)
  u_out%inducedVel = u(1)%inducedVel + b2 * t_out
  DEALLOCATE(b2)
  DEALLOCATE(c2)
END IF ! check if allocated
IF (ALLOCATED(u_out%phi) .AND. ALLOCATED(u(1)%phi)) THEN
  ALLOCATE(b2(SIZE(u_out%phi,1),SIZE(u_out%phi,2) ))
  ALLOCATE(c2(SIZE(u_out%phi,1),SIZE(u_out%phi,2) ))
  b2 = -(u(1)%phi - u(2)%phi)/t(2)
  u_out%phi = u(1)%phi + b2 * t_out
  DEALLOCATE(b2)
  DEALLOCATE(c2)
END IF ! check if allocated
 ELSE IF ( order .eq. 2 ) THEN
  IF ( EqualRealNos( t(1), t(2) ) ) THEN
    ErrStat = ErrID_Fatal
    ErrMsg  = ' Error in BEM_Output_ExtrapInterp: t(1) must not equal t(2) to avoid a division-by-zero error.'
    RETURN
  END IF
  IF ( EqualRealNos( t(2), t(3) ) ) THEN
    ErrStat = ErrID_Fatal
    ErrMsg  = ' Error in BEM_Output_ExtrapInterp: t(2) must not equal t(3) to avoid a division-by-zero error.'
    RETURN
  END IF
  IF ( EqualRealNos( t(1), t(3) ) ) THEN
    ErrStat = ErrID_Fatal
    ErrMsg  = ' Error in BEM_Output_ExtrapInterp: t(1) must not equal t(3) to avoid a division-by-zero error.'
    RETURN
  END IF
IF (ALLOCATED(u_out%inducedVel) .AND. ALLOCATED(u(1)%inducedVel)) THEN
  ALLOCATE(b2(SIZE(u_out%inducedVel,1),SIZE(u_out%inducedVel,2) ))
  ALLOCATE(c2(SIZE(u_out%inducedVel,1),SIZE(u_out%inducedVel,2) ))
  b2 = (t(3)**2*(u(1)%inducedVel - u(2)%inducedVel) + t(2)**2*(-u(1)%inducedVel + u(3)%inducedVel))/(t(2)*t(3)*(t(2) - t(3)))
  c2 = ( (t(2)-t(3))*u(1)%inducedVel + t(3)*u(2)%inducedVel - t(2)*u(3)%inducedVel ) / (t(2)*t(3)*(t(2) - t(3)))
  u_out%inducedVel = u(1)%inducedVel + b2 * t_out + c2 * t_out**2
  DEALLOCATE(b2)
  DEALLOCATE(c2)
END IF ! check if allocated
IF (ALLOCATED(u_out%phi) .AND. ALLOCATED(u(1)%phi)) THEN
  ALLOCATE(b2(SIZE(u_out%phi,1),SIZE(u_out%phi,2) ))
  ALLOCATE(c2(SIZE(u_out%phi,1),SIZE(u_out%phi,2) ))
  b2 = (t(3)**2*(u(1)%phi - u(2)%phi) + t(2)**2*(-u(1)%phi + u(3)%phi))/(t(2)*t(3)*(t(2) - t(3)))
  c2 = ( (t(2)-t(3))*u(1)%phi + t(3)*u(2)%phi - t(2)*u(3)%phi ) / (t(2)*t(3)*(t(2) - t(3)))
  u_out%phi = u(1)%phi + b2 * t_out + c2 * t_out**2
  DEALLOCATE(b2)
  DEALLOCATE(c2)
END IF ! check if allocated
 ELSE 
   ErrStat = ErrID_Fatal
   ErrMsg = ' order must be less than 3 in BEM_Output_ExtrapInterp '
   RETURN
 ENDIF 
 END SUBROUTINE BEM_Output_ExtrapInterp

END MODULE BEM_Types
!ENDOFREGISTRYGENERATEDFILE
