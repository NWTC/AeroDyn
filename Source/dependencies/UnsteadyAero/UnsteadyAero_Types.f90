!STARTOFREGISTRYGENERATEDFILE './UnsteadyAero_Types.f90'
!
! WARNING This file is generated automatically by the FAST registry
! Do not edit.  Your changes to this file will be lost.
!
! FAST Registry (v2.05.00, 10-Jan-2015)
!*********************************************************************************************************************************
! UnsteadyAero_Types
!.................................................................................................................................
! This file is part of UnsteadyAero.
!
! Copyright (C) 2012-2015 National Renewable Energy Laboratory
!
! Licensed under the Apache License, Version 2.0 (the "License");
! you may not use this file except in compliance with the License.
! You may obtain a copy of the License at
!
!     http://www.apache.org/licenses/LICENSE-2.0
!
! Unless required by applicable law or agreed to in writing, software
! distributed under the License is distributed on an "AS IS" BASIS,
! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
! See the License for the specific language governing permissions and
! limitations under the License.
!
!
! W A R N I N G : This file was automatically generated from the FAST registry.  Changes made to this file may be lost.
!
!*********************************************************************************************************************************
MODULE UnsteadyAero_Types
! This module contains all of the user-defined types needed in UnsteadyAero. It also contains copy, destroy, pack, and
! unpack routines associated with each defined data type. This code will be generated by the FAST Registry.
!---------------------------------------------------------------------------------------------------------------------------------
USE AirfoilInfo_Types
USE NWTC_Library
IMPLICIT NONE
! =========  UnsteadyAero_InitInputType  =======
  TYPE, PUBLIC :: UnsteadyAero_InitInputType
    REAL(DbKi)  :: dt      ! time step [s]
    CHARACTER(1024)  :: OutRootName      ! Supplied by Driver:  The name of the root file (without extension) including the full path [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: c      ! Chord length at node [m]
    INTEGER(IntKi)  :: numBlades      ! Number nodes of all blades [-]
    INTEGER(IntKi)  :: nNodesPerBlade      ! Number nodes of all blades [-]
    INTEGER(IntKi)  :: DSMod      ! Model for the dynamic stall equations [-]
    REAL(ReKi)  :: a_s      ! speed of sound [m/s]
    INTEGER(IntKi) , DIMENSION(:,:), ALLOCATABLE  :: AFIndx      !  [-]
    TYPE(AFI_ParameterType)  :: AFI_Params      !  [-]
    CHARACTER(20)  :: OutFmt      ! Output format for numerical results [-]
    CHARACTER(20)  :: OutSFmt      ! Output format for header strings [-]
    INTEGER(IntKi)  :: NumOuts      ! The number of outputs for this module as requested in the input file [-]
    CHARACTER(10) , DIMENSION(1:199)  :: OutList      ! The user-requested output channel labels for this modules. This should really be dimensioned with MaxOutPts [-]
  END TYPE UnsteadyAero_InitInputType
! =======================
! =========  UnsteadyAero_InitOutputType  =======
  TYPE, PUBLIC :: UnsteadyAero_InitOutputType
    TYPE(ProgDesc)  :: Version      !  [-]
    CHARACTER(10) , DIMENSION(:), ALLOCATABLE  :: WriteOutputHdr      ! The is the list of all HD-related output channel header strings (includes all sub-module channels) [-]
    CHARACTER(10) , DIMENSION(:), ALLOCATABLE  :: WriteOutputUnt      ! The is the list of all HD-related output channel unit strings (includes all sub-module channels) [-]
  END TYPE UnsteadyAero_InitOutputType
! =======================
! =========  UnsteadyAero_ContinuousStateType  =======
  TYPE, PUBLIC :: UnsteadyAero_ContinuousStateType
    REAL(ReKi)  :: DummyContState      ! Remove this variable if you have continuous states [-]
  END TYPE UnsteadyAero_ContinuousStateType
! =======================
! =========  UnsteadyAero_DiscreteStateType  =======
  TYPE, PUBLIC :: UnsteadyAero_DiscreteStateType
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: alpha_minus1      !  [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: alpha_minus2      !  [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: q_minus1      !  [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: q_minus2      !  [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: X1_minus1      !  [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: X2_minus1      !  [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: Kprime_alpha_minus1      !  [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: Kprime_q_minus1      !  [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: Dp_minus1      !  [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: Cn_pot_minus1      !  [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: T_f      !  [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: fprimeprime_minus1      !  [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: Df_minus1      !  [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: fprime_minus1      !  [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: tau_V      !  [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: Cn_v_minus1      !  [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: C_V_minus1      !  [-]
  END TYPE UnsteadyAero_DiscreteStateType
! =======================
! =========  UnsteadyAero_ConstraintStateType  =======
  TYPE, PUBLIC :: UnsteadyAero_ConstraintStateType
    REAL(ReKi)  :: DummyConstraintState      !  [-]
  END TYPE UnsteadyAero_ConstraintStateType
! =======================
! =========  UnsteadyAero_OtherStateType  =======
  TYPE, PUBLIC :: UnsteadyAero_OtherStateType
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: sigma1      !  [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: sigma3      !  [-]
    LOGICAL , DIMENSION(:,:), ALLOCATABLE  :: TESF      !  [-]
    LOGICAL , DIMENSION(:,:), ALLOCATABLE  :: LESF      !  [-]
    LOGICAL , DIMENSION(:,:), ALLOCATABLE  :: VRTX      !  [-]
    LOGICAL  :: FirstPass      !  [-]
  END TYPE UnsteadyAero_OtherStateType
! =======================
! =========  UnsteadyAero_ParameterType  =======
  TYPE, PUBLIC :: UnsteadyAero_ParameterType
    REAL(DbKi)  :: dt      ! time step [s]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: c      ! Chord length at node [m]
    INTEGER(IntKi)  :: numBlades      ! Number nodes of all blades [-]
    INTEGER(IntKi)  :: nNodesPerBlade      ! Number nodes of all blades [-]
    INTEGER(IntKi)  :: DSMod      !  [-]
    REAL(ReKi)  :: a_s      ! speed of sound [m/s]
    INTEGER(IntKi) , DIMENSION(:,:), ALLOCATABLE  :: AFIndx      !  [-]
    TYPE(AFI_ParameterType)  :: AFI_Params      ! Parameters for the airfoils [-]
    INTEGER(IntKi)  :: NumOuts      ! Number of HydroDyn module-level outputs (not the total number including sub-modules [-]
    INTEGER(IntKi)  :: OutSwtch      ! Output requested channels to: [1=Hydrodyn.out 2=GlueCode.out  3=both files] [-]
    CHARACTER(20)  :: OutFmt      ! Output format for numerical results [-]
    CHARACTER(20)  :: OutSFmt      ! Output format for header strings [-]
    CHARACTER(10)  :: Delim      ! Delimiter string for outputs, defaults to tab-delimiters [-]
    INTEGER(IntKi)  :: UnOutFile      ! File unit for the HydroDyn outputs [-]
  END TYPE UnsteadyAero_ParameterType
! =======================
! =========  UnsteadyAero_InputType  =======
  TYPE, PUBLIC :: UnsteadyAero_InputType
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: U      !  [m/s]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: Re      !  [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: alpha      !  [rad]
  END TYPE UnsteadyAero_InputType
! =======================
! =========  UnsteadyAero_OutputType  =======
  TYPE, PUBLIC :: UnsteadyAero_OutputType
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: Cn      !  [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: Cc      !  [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: Cm      !  [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: Cl      !  [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: Cd      !  [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: WriteOutput      !  [-]
  END TYPE UnsteadyAero_OutputType
! =======================
CONTAINS
 SUBROUTINE UnsteadyAero_CopyInitInput( SrcInitInputData, DstInitInputData, CtrlCode, ErrStat, ErrMsg )
   TYPE(UnsteadyAero_InitInputType), INTENT(IN) :: SrcInitInputData
   TYPE(UnsteadyAero_InitInputType), INTENT(INOUT) :: DstInitInputData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: i2, i2_l, i2_u  !  bounds (upper/lower) for an array dimension 2
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(1024)                :: ErrMsg2
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
   DstInitInputData%dt = SrcInitInputData%dt
   DstInitInputData%OutRootName = SrcInitInputData%OutRootName
IF (ALLOCATED(SrcInitInputData%c)) THEN
   i1_l = LBOUND(SrcInitInputData%c,1)
   i1_u = UBOUND(SrcInitInputData%c,1)
   i2_l = LBOUND(SrcInitInputData%c,2)
   i2_u = UBOUND(SrcInitInputData%c,2)
   IF (.NOT. ALLOCATED(DstInitInputData%c)) THEN 
      ALLOCATE(DstInitInputData%c(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInitInputData%c.', ErrStat, ErrMsg,'UnsteadyAero_CopyInitInput')
         RETURN
      END IF
   END IF
   DstInitInputData%c = SrcInitInputData%c
ENDIF
   DstInitInputData%numBlades = SrcInitInputData%numBlades
   DstInitInputData%nNodesPerBlade = SrcInitInputData%nNodesPerBlade
   DstInitInputData%DSMod = SrcInitInputData%DSMod
   DstInitInputData%a_s = SrcInitInputData%a_s
IF (ALLOCATED(SrcInitInputData%AFIndx)) THEN
   i1_l = LBOUND(SrcInitInputData%AFIndx,1)
   i1_u = UBOUND(SrcInitInputData%AFIndx,1)
   i2_l = LBOUND(SrcInitInputData%AFIndx,2)
   i2_u = UBOUND(SrcInitInputData%AFIndx,2)
   IF (.NOT. ALLOCATED(DstInitInputData%AFIndx)) THEN 
      ALLOCATE(DstInitInputData%AFIndx(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInitInputData%AFIndx.', ErrStat, ErrMsg,'UnsteadyAero_CopyInitInput')
         RETURN
      END IF
   END IF
   DstInitInputData%AFIndx = SrcInitInputData%AFIndx
ENDIF
      CALL AFI_CopyParam( SrcInitInputData%AFI_Params, DstInitInputData%AFI_Params, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,'UnsteadyAero_CopyInitInput:AFI_Params')
         IF (ErrStat>=AbortErrLev) RETURN
   DstInitInputData%OutFmt = SrcInitInputData%OutFmt
   DstInitInputData%OutSFmt = SrcInitInputData%OutSFmt
   DstInitInputData%NumOuts = SrcInitInputData%NumOuts
   DstInitInputData%OutList = SrcInitInputData%OutList
 END SUBROUTINE UnsteadyAero_CopyInitInput

 SUBROUTINE UnsteadyAero_DestroyInitInput( InitInputData, ErrStat, ErrMsg )
  TYPE(UnsteadyAero_InitInputType), INTENT(INOUT) :: InitInputData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
IF (ALLOCATED(InitInputData%c)) THEN
   DEALLOCATE(InitInputData%c)
ENDIF
IF (ALLOCATED(InitInputData%AFIndx)) THEN
   DEALLOCATE(InitInputData%AFIndx)
ENDIF
  CALL AFI_DestroyParam( InitInputData%AFI_Params, ErrStat, ErrMsg )
 END SUBROUTINE UnsteadyAero_DestroyInitInput

 SUBROUTINE UnsteadyAero_PackInitInput( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(UnsteadyAero_InitInputType),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  REAL(ReKi),     ALLOCATABLE :: Re_AFI_Params_Buf(:)
  REAL(DbKi),     ALLOCATABLE :: Db_AFI_Params_Buf(:)
  INTEGER(IntKi), ALLOCATABLE :: Int_AFI_Params_Buf(:)
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  Db_BufSz   = Db_BufSz   + 1  ! dt
!  missing buffer for OutRootName
  IF ( ALLOCATED(InData%c) )   Re_BufSz    = Re_BufSz    + SIZE( InData%c )  ! c 
  Int_BufSz  = Int_BufSz  + 1  ! numBlades
  Int_BufSz  = Int_BufSz  + 1  ! nNodesPerBlade
  Int_BufSz  = Int_BufSz  + 1  ! DSMod
  Re_BufSz   = Re_BufSz   + 1  ! a_s
  IF ( ALLOCATED(InData%AFIndx) )   Int_BufSz   = Int_BufSz   + SIZE( InData%AFIndx )  ! AFIndx 
  CALL AFI_PackParam( Re_AFI_Params_Buf, Db_AFI_Params_Buf, Int_AFI_Params_Buf, InData%AFI_Params, ErrStat, ErrMsg, .TRUE. ) ! AFI_Params 
  IF(ALLOCATED(Re_AFI_Params_Buf)) Re_BufSz  = Re_BufSz  + SIZE( Re_AFI_Params_Buf  ) ! AFI_Params
  IF(ALLOCATED(Db_AFI_Params_Buf)) Db_BufSz  = Db_BufSz  + SIZE( Db_AFI_Params_Buf  ) ! AFI_Params
  IF(ALLOCATED(Int_AFI_Params_Buf))Int_BufSz = Int_BufSz + SIZE( Int_AFI_Params_Buf ) ! AFI_Params
  IF(ALLOCATED(Re_AFI_Params_Buf))  DEALLOCATE(Re_AFI_Params_Buf)
  IF(ALLOCATED(Db_AFI_Params_Buf))  DEALLOCATE(Db_AFI_Params_Buf)
  IF(ALLOCATED(Int_AFI_Params_Buf)) DEALLOCATE(Int_AFI_Params_Buf)
!  missing buffer for OutFmt
!  missing buffer for OutSFmt
  Int_BufSz  = Int_BufSz  + 1  ! NumOuts
!  missing buffer for OutList
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  IF ( .NOT. OnlySize ) DbKiBuf ( Db_Xferred:Db_Xferred+(1)-1 ) =  (InData%dt )
  Db_Xferred   = Db_Xferred   + 1
  IF ( ALLOCATED(InData%c) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%c))-1 ) =  PACK(InData%c ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%c)
  ENDIF
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%numBlades )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%nNodesPerBlade )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%DSMod )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%a_s )
  Re_Xferred   = Re_Xferred   + 1
  IF ( ALLOCATED(InData%AFIndx) ) THEN
    IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(SIZE(InData%AFIndx))-1 ) = PACK(InData%AFIndx ,.TRUE.)
    Int_Xferred   = Int_Xferred   + SIZE(InData%AFIndx)
  ENDIF
  CALL AFI_PackParam( Re_AFI_Params_Buf, Db_AFI_Params_Buf, Int_AFI_Params_Buf, InData%AFI_Params, ErrStat, ErrMsg, OnlySize ) ! AFI_Params 
  IF(ALLOCATED(Re_AFI_Params_Buf)) THEN
    IF ( .NOT. OnlySize ) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_AFI_Params_Buf)-1 ) = Re_AFI_Params_Buf
    Re_Xferred = Re_Xferred + SIZE(Re_AFI_Params_Buf)
  ENDIF
  IF(ALLOCATED(Db_AFI_Params_Buf)) THEN
    IF ( .NOT. OnlySize ) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_AFI_Params_Buf)-1 ) = Db_AFI_Params_Buf
    Db_Xferred = Db_Xferred + SIZE(Db_AFI_Params_Buf)
  ENDIF
  IF(ALLOCATED(Int_AFI_Params_Buf)) THEN
    IF ( .NOT. OnlySize ) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_AFI_Params_Buf)-1 ) = Int_AFI_Params_Buf
    Int_Xferred = Int_Xferred + SIZE(Int_AFI_Params_Buf)
  ENDIF
  IF( ALLOCATED(Re_AFI_Params_Buf) )  DEALLOCATE(Re_AFI_Params_Buf)
  IF( ALLOCATED(Db_AFI_Params_Buf) )  DEALLOCATE(Db_AFI_Params_Buf)
  IF( ALLOCATED(Int_AFI_Params_Buf) ) DEALLOCATE(Int_AFI_Params_Buf)
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%NumOuts )
  Int_Xferred   = Int_Xferred   + 1
 END SUBROUTINE UnsteadyAero_PackInitInput

 SUBROUTINE UnsteadyAero_UnPackInitInput( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(UnsteadyAero_InitInputType), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
  REAL(ReKi),    ALLOCATABLE :: Re_AFI_Params_Buf(:)
  REAL(DbKi),    ALLOCATABLE :: Db_AFI_Params_Buf(:)
  INTEGER(IntKi),    ALLOCATABLE :: Int_AFI_Params_Buf(:)
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  OutData%dt = DbKiBuf ( Db_Xferred )
  Db_Xferred   = Db_Xferred   + 1
  IF ( ALLOCATED(OutData%c) ) THEN
  ALLOCATE(mask2(SIZE(OutData%c,1),SIZE(OutData%c,2)))
  mask2 = .TRUE.
    OutData%c = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%c))-1 ),mask2,OutData%c)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%c)
  ENDIF
  OutData%numBlades = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%nNodesPerBlade = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%DSMod = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%a_s = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  IF ( ALLOCATED(OutData%AFIndx) ) THEN
  ALLOCATE(mask2(SIZE(OutData%AFIndx,1),SIZE(OutData%AFIndx,2)))
  mask2 = .TRUE.
    OutData%AFIndx = UNPACK(IntKiBuf( Int_Xferred:Re_Xferred+(SIZE(OutData%AFIndx))-1 ),mask2,OutData%AFIndx)
  DEALLOCATE(mask2)
    Int_Xferred   = Int_Xferred   + SIZE(OutData%AFIndx)
  ENDIF
 ! first call AFI_PackParam to get correctly sized buffers for unpacking
  CALL AFI_PackParam( Re_AFI_Params_Buf, Db_AFI_Params_Buf, Int_AFI_Params_Buf, OutData%AFI_Params, ErrStat, ErrMsg, .TRUE. ) ! AFI_Params 
  IF(ALLOCATED(Re_AFI_Params_Buf)) THEN
    Re_AFI_Params_Buf = ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_AFI_Params_Buf)-1 )
    Re_Xferred = Re_Xferred + SIZE(Re_AFI_Params_Buf)
  ENDIF
  IF(ALLOCATED(Db_AFI_Params_Buf)) THEN
    Db_AFI_Params_Buf = DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_AFI_Params_Buf)-1 )
    Db_Xferred = Db_Xferred + SIZE(Db_AFI_Params_Buf)
  ENDIF
  IF(ALLOCATED(Int_AFI_Params_Buf)) THEN
    Int_AFI_Params_Buf = IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_AFI_Params_Buf)-1 )
    Int_Xferred = Int_Xferred + SIZE(Int_AFI_Params_Buf)
  ENDIF
  CALL AFI_UnPackParam( Re_AFI_Params_Buf, Db_AFI_Params_Buf, Int_AFI_Params_Buf, OutData%AFI_Params, ErrStat, ErrMsg ) ! AFI_Params 
  OutData%NumOuts = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE UnsteadyAero_UnPackInitInput

 SUBROUTINE UnsteadyAero_CopyInitOutput( SrcInitOutputData, DstInitOutputData, CtrlCode, ErrStat, ErrMsg )
   TYPE(UnsteadyAero_InitOutputType), INTENT(IN) :: SrcInitOutputData
   TYPE(UnsteadyAero_InitOutputType), INTENT(INOUT) :: DstInitOutputData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: i2, i2_l, i2_u  !  bounds (upper/lower) for an array dimension 2
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(1024)                :: ErrMsg2
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
      CALL NWTC_Library_Copyprogdesc( SrcInitOutputData%Version, DstInitOutputData%Version, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,'UnsteadyAero_CopyInitOutput:Version')
         IF (ErrStat>=AbortErrLev) RETURN
IF (ALLOCATED(SrcInitOutputData%WriteOutputHdr)) THEN
   i1_l = LBOUND(SrcInitOutputData%WriteOutputHdr,1)
   i1_u = UBOUND(SrcInitOutputData%WriteOutputHdr,1)
   IF (.NOT. ALLOCATED(DstInitOutputData%WriteOutputHdr)) THEN 
      ALLOCATE(DstInitOutputData%WriteOutputHdr(i1_l:i1_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInitOutputData%WriteOutputHdr.', ErrStat, ErrMsg,'UnsteadyAero_CopyInitOutput')
         RETURN
      END IF
   END IF
   DstInitOutputData%WriteOutputHdr = SrcInitOutputData%WriteOutputHdr
ENDIF
IF (ALLOCATED(SrcInitOutputData%WriteOutputUnt)) THEN
   i1_l = LBOUND(SrcInitOutputData%WriteOutputUnt,1)
   i1_u = UBOUND(SrcInitOutputData%WriteOutputUnt,1)
   IF (.NOT. ALLOCATED(DstInitOutputData%WriteOutputUnt)) THEN 
      ALLOCATE(DstInitOutputData%WriteOutputUnt(i1_l:i1_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInitOutputData%WriteOutputUnt.', ErrStat, ErrMsg,'UnsteadyAero_CopyInitOutput')
         RETURN
      END IF
   END IF
   DstInitOutputData%WriteOutputUnt = SrcInitOutputData%WriteOutputUnt
ENDIF
 END SUBROUTINE UnsteadyAero_CopyInitOutput

 SUBROUTINE UnsteadyAero_DestroyInitOutput( InitOutputData, ErrStat, ErrMsg )
  TYPE(UnsteadyAero_InitOutputType), INTENT(INOUT) :: InitOutputData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
  CALL NWTC_Library_Destroyprogdesc( InitOutputData%Version, ErrStat, ErrMsg )
IF (ALLOCATED(InitOutputData%WriteOutputHdr)) THEN
   DEALLOCATE(InitOutputData%WriteOutputHdr)
ENDIF
IF (ALLOCATED(InitOutputData%WriteOutputUnt)) THEN
   DEALLOCATE(InitOutputData%WriteOutputUnt)
ENDIF
 END SUBROUTINE UnsteadyAero_DestroyInitOutput

 SUBROUTINE UnsteadyAero_PackInitOutput( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(UnsteadyAero_InitOutputType),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  REAL(ReKi),     ALLOCATABLE :: Re_Version_Buf(:)
  REAL(DbKi),     ALLOCATABLE :: Db_Version_Buf(:)
  INTEGER(IntKi), ALLOCATABLE :: Int_Version_Buf(:)
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  CALL NWTC_Library_Packprogdesc( Re_Version_Buf, Db_Version_Buf, Int_Version_Buf, InData%Version, ErrStat, ErrMsg, .TRUE. ) ! Version 
  IF(ALLOCATED(Re_Version_Buf)) Re_BufSz  = Re_BufSz  + SIZE( Re_Version_Buf  ) ! Version
  IF(ALLOCATED(Db_Version_Buf)) Db_BufSz  = Db_BufSz  + SIZE( Db_Version_Buf  ) ! Version
  IF(ALLOCATED(Int_Version_Buf))Int_BufSz = Int_BufSz + SIZE( Int_Version_Buf ) ! Version
  IF(ALLOCATED(Re_Version_Buf))  DEALLOCATE(Re_Version_Buf)
  IF(ALLOCATED(Db_Version_Buf))  DEALLOCATE(Db_Version_Buf)
  IF(ALLOCATED(Int_Version_Buf)) DEALLOCATE(Int_Version_Buf)
!  missing buffer for WriteOutputHdr
!  missing buffer for WriteOutputUnt
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  CALL NWTC_Library_Packprogdesc( Re_Version_Buf, Db_Version_Buf, Int_Version_Buf, InData%Version, ErrStat, ErrMsg, OnlySize ) ! Version 
  IF(ALLOCATED(Re_Version_Buf)) THEN
    IF ( .NOT. OnlySize ) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_Version_Buf)-1 ) = Re_Version_Buf
    Re_Xferred = Re_Xferred + SIZE(Re_Version_Buf)
  ENDIF
  IF(ALLOCATED(Db_Version_Buf)) THEN
    IF ( .NOT. OnlySize ) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_Version_Buf)-1 ) = Db_Version_Buf
    Db_Xferred = Db_Xferred + SIZE(Db_Version_Buf)
  ENDIF
  IF(ALLOCATED(Int_Version_Buf)) THEN
    IF ( .NOT. OnlySize ) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_Version_Buf)-1 ) = Int_Version_Buf
    Int_Xferred = Int_Xferred + SIZE(Int_Version_Buf)
  ENDIF
  IF( ALLOCATED(Re_Version_Buf) )  DEALLOCATE(Re_Version_Buf)
  IF( ALLOCATED(Db_Version_Buf) )  DEALLOCATE(Db_Version_Buf)
  IF( ALLOCATED(Int_Version_Buf) ) DEALLOCATE(Int_Version_Buf)
 END SUBROUTINE UnsteadyAero_PackInitOutput

 SUBROUTINE UnsteadyAero_UnPackInitOutput( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(UnsteadyAero_InitOutputType), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
  REAL(ReKi),    ALLOCATABLE :: Re_Version_Buf(:)
  REAL(DbKi),    ALLOCATABLE :: Db_Version_Buf(:)
  INTEGER(IntKi),    ALLOCATABLE :: Int_Version_Buf(:)
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
 ! first call NWTC_Library_Packprogdesc to get correctly sized buffers for unpacking
  CALL NWTC_Library_Packprogdesc( Re_Version_Buf, Db_Version_Buf, Int_Version_Buf, OutData%Version, ErrStat, ErrMsg, .TRUE. ) ! Version 
  IF(ALLOCATED(Re_Version_Buf)) THEN
    Re_Version_Buf = ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_Version_Buf)-1 )
    Re_Xferred = Re_Xferred + SIZE(Re_Version_Buf)
  ENDIF
  IF(ALLOCATED(Db_Version_Buf)) THEN
    Db_Version_Buf = DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_Version_Buf)-1 )
    Db_Xferred = Db_Xferred + SIZE(Db_Version_Buf)
  ENDIF
  IF(ALLOCATED(Int_Version_Buf)) THEN
    Int_Version_Buf = IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_Version_Buf)-1 )
    Int_Xferred = Int_Xferred + SIZE(Int_Version_Buf)
  ENDIF
  CALL NWTC_Library_UnPackprogdesc( Re_Version_Buf, Db_Version_Buf, Int_Version_Buf, OutData%Version, ErrStat, ErrMsg ) ! Version 
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE UnsteadyAero_UnPackInitOutput

 SUBROUTINE UnsteadyAero_CopyContState( SrcContStateData, DstContStateData, CtrlCode, ErrStat, ErrMsg )
   TYPE(UnsteadyAero_ContinuousStateType), INTENT(IN) :: SrcContStateData
   TYPE(UnsteadyAero_ContinuousStateType), INTENT(INOUT) :: DstContStateData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: i2, i2_l, i2_u  !  bounds (upper/lower) for an array dimension 2
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(1024)                :: ErrMsg2
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
   DstContStateData%DummyContState = SrcContStateData%DummyContState
 END SUBROUTINE UnsteadyAero_CopyContState

 SUBROUTINE UnsteadyAero_DestroyContState( ContStateData, ErrStat, ErrMsg )
  TYPE(UnsteadyAero_ContinuousStateType), INTENT(INOUT) :: ContStateData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
 END SUBROUTINE UnsteadyAero_DestroyContState

 SUBROUTINE UnsteadyAero_PackContState( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(UnsteadyAero_ContinuousStateType),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  Re_BufSz   = Re_BufSz   + 1  ! DummyContState
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%DummyContState )
  Re_Xferred   = Re_Xferred   + 1
 END SUBROUTINE UnsteadyAero_PackContState

 SUBROUTINE UnsteadyAero_UnPackContState( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(UnsteadyAero_ContinuousStateType), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  OutData%DummyContState = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE UnsteadyAero_UnPackContState

 SUBROUTINE UnsteadyAero_CopyDiscState( SrcDiscStateData, DstDiscStateData, CtrlCode, ErrStat, ErrMsg )
   TYPE(UnsteadyAero_DiscreteStateType), INTENT(IN) :: SrcDiscStateData
   TYPE(UnsteadyAero_DiscreteStateType), INTENT(INOUT) :: DstDiscStateData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: i2, i2_l, i2_u  !  bounds (upper/lower) for an array dimension 2
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(1024)                :: ErrMsg2
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
IF (ALLOCATED(SrcDiscStateData%alpha_minus1)) THEN
   i1_l = LBOUND(SrcDiscStateData%alpha_minus1,1)
   i1_u = UBOUND(SrcDiscStateData%alpha_minus1,1)
   i2_l = LBOUND(SrcDiscStateData%alpha_minus1,2)
   i2_u = UBOUND(SrcDiscStateData%alpha_minus1,2)
   IF (.NOT. ALLOCATED(DstDiscStateData%alpha_minus1)) THEN 
      ALLOCATE(DstDiscStateData%alpha_minus1(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstDiscStateData%alpha_minus1.', ErrStat, ErrMsg,'UnsteadyAero_CopyDiscState')
         RETURN
      END IF
   END IF
   DstDiscStateData%alpha_minus1 = SrcDiscStateData%alpha_minus1
ENDIF
IF (ALLOCATED(SrcDiscStateData%alpha_minus2)) THEN
   i1_l = LBOUND(SrcDiscStateData%alpha_minus2,1)
   i1_u = UBOUND(SrcDiscStateData%alpha_minus2,1)
   i2_l = LBOUND(SrcDiscStateData%alpha_minus2,2)
   i2_u = UBOUND(SrcDiscStateData%alpha_minus2,2)
   IF (.NOT. ALLOCATED(DstDiscStateData%alpha_minus2)) THEN 
      ALLOCATE(DstDiscStateData%alpha_minus2(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstDiscStateData%alpha_minus2.', ErrStat, ErrMsg,'UnsteadyAero_CopyDiscState')
         RETURN
      END IF
   END IF
   DstDiscStateData%alpha_minus2 = SrcDiscStateData%alpha_minus2
ENDIF
IF (ALLOCATED(SrcDiscStateData%q_minus1)) THEN
   i1_l = LBOUND(SrcDiscStateData%q_minus1,1)
   i1_u = UBOUND(SrcDiscStateData%q_minus1,1)
   i2_l = LBOUND(SrcDiscStateData%q_minus1,2)
   i2_u = UBOUND(SrcDiscStateData%q_minus1,2)
   IF (.NOT. ALLOCATED(DstDiscStateData%q_minus1)) THEN 
      ALLOCATE(DstDiscStateData%q_minus1(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstDiscStateData%q_minus1.', ErrStat, ErrMsg,'UnsteadyAero_CopyDiscState')
         RETURN
      END IF
   END IF
   DstDiscStateData%q_minus1 = SrcDiscStateData%q_minus1
ENDIF
IF (ALLOCATED(SrcDiscStateData%q_minus2)) THEN
   i1_l = LBOUND(SrcDiscStateData%q_minus2,1)
   i1_u = UBOUND(SrcDiscStateData%q_minus2,1)
   i2_l = LBOUND(SrcDiscStateData%q_minus2,2)
   i2_u = UBOUND(SrcDiscStateData%q_minus2,2)
   IF (.NOT. ALLOCATED(DstDiscStateData%q_minus2)) THEN 
      ALLOCATE(DstDiscStateData%q_minus2(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstDiscStateData%q_minus2.', ErrStat, ErrMsg,'UnsteadyAero_CopyDiscState')
         RETURN
      END IF
   END IF
   DstDiscStateData%q_minus2 = SrcDiscStateData%q_minus2
ENDIF
IF (ALLOCATED(SrcDiscStateData%X1_minus1)) THEN
   i1_l = LBOUND(SrcDiscStateData%X1_minus1,1)
   i1_u = UBOUND(SrcDiscStateData%X1_minus1,1)
   i2_l = LBOUND(SrcDiscStateData%X1_minus1,2)
   i2_u = UBOUND(SrcDiscStateData%X1_minus1,2)
   IF (.NOT. ALLOCATED(DstDiscStateData%X1_minus1)) THEN 
      ALLOCATE(DstDiscStateData%X1_minus1(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstDiscStateData%X1_minus1.', ErrStat, ErrMsg,'UnsteadyAero_CopyDiscState')
         RETURN
      END IF
   END IF
   DstDiscStateData%X1_minus1 = SrcDiscStateData%X1_minus1
ENDIF
IF (ALLOCATED(SrcDiscStateData%X2_minus1)) THEN
   i1_l = LBOUND(SrcDiscStateData%X2_minus1,1)
   i1_u = UBOUND(SrcDiscStateData%X2_minus1,1)
   i2_l = LBOUND(SrcDiscStateData%X2_minus1,2)
   i2_u = UBOUND(SrcDiscStateData%X2_minus1,2)
   IF (.NOT. ALLOCATED(DstDiscStateData%X2_minus1)) THEN 
      ALLOCATE(DstDiscStateData%X2_minus1(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstDiscStateData%X2_minus1.', ErrStat, ErrMsg,'UnsteadyAero_CopyDiscState')
         RETURN
      END IF
   END IF
   DstDiscStateData%X2_minus1 = SrcDiscStateData%X2_minus1
ENDIF
IF (ALLOCATED(SrcDiscStateData%Kprime_alpha_minus1)) THEN
   i1_l = LBOUND(SrcDiscStateData%Kprime_alpha_minus1,1)
   i1_u = UBOUND(SrcDiscStateData%Kprime_alpha_minus1,1)
   i2_l = LBOUND(SrcDiscStateData%Kprime_alpha_minus1,2)
   i2_u = UBOUND(SrcDiscStateData%Kprime_alpha_minus1,2)
   IF (.NOT. ALLOCATED(DstDiscStateData%Kprime_alpha_minus1)) THEN 
      ALLOCATE(DstDiscStateData%Kprime_alpha_minus1(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstDiscStateData%Kprime_alpha_minus1.', ErrStat, ErrMsg,'UnsteadyAero_CopyDiscState')
         RETURN
      END IF
   END IF
   DstDiscStateData%Kprime_alpha_minus1 = SrcDiscStateData%Kprime_alpha_minus1
ENDIF
IF (ALLOCATED(SrcDiscStateData%Kprime_q_minus1)) THEN
   i1_l = LBOUND(SrcDiscStateData%Kprime_q_minus1,1)
   i1_u = UBOUND(SrcDiscStateData%Kprime_q_minus1,1)
   i2_l = LBOUND(SrcDiscStateData%Kprime_q_minus1,2)
   i2_u = UBOUND(SrcDiscStateData%Kprime_q_minus1,2)
   IF (.NOT. ALLOCATED(DstDiscStateData%Kprime_q_minus1)) THEN 
      ALLOCATE(DstDiscStateData%Kprime_q_minus1(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstDiscStateData%Kprime_q_minus1.', ErrStat, ErrMsg,'UnsteadyAero_CopyDiscState')
         RETURN
      END IF
   END IF
   DstDiscStateData%Kprime_q_minus1 = SrcDiscStateData%Kprime_q_minus1
ENDIF
IF (ALLOCATED(SrcDiscStateData%Dp_minus1)) THEN
   i1_l = LBOUND(SrcDiscStateData%Dp_minus1,1)
   i1_u = UBOUND(SrcDiscStateData%Dp_minus1,1)
   i2_l = LBOUND(SrcDiscStateData%Dp_minus1,2)
   i2_u = UBOUND(SrcDiscStateData%Dp_minus1,2)
   IF (.NOT. ALLOCATED(DstDiscStateData%Dp_minus1)) THEN 
      ALLOCATE(DstDiscStateData%Dp_minus1(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstDiscStateData%Dp_minus1.', ErrStat, ErrMsg,'UnsteadyAero_CopyDiscState')
         RETURN
      END IF
   END IF
   DstDiscStateData%Dp_minus1 = SrcDiscStateData%Dp_minus1
ENDIF
IF (ALLOCATED(SrcDiscStateData%Cn_pot_minus1)) THEN
   i1_l = LBOUND(SrcDiscStateData%Cn_pot_minus1,1)
   i1_u = UBOUND(SrcDiscStateData%Cn_pot_minus1,1)
   i2_l = LBOUND(SrcDiscStateData%Cn_pot_minus1,2)
   i2_u = UBOUND(SrcDiscStateData%Cn_pot_minus1,2)
   IF (.NOT. ALLOCATED(DstDiscStateData%Cn_pot_minus1)) THEN 
      ALLOCATE(DstDiscStateData%Cn_pot_minus1(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstDiscStateData%Cn_pot_minus1.', ErrStat, ErrMsg,'UnsteadyAero_CopyDiscState')
         RETURN
      END IF
   END IF
   DstDiscStateData%Cn_pot_minus1 = SrcDiscStateData%Cn_pot_minus1
ENDIF
IF (ALLOCATED(SrcDiscStateData%T_f)) THEN
   i1_l = LBOUND(SrcDiscStateData%T_f,1)
   i1_u = UBOUND(SrcDiscStateData%T_f,1)
   i2_l = LBOUND(SrcDiscStateData%T_f,2)
   i2_u = UBOUND(SrcDiscStateData%T_f,2)
   IF (.NOT. ALLOCATED(DstDiscStateData%T_f)) THEN 
      ALLOCATE(DstDiscStateData%T_f(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstDiscStateData%T_f.', ErrStat, ErrMsg,'UnsteadyAero_CopyDiscState')
         RETURN
      END IF
   END IF
   DstDiscStateData%T_f = SrcDiscStateData%T_f
ENDIF
IF (ALLOCATED(SrcDiscStateData%fprimeprime_minus1)) THEN
   i1_l = LBOUND(SrcDiscStateData%fprimeprime_minus1,1)
   i1_u = UBOUND(SrcDiscStateData%fprimeprime_minus1,1)
   i2_l = LBOUND(SrcDiscStateData%fprimeprime_minus1,2)
   i2_u = UBOUND(SrcDiscStateData%fprimeprime_minus1,2)
   IF (.NOT. ALLOCATED(DstDiscStateData%fprimeprime_minus1)) THEN 
      ALLOCATE(DstDiscStateData%fprimeprime_minus1(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstDiscStateData%fprimeprime_minus1.', ErrStat, ErrMsg,'UnsteadyAero_CopyDiscState')
         RETURN
      END IF
   END IF
   DstDiscStateData%fprimeprime_minus1 = SrcDiscStateData%fprimeprime_minus1
ENDIF
IF (ALLOCATED(SrcDiscStateData%Df_minus1)) THEN
   i1_l = LBOUND(SrcDiscStateData%Df_minus1,1)
   i1_u = UBOUND(SrcDiscStateData%Df_minus1,1)
   i2_l = LBOUND(SrcDiscStateData%Df_minus1,2)
   i2_u = UBOUND(SrcDiscStateData%Df_minus1,2)
   IF (.NOT. ALLOCATED(DstDiscStateData%Df_minus1)) THEN 
      ALLOCATE(DstDiscStateData%Df_minus1(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstDiscStateData%Df_minus1.', ErrStat, ErrMsg,'UnsteadyAero_CopyDiscState')
         RETURN
      END IF
   END IF
   DstDiscStateData%Df_minus1 = SrcDiscStateData%Df_minus1
ENDIF
IF (ALLOCATED(SrcDiscStateData%fprime_minus1)) THEN
   i1_l = LBOUND(SrcDiscStateData%fprime_minus1,1)
   i1_u = UBOUND(SrcDiscStateData%fprime_minus1,1)
   i2_l = LBOUND(SrcDiscStateData%fprime_minus1,2)
   i2_u = UBOUND(SrcDiscStateData%fprime_minus1,2)
   IF (.NOT. ALLOCATED(DstDiscStateData%fprime_minus1)) THEN 
      ALLOCATE(DstDiscStateData%fprime_minus1(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstDiscStateData%fprime_minus1.', ErrStat, ErrMsg,'UnsteadyAero_CopyDiscState')
         RETURN
      END IF
   END IF
   DstDiscStateData%fprime_minus1 = SrcDiscStateData%fprime_minus1
ENDIF
IF (ALLOCATED(SrcDiscStateData%tau_V)) THEN
   i1_l = LBOUND(SrcDiscStateData%tau_V,1)
   i1_u = UBOUND(SrcDiscStateData%tau_V,1)
   i2_l = LBOUND(SrcDiscStateData%tau_V,2)
   i2_u = UBOUND(SrcDiscStateData%tau_V,2)
   IF (.NOT. ALLOCATED(DstDiscStateData%tau_V)) THEN 
      ALLOCATE(DstDiscStateData%tau_V(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstDiscStateData%tau_V.', ErrStat, ErrMsg,'UnsteadyAero_CopyDiscState')
         RETURN
      END IF
   END IF
   DstDiscStateData%tau_V = SrcDiscStateData%tau_V
ENDIF
IF (ALLOCATED(SrcDiscStateData%Cn_v_minus1)) THEN
   i1_l = LBOUND(SrcDiscStateData%Cn_v_minus1,1)
   i1_u = UBOUND(SrcDiscStateData%Cn_v_minus1,1)
   i2_l = LBOUND(SrcDiscStateData%Cn_v_minus1,2)
   i2_u = UBOUND(SrcDiscStateData%Cn_v_minus1,2)
   IF (.NOT. ALLOCATED(DstDiscStateData%Cn_v_minus1)) THEN 
      ALLOCATE(DstDiscStateData%Cn_v_minus1(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstDiscStateData%Cn_v_minus1.', ErrStat, ErrMsg,'UnsteadyAero_CopyDiscState')
         RETURN
      END IF
   END IF
   DstDiscStateData%Cn_v_minus1 = SrcDiscStateData%Cn_v_minus1
ENDIF
IF (ALLOCATED(SrcDiscStateData%C_V_minus1)) THEN
   i1_l = LBOUND(SrcDiscStateData%C_V_minus1,1)
   i1_u = UBOUND(SrcDiscStateData%C_V_minus1,1)
   i2_l = LBOUND(SrcDiscStateData%C_V_minus1,2)
   i2_u = UBOUND(SrcDiscStateData%C_V_minus1,2)
   IF (.NOT. ALLOCATED(DstDiscStateData%C_V_minus1)) THEN 
      ALLOCATE(DstDiscStateData%C_V_minus1(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstDiscStateData%C_V_minus1.', ErrStat, ErrMsg,'UnsteadyAero_CopyDiscState')
         RETURN
      END IF
   END IF
   DstDiscStateData%C_V_minus1 = SrcDiscStateData%C_V_minus1
ENDIF
 END SUBROUTINE UnsteadyAero_CopyDiscState

 SUBROUTINE UnsteadyAero_DestroyDiscState( DiscStateData, ErrStat, ErrMsg )
  TYPE(UnsteadyAero_DiscreteStateType), INTENT(INOUT) :: DiscStateData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
IF (ALLOCATED(DiscStateData%alpha_minus1)) THEN
   DEALLOCATE(DiscStateData%alpha_minus1)
ENDIF
IF (ALLOCATED(DiscStateData%alpha_minus2)) THEN
   DEALLOCATE(DiscStateData%alpha_minus2)
ENDIF
IF (ALLOCATED(DiscStateData%q_minus1)) THEN
   DEALLOCATE(DiscStateData%q_minus1)
ENDIF
IF (ALLOCATED(DiscStateData%q_minus2)) THEN
   DEALLOCATE(DiscStateData%q_minus2)
ENDIF
IF (ALLOCATED(DiscStateData%X1_minus1)) THEN
   DEALLOCATE(DiscStateData%X1_minus1)
ENDIF
IF (ALLOCATED(DiscStateData%X2_minus1)) THEN
   DEALLOCATE(DiscStateData%X2_minus1)
ENDIF
IF (ALLOCATED(DiscStateData%Kprime_alpha_minus1)) THEN
   DEALLOCATE(DiscStateData%Kprime_alpha_minus1)
ENDIF
IF (ALLOCATED(DiscStateData%Kprime_q_minus1)) THEN
   DEALLOCATE(DiscStateData%Kprime_q_minus1)
ENDIF
IF (ALLOCATED(DiscStateData%Dp_minus1)) THEN
   DEALLOCATE(DiscStateData%Dp_minus1)
ENDIF
IF (ALLOCATED(DiscStateData%Cn_pot_minus1)) THEN
   DEALLOCATE(DiscStateData%Cn_pot_minus1)
ENDIF
IF (ALLOCATED(DiscStateData%T_f)) THEN
   DEALLOCATE(DiscStateData%T_f)
ENDIF
IF (ALLOCATED(DiscStateData%fprimeprime_minus1)) THEN
   DEALLOCATE(DiscStateData%fprimeprime_minus1)
ENDIF
IF (ALLOCATED(DiscStateData%Df_minus1)) THEN
   DEALLOCATE(DiscStateData%Df_minus1)
ENDIF
IF (ALLOCATED(DiscStateData%fprime_minus1)) THEN
   DEALLOCATE(DiscStateData%fprime_minus1)
ENDIF
IF (ALLOCATED(DiscStateData%tau_V)) THEN
   DEALLOCATE(DiscStateData%tau_V)
ENDIF
IF (ALLOCATED(DiscStateData%Cn_v_minus1)) THEN
   DEALLOCATE(DiscStateData%Cn_v_minus1)
ENDIF
IF (ALLOCATED(DiscStateData%C_V_minus1)) THEN
   DEALLOCATE(DiscStateData%C_V_minus1)
ENDIF
 END SUBROUTINE UnsteadyAero_DestroyDiscState

 SUBROUTINE UnsteadyAero_PackDiscState( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(UnsteadyAero_DiscreteStateType),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  IF ( ALLOCATED(InData%alpha_minus1) )   Re_BufSz    = Re_BufSz    + SIZE( InData%alpha_minus1 )  ! alpha_minus1 
  IF ( ALLOCATED(InData%alpha_minus2) )   Re_BufSz    = Re_BufSz    + SIZE( InData%alpha_minus2 )  ! alpha_minus2 
  IF ( ALLOCATED(InData%q_minus1) )   Re_BufSz    = Re_BufSz    + SIZE( InData%q_minus1 )  ! q_minus1 
  IF ( ALLOCATED(InData%q_minus2) )   Re_BufSz    = Re_BufSz    + SIZE( InData%q_minus2 )  ! q_minus2 
  IF ( ALLOCATED(InData%X1_minus1) )   Re_BufSz    = Re_BufSz    + SIZE( InData%X1_minus1 )  ! X1_minus1 
  IF ( ALLOCATED(InData%X2_minus1) )   Re_BufSz    = Re_BufSz    + SIZE( InData%X2_minus1 )  ! X2_minus1 
  IF ( ALLOCATED(InData%Kprime_alpha_minus1) )   Re_BufSz    = Re_BufSz    + SIZE( InData%Kprime_alpha_minus1 )  ! Kprime_alpha_minus1 
  IF ( ALLOCATED(InData%Kprime_q_minus1) )   Re_BufSz    = Re_BufSz    + SIZE( InData%Kprime_q_minus1 )  ! Kprime_q_minus1 
  IF ( ALLOCATED(InData%Dp_minus1) )   Re_BufSz    = Re_BufSz    + SIZE( InData%Dp_minus1 )  ! Dp_minus1 
  IF ( ALLOCATED(InData%Cn_pot_minus1) )   Re_BufSz    = Re_BufSz    + SIZE( InData%Cn_pot_minus1 )  ! Cn_pot_minus1 
  IF ( ALLOCATED(InData%T_f) )   Re_BufSz    = Re_BufSz    + SIZE( InData%T_f )  ! T_f 
  IF ( ALLOCATED(InData%fprimeprime_minus1) )   Re_BufSz    = Re_BufSz    + SIZE( InData%fprimeprime_minus1 )  ! fprimeprime_minus1 
  IF ( ALLOCATED(InData%Df_minus1) )   Re_BufSz    = Re_BufSz    + SIZE( InData%Df_minus1 )  ! Df_minus1 
  IF ( ALLOCATED(InData%fprime_minus1) )   Re_BufSz    = Re_BufSz    + SIZE( InData%fprime_minus1 )  ! fprime_minus1 
  IF ( ALLOCATED(InData%tau_V) )   Re_BufSz    = Re_BufSz    + SIZE( InData%tau_V )  ! tau_V 
  IF ( ALLOCATED(InData%Cn_v_minus1) )   Re_BufSz    = Re_BufSz    + SIZE( InData%Cn_v_minus1 )  ! Cn_v_minus1 
  IF ( ALLOCATED(InData%C_V_minus1) )   Re_BufSz    = Re_BufSz    + SIZE( InData%C_V_minus1 )  ! C_V_minus1 
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  IF ( ALLOCATED(InData%alpha_minus1) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%alpha_minus1))-1 ) =  PACK(InData%alpha_minus1 ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%alpha_minus1)
  ENDIF
  IF ( ALLOCATED(InData%alpha_minus2) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%alpha_minus2))-1 ) =  PACK(InData%alpha_minus2 ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%alpha_minus2)
  ENDIF
  IF ( ALLOCATED(InData%q_minus1) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%q_minus1))-1 ) =  PACK(InData%q_minus1 ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%q_minus1)
  ENDIF
  IF ( ALLOCATED(InData%q_minus2) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%q_minus2))-1 ) =  PACK(InData%q_minus2 ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%q_minus2)
  ENDIF
  IF ( ALLOCATED(InData%X1_minus1) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%X1_minus1))-1 ) =  PACK(InData%X1_minus1 ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%X1_minus1)
  ENDIF
  IF ( ALLOCATED(InData%X2_minus1) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%X2_minus1))-1 ) =  PACK(InData%X2_minus1 ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%X2_minus1)
  ENDIF
  IF ( ALLOCATED(InData%Kprime_alpha_minus1) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%Kprime_alpha_minus1))-1 ) =  PACK(InData%Kprime_alpha_minus1 ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%Kprime_alpha_minus1)
  ENDIF
  IF ( ALLOCATED(InData%Kprime_q_minus1) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%Kprime_q_minus1))-1 ) =  PACK(InData%Kprime_q_minus1 ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%Kprime_q_minus1)
  ENDIF
  IF ( ALLOCATED(InData%Dp_minus1) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%Dp_minus1))-1 ) =  PACK(InData%Dp_minus1 ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%Dp_minus1)
  ENDIF
  IF ( ALLOCATED(InData%Cn_pot_minus1) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%Cn_pot_minus1))-1 ) =  PACK(InData%Cn_pot_minus1 ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%Cn_pot_minus1)
  ENDIF
  IF ( ALLOCATED(InData%T_f) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%T_f))-1 ) =  PACK(InData%T_f ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%T_f)
  ENDIF
  IF ( ALLOCATED(InData%fprimeprime_minus1) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%fprimeprime_minus1))-1 ) =  PACK(InData%fprimeprime_minus1 ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%fprimeprime_minus1)
  ENDIF
  IF ( ALLOCATED(InData%Df_minus1) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%Df_minus1))-1 ) =  PACK(InData%Df_minus1 ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%Df_minus1)
  ENDIF
  IF ( ALLOCATED(InData%fprime_minus1) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%fprime_minus1))-1 ) =  PACK(InData%fprime_minus1 ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%fprime_minus1)
  ENDIF
  IF ( ALLOCATED(InData%tau_V) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%tau_V))-1 ) =  PACK(InData%tau_V ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%tau_V)
  ENDIF
  IF ( ALLOCATED(InData%Cn_v_minus1) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%Cn_v_minus1))-1 ) =  PACK(InData%Cn_v_minus1 ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%Cn_v_minus1)
  ENDIF
  IF ( ALLOCATED(InData%C_V_minus1) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%C_V_minus1))-1 ) =  PACK(InData%C_V_minus1 ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%C_V_minus1)
  ENDIF
 END SUBROUTINE UnsteadyAero_PackDiscState

 SUBROUTINE UnsteadyAero_UnPackDiscState( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(UnsteadyAero_DiscreteStateType), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  IF ( ALLOCATED(OutData%alpha_minus1) ) THEN
  ALLOCATE(mask2(SIZE(OutData%alpha_minus1,1),SIZE(OutData%alpha_minus1,2)))
  mask2 = .TRUE.
    OutData%alpha_minus1 = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%alpha_minus1))-1 ),mask2,OutData%alpha_minus1)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%alpha_minus1)
  ENDIF
  IF ( ALLOCATED(OutData%alpha_minus2) ) THEN
  ALLOCATE(mask2(SIZE(OutData%alpha_minus2,1),SIZE(OutData%alpha_minus2,2)))
  mask2 = .TRUE.
    OutData%alpha_minus2 = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%alpha_minus2))-1 ),mask2,OutData%alpha_minus2)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%alpha_minus2)
  ENDIF
  IF ( ALLOCATED(OutData%q_minus1) ) THEN
  ALLOCATE(mask2(SIZE(OutData%q_minus1,1),SIZE(OutData%q_minus1,2)))
  mask2 = .TRUE.
    OutData%q_minus1 = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%q_minus1))-1 ),mask2,OutData%q_minus1)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%q_minus1)
  ENDIF
  IF ( ALLOCATED(OutData%q_minus2) ) THEN
  ALLOCATE(mask2(SIZE(OutData%q_minus2,1),SIZE(OutData%q_minus2,2)))
  mask2 = .TRUE.
    OutData%q_minus2 = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%q_minus2))-1 ),mask2,OutData%q_minus2)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%q_minus2)
  ENDIF
  IF ( ALLOCATED(OutData%X1_minus1) ) THEN
  ALLOCATE(mask2(SIZE(OutData%X1_minus1,1),SIZE(OutData%X1_minus1,2)))
  mask2 = .TRUE.
    OutData%X1_minus1 = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%X1_minus1))-1 ),mask2,OutData%X1_minus1)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%X1_minus1)
  ENDIF
  IF ( ALLOCATED(OutData%X2_minus1) ) THEN
  ALLOCATE(mask2(SIZE(OutData%X2_minus1,1),SIZE(OutData%X2_minus1,2)))
  mask2 = .TRUE.
    OutData%X2_minus1 = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%X2_minus1))-1 ),mask2,OutData%X2_minus1)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%X2_minus1)
  ENDIF
  IF ( ALLOCATED(OutData%Kprime_alpha_minus1) ) THEN
  ALLOCATE(mask2(SIZE(OutData%Kprime_alpha_minus1,1),SIZE(OutData%Kprime_alpha_minus1,2)))
  mask2 = .TRUE.
    OutData%Kprime_alpha_minus1 = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%Kprime_alpha_minus1))-1 ),mask2,OutData%Kprime_alpha_minus1)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%Kprime_alpha_minus1)
  ENDIF
  IF ( ALLOCATED(OutData%Kprime_q_minus1) ) THEN
  ALLOCATE(mask2(SIZE(OutData%Kprime_q_minus1,1),SIZE(OutData%Kprime_q_minus1,2)))
  mask2 = .TRUE.
    OutData%Kprime_q_minus1 = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%Kprime_q_minus1))-1 ),mask2,OutData%Kprime_q_minus1)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%Kprime_q_minus1)
  ENDIF
  IF ( ALLOCATED(OutData%Dp_minus1) ) THEN
  ALLOCATE(mask2(SIZE(OutData%Dp_minus1,1),SIZE(OutData%Dp_minus1,2)))
  mask2 = .TRUE.
    OutData%Dp_minus1 = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%Dp_minus1))-1 ),mask2,OutData%Dp_minus1)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%Dp_minus1)
  ENDIF
  IF ( ALLOCATED(OutData%Cn_pot_minus1) ) THEN
  ALLOCATE(mask2(SIZE(OutData%Cn_pot_minus1,1),SIZE(OutData%Cn_pot_minus1,2)))
  mask2 = .TRUE.
    OutData%Cn_pot_minus1 = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%Cn_pot_minus1))-1 ),mask2,OutData%Cn_pot_minus1)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%Cn_pot_minus1)
  ENDIF
  IF ( ALLOCATED(OutData%T_f) ) THEN
  ALLOCATE(mask2(SIZE(OutData%T_f,1),SIZE(OutData%T_f,2)))
  mask2 = .TRUE.
    OutData%T_f = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%T_f))-1 ),mask2,OutData%T_f)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%T_f)
  ENDIF
  IF ( ALLOCATED(OutData%fprimeprime_minus1) ) THEN
  ALLOCATE(mask2(SIZE(OutData%fprimeprime_minus1,1),SIZE(OutData%fprimeprime_minus1,2)))
  mask2 = .TRUE.
    OutData%fprimeprime_minus1 = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%fprimeprime_minus1))-1 ),mask2,OutData%fprimeprime_minus1)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%fprimeprime_minus1)
  ENDIF
  IF ( ALLOCATED(OutData%Df_minus1) ) THEN
  ALLOCATE(mask2(SIZE(OutData%Df_minus1,1),SIZE(OutData%Df_minus1,2)))
  mask2 = .TRUE.
    OutData%Df_minus1 = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%Df_minus1))-1 ),mask2,OutData%Df_minus1)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%Df_minus1)
  ENDIF
  IF ( ALLOCATED(OutData%fprime_minus1) ) THEN
  ALLOCATE(mask2(SIZE(OutData%fprime_minus1,1),SIZE(OutData%fprime_minus1,2)))
  mask2 = .TRUE.
    OutData%fprime_minus1 = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%fprime_minus1))-1 ),mask2,OutData%fprime_minus1)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%fprime_minus1)
  ENDIF
  IF ( ALLOCATED(OutData%tau_V) ) THEN
  ALLOCATE(mask2(SIZE(OutData%tau_V,1),SIZE(OutData%tau_V,2)))
  mask2 = .TRUE.
    OutData%tau_V = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%tau_V))-1 ),mask2,OutData%tau_V)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%tau_V)
  ENDIF
  IF ( ALLOCATED(OutData%Cn_v_minus1) ) THEN
  ALLOCATE(mask2(SIZE(OutData%Cn_v_minus1,1),SIZE(OutData%Cn_v_minus1,2)))
  mask2 = .TRUE.
    OutData%Cn_v_minus1 = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%Cn_v_minus1))-1 ),mask2,OutData%Cn_v_minus1)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%Cn_v_minus1)
  ENDIF
  IF ( ALLOCATED(OutData%C_V_minus1) ) THEN
  ALLOCATE(mask2(SIZE(OutData%C_V_minus1,1),SIZE(OutData%C_V_minus1,2)))
  mask2 = .TRUE.
    OutData%C_V_minus1 = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%C_V_minus1))-1 ),mask2,OutData%C_V_minus1)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%C_V_minus1)
  ENDIF
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE UnsteadyAero_UnPackDiscState

 SUBROUTINE UnsteadyAero_CopyConstrState( SrcConstrStateData, DstConstrStateData, CtrlCode, ErrStat, ErrMsg )
   TYPE(UnsteadyAero_ConstraintStateType), INTENT(IN) :: SrcConstrStateData
   TYPE(UnsteadyAero_ConstraintStateType), INTENT(INOUT) :: DstConstrStateData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: i2, i2_l, i2_u  !  bounds (upper/lower) for an array dimension 2
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(1024)                :: ErrMsg2
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
   DstConstrStateData%DummyConstraintState = SrcConstrStateData%DummyConstraintState
 END SUBROUTINE UnsteadyAero_CopyConstrState

 SUBROUTINE UnsteadyAero_DestroyConstrState( ConstrStateData, ErrStat, ErrMsg )
  TYPE(UnsteadyAero_ConstraintStateType), INTENT(INOUT) :: ConstrStateData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
 END SUBROUTINE UnsteadyAero_DestroyConstrState

 SUBROUTINE UnsteadyAero_PackConstrState( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(UnsteadyAero_ConstraintStateType),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  Re_BufSz   = Re_BufSz   + 1  ! DummyConstraintState
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%DummyConstraintState )
  Re_Xferred   = Re_Xferred   + 1
 END SUBROUTINE UnsteadyAero_PackConstrState

 SUBROUTINE UnsteadyAero_UnPackConstrState( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(UnsteadyAero_ConstraintStateType), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  OutData%DummyConstraintState = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE UnsteadyAero_UnPackConstrState

 SUBROUTINE UnsteadyAero_CopyOtherState( SrcOtherStateData, DstOtherStateData, CtrlCode, ErrStat, ErrMsg )
   TYPE(UnsteadyAero_OtherStateType), INTENT(IN) :: SrcOtherStateData
   TYPE(UnsteadyAero_OtherStateType), INTENT(INOUT) :: DstOtherStateData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: i2, i2_l, i2_u  !  bounds (upper/lower) for an array dimension 2
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(1024)                :: ErrMsg2
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
IF (ALLOCATED(SrcOtherStateData%sigma1)) THEN
   i1_l = LBOUND(SrcOtherStateData%sigma1,1)
   i1_u = UBOUND(SrcOtherStateData%sigma1,1)
   i2_l = LBOUND(SrcOtherStateData%sigma1,2)
   i2_u = UBOUND(SrcOtherStateData%sigma1,2)
   IF (.NOT. ALLOCATED(DstOtherStateData%sigma1)) THEN 
      ALLOCATE(DstOtherStateData%sigma1(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstOtherStateData%sigma1.', ErrStat, ErrMsg,'UnsteadyAero_CopyOtherState')
         RETURN
      END IF
   END IF
   DstOtherStateData%sigma1 = SrcOtherStateData%sigma1
ENDIF
IF (ALLOCATED(SrcOtherStateData%sigma3)) THEN
   i1_l = LBOUND(SrcOtherStateData%sigma3,1)
   i1_u = UBOUND(SrcOtherStateData%sigma3,1)
   i2_l = LBOUND(SrcOtherStateData%sigma3,2)
   i2_u = UBOUND(SrcOtherStateData%sigma3,2)
   IF (.NOT. ALLOCATED(DstOtherStateData%sigma3)) THEN 
      ALLOCATE(DstOtherStateData%sigma3(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstOtherStateData%sigma3.', ErrStat, ErrMsg,'UnsteadyAero_CopyOtherState')
         RETURN
      END IF
   END IF
   DstOtherStateData%sigma3 = SrcOtherStateData%sigma3
ENDIF
IF (ALLOCATED(SrcOtherStateData%TESF)) THEN
   i1_l = LBOUND(SrcOtherStateData%TESF,1)
   i1_u = UBOUND(SrcOtherStateData%TESF,1)
   i2_l = LBOUND(SrcOtherStateData%TESF,2)
   i2_u = UBOUND(SrcOtherStateData%TESF,2)
   IF (.NOT. ALLOCATED(DstOtherStateData%TESF)) THEN 
      ALLOCATE(DstOtherStateData%TESF(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstOtherStateData%TESF.', ErrStat, ErrMsg,'UnsteadyAero_CopyOtherState')
         RETURN
      END IF
   END IF
   DstOtherStateData%TESF = SrcOtherStateData%TESF
ENDIF
IF (ALLOCATED(SrcOtherStateData%LESF)) THEN
   i1_l = LBOUND(SrcOtherStateData%LESF,1)
   i1_u = UBOUND(SrcOtherStateData%LESF,1)
   i2_l = LBOUND(SrcOtherStateData%LESF,2)
   i2_u = UBOUND(SrcOtherStateData%LESF,2)
   IF (.NOT. ALLOCATED(DstOtherStateData%LESF)) THEN 
      ALLOCATE(DstOtherStateData%LESF(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstOtherStateData%LESF.', ErrStat, ErrMsg,'UnsteadyAero_CopyOtherState')
         RETURN
      END IF
   END IF
   DstOtherStateData%LESF = SrcOtherStateData%LESF
ENDIF
IF (ALLOCATED(SrcOtherStateData%VRTX)) THEN
   i1_l = LBOUND(SrcOtherStateData%VRTX,1)
   i1_u = UBOUND(SrcOtherStateData%VRTX,1)
   i2_l = LBOUND(SrcOtherStateData%VRTX,2)
   i2_u = UBOUND(SrcOtherStateData%VRTX,2)
   IF (.NOT. ALLOCATED(DstOtherStateData%VRTX)) THEN 
      ALLOCATE(DstOtherStateData%VRTX(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstOtherStateData%VRTX.', ErrStat, ErrMsg,'UnsteadyAero_CopyOtherState')
         RETURN
      END IF
   END IF
   DstOtherStateData%VRTX = SrcOtherStateData%VRTX
ENDIF
   DstOtherStateData%FirstPass = SrcOtherStateData%FirstPass
 END SUBROUTINE UnsteadyAero_CopyOtherState

 SUBROUTINE UnsteadyAero_DestroyOtherState( OtherStateData, ErrStat, ErrMsg )
  TYPE(UnsteadyAero_OtherStateType), INTENT(INOUT) :: OtherStateData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
IF (ALLOCATED(OtherStateData%sigma1)) THEN
   DEALLOCATE(OtherStateData%sigma1)
ENDIF
IF (ALLOCATED(OtherStateData%sigma3)) THEN
   DEALLOCATE(OtherStateData%sigma3)
ENDIF
IF (ALLOCATED(OtherStateData%TESF)) THEN
   DEALLOCATE(OtherStateData%TESF)
ENDIF
IF (ALLOCATED(OtherStateData%LESF)) THEN
   DEALLOCATE(OtherStateData%LESF)
ENDIF
IF (ALLOCATED(OtherStateData%VRTX)) THEN
   DEALLOCATE(OtherStateData%VRTX)
ENDIF
 END SUBROUTINE UnsteadyAero_DestroyOtherState

 SUBROUTINE UnsteadyAero_PackOtherState( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(UnsteadyAero_OtherStateType),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  IF ( ALLOCATED(InData%sigma1) )   Re_BufSz    = Re_BufSz    + SIZE( InData%sigma1 )  ! sigma1 
  IF ( ALLOCATED(InData%sigma3) )   Re_BufSz    = Re_BufSz    + SIZE( InData%sigma3 )  ! sigma3 
  IF ( ALLOCATED(InData%TESF) )   Int_BufSz   = Int_BufSz   + SIZE( InData%TESF )  ! TESF 
  IF ( ALLOCATED(InData%LESF) )   Int_BufSz   = Int_BufSz   + SIZE( InData%LESF )  ! LESF 
  IF ( ALLOCATED(InData%VRTX) )   Int_BufSz   = Int_BufSz   + SIZE( InData%VRTX )  ! VRTX 
  Int_BufSz  = Int_BufSz  + 1  ! FirstPass
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  IF ( ALLOCATED(InData%sigma1) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%sigma1))-1 ) =  PACK(InData%sigma1 ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%sigma1)
  ENDIF
  IF ( ALLOCATED(InData%sigma3) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%sigma3))-1 ) =  PACK(InData%sigma3 ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%sigma3)
  ENDIF
  IF ( ALLOCATED(InData%TESF) ) THEN
    IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(SIZE(InData%TESF))-1 ) = TRANSFER( PACK(InData%TESF ,.TRUE.), IntKiBuf(1), 1)
    Int_Xferred   = Int_Xferred   + SIZE(InData%TESF)
  ENDIF
  IF ( ALLOCATED(InData%LESF) ) THEN
    IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(SIZE(InData%LESF))-1 ) = TRANSFER( PACK(InData%LESF ,.TRUE.), IntKiBuf(1), 1)
    Int_Xferred   = Int_Xferred   + SIZE(InData%LESF)
  ENDIF
  IF ( ALLOCATED(InData%VRTX) ) THEN
    IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(SIZE(InData%VRTX))-1 ) = TRANSFER( PACK(InData%VRTX ,.TRUE.), IntKiBuf(1), 1)
    Int_Xferred   = Int_Xferred   + SIZE(InData%VRTX)
  ENDIF
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = TRANSFER( (InData%FirstPass ), IntKiBuf(1), 1)
  Int_Xferred   = Int_Xferred   + 1
 END SUBROUTINE UnsteadyAero_PackOtherState

 SUBROUTINE UnsteadyAero_UnPackOtherState( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(UnsteadyAero_OtherStateType), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  IF ( ALLOCATED(OutData%sigma1) ) THEN
  ALLOCATE(mask2(SIZE(OutData%sigma1,1),SIZE(OutData%sigma1,2)))
  mask2 = .TRUE.
    OutData%sigma1 = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%sigma1))-1 ),mask2,OutData%sigma1)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%sigma1)
  ENDIF
  IF ( ALLOCATED(OutData%sigma3) ) THEN
  ALLOCATE(mask2(SIZE(OutData%sigma3,1),SIZE(OutData%sigma3,2)))
  mask2 = .TRUE.
    OutData%sigma3 = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%sigma3))-1 ),mask2,OutData%sigma3)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%sigma3)
  ENDIF
  IF ( ALLOCATED(OutData%TESF) ) THEN
  ENDIF
  IF ( ALLOCATED(OutData%LESF) ) THEN
  ENDIF
  IF ( ALLOCATED(OutData%VRTX) ) THEN
  ENDIF
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE UnsteadyAero_UnPackOtherState

 SUBROUTINE UnsteadyAero_CopyParam( SrcParamData, DstParamData, CtrlCode, ErrStat, ErrMsg )
   TYPE(UnsteadyAero_ParameterType), INTENT(IN) :: SrcParamData
   TYPE(UnsteadyAero_ParameterType), INTENT(INOUT) :: DstParamData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: i2, i2_l, i2_u  !  bounds (upper/lower) for an array dimension 2
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(1024)                :: ErrMsg2
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
   DstParamData%dt = SrcParamData%dt
IF (ALLOCATED(SrcParamData%c)) THEN
   i1_l = LBOUND(SrcParamData%c,1)
   i1_u = UBOUND(SrcParamData%c,1)
   i2_l = LBOUND(SrcParamData%c,2)
   i2_u = UBOUND(SrcParamData%c,2)
   IF (.NOT. ALLOCATED(DstParamData%c)) THEN 
      ALLOCATE(DstParamData%c(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%c.', ErrStat, ErrMsg,'UnsteadyAero_CopyParam')
         RETURN
      END IF
   END IF
   DstParamData%c = SrcParamData%c
ENDIF
   DstParamData%numBlades = SrcParamData%numBlades
   DstParamData%nNodesPerBlade = SrcParamData%nNodesPerBlade
   DstParamData%DSMod = SrcParamData%DSMod
   DstParamData%a_s = SrcParamData%a_s
IF (ALLOCATED(SrcParamData%AFIndx)) THEN
   i1_l = LBOUND(SrcParamData%AFIndx,1)
   i1_u = UBOUND(SrcParamData%AFIndx,1)
   i2_l = LBOUND(SrcParamData%AFIndx,2)
   i2_u = UBOUND(SrcParamData%AFIndx,2)
   IF (.NOT. ALLOCATED(DstParamData%AFIndx)) THEN 
      ALLOCATE(DstParamData%AFIndx(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%AFIndx.', ErrStat, ErrMsg,'UnsteadyAero_CopyParam')
         RETURN
      END IF
   END IF
   DstParamData%AFIndx = SrcParamData%AFIndx
ENDIF
      CALL AFI_CopyParam( SrcParamData%AFI_Params, DstParamData%AFI_Params, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,'UnsteadyAero_CopyParam:AFI_Params')
         IF (ErrStat>=AbortErrLev) RETURN
   DstParamData%NumOuts = SrcParamData%NumOuts
   DstParamData%OutSwtch = SrcParamData%OutSwtch
   DstParamData%OutFmt = SrcParamData%OutFmt
   DstParamData%OutSFmt = SrcParamData%OutSFmt
   DstParamData%Delim = SrcParamData%Delim
   DstParamData%UnOutFile = SrcParamData%UnOutFile
 END SUBROUTINE UnsteadyAero_CopyParam

 SUBROUTINE UnsteadyAero_DestroyParam( ParamData, ErrStat, ErrMsg )
  TYPE(UnsteadyAero_ParameterType), INTENT(INOUT) :: ParamData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
IF (ALLOCATED(ParamData%c)) THEN
   DEALLOCATE(ParamData%c)
ENDIF
IF (ALLOCATED(ParamData%AFIndx)) THEN
   DEALLOCATE(ParamData%AFIndx)
ENDIF
  CALL AFI_DestroyParam( ParamData%AFI_Params, ErrStat, ErrMsg )
 END SUBROUTINE UnsteadyAero_DestroyParam

 SUBROUTINE UnsteadyAero_PackParam( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(UnsteadyAero_ParameterType),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  REAL(ReKi),     ALLOCATABLE :: Re_AFI_Params_Buf(:)
  REAL(DbKi),     ALLOCATABLE :: Db_AFI_Params_Buf(:)
  INTEGER(IntKi), ALLOCATABLE :: Int_AFI_Params_Buf(:)
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  Db_BufSz   = Db_BufSz   + 1  ! dt
  IF ( ALLOCATED(InData%c) )   Re_BufSz    = Re_BufSz    + SIZE( InData%c )  ! c 
  Int_BufSz  = Int_BufSz  + 1  ! numBlades
  Int_BufSz  = Int_BufSz  + 1  ! nNodesPerBlade
  Int_BufSz  = Int_BufSz  + 1  ! DSMod
  Re_BufSz   = Re_BufSz   + 1  ! a_s
  IF ( ALLOCATED(InData%AFIndx) )   Int_BufSz   = Int_BufSz   + SIZE( InData%AFIndx )  ! AFIndx 
  CALL AFI_PackParam( Re_AFI_Params_Buf, Db_AFI_Params_Buf, Int_AFI_Params_Buf, InData%AFI_Params, ErrStat, ErrMsg, .TRUE. ) ! AFI_Params 
  IF(ALLOCATED(Re_AFI_Params_Buf)) Re_BufSz  = Re_BufSz  + SIZE( Re_AFI_Params_Buf  ) ! AFI_Params
  IF(ALLOCATED(Db_AFI_Params_Buf)) Db_BufSz  = Db_BufSz  + SIZE( Db_AFI_Params_Buf  ) ! AFI_Params
  IF(ALLOCATED(Int_AFI_Params_Buf))Int_BufSz = Int_BufSz + SIZE( Int_AFI_Params_Buf ) ! AFI_Params
  IF(ALLOCATED(Re_AFI_Params_Buf))  DEALLOCATE(Re_AFI_Params_Buf)
  IF(ALLOCATED(Db_AFI_Params_Buf))  DEALLOCATE(Db_AFI_Params_Buf)
  IF(ALLOCATED(Int_AFI_Params_Buf)) DEALLOCATE(Int_AFI_Params_Buf)
  Int_BufSz  = Int_BufSz  + 1  ! NumOuts
  Int_BufSz  = Int_BufSz  + 1  ! OutSwtch
!  missing buffer for OutFmt
!  missing buffer for OutSFmt
!  missing buffer for Delim
  Int_BufSz  = Int_BufSz  + 1  ! UnOutFile
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  IF ( .NOT. OnlySize ) DbKiBuf ( Db_Xferred:Db_Xferred+(1)-1 ) =  (InData%dt )
  Db_Xferred   = Db_Xferred   + 1
  IF ( ALLOCATED(InData%c) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%c))-1 ) =  PACK(InData%c ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%c)
  ENDIF
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%numBlades )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%nNodesPerBlade )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%DSMod )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%a_s )
  Re_Xferred   = Re_Xferred   + 1
  IF ( ALLOCATED(InData%AFIndx) ) THEN
    IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(SIZE(InData%AFIndx))-1 ) = PACK(InData%AFIndx ,.TRUE.)
    Int_Xferred   = Int_Xferred   + SIZE(InData%AFIndx)
  ENDIF
  CALL AFI_PackParam( Re_AFI_Params_Buf, Db_AFI_Params_Buf, Int_AFI_Params_Buf, InData%AFI_Params, ErrStat, ErrMsg, OnlySize ) ! AFI_Params 
  IF(ALLOCATED(Re_AFI_Params_Buf)) THEN
    IF ( .NOT. OnlySize ) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_AFI_Params_Buf)-1 ) = Re_AFI_Params_Buf
    Re_Xferred = Re_Xferred + SIZE(Re_AFI_Params_Buf)
  ENDIF
  IF(ALLOCATED(Db_AFI_Params_Buf)) THEN
    IF ( .NOT. OnlySize ) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_AFI_Params_Buf)-1 ) = Db_AFI_Params_Buf
    Db_Xferred = Db_Xferred + SIZE(Db_AFI_Params_Buf)
  ENDIF
  IF(ALLOCATED(Int_AFI_Params_Buf)) THEN
    IF ( .NOT. OnlySize ) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_AFI_Params_Buf)-1 ) = Int_AFI_Params_Buf
    Int_Xferred = Int_Xferred + SIZE(Int_AFI_Params_Buf)
  ENDIF
  IF( ALLOCATED(Re_AFI_Params_Buf) )  DEALLOCATE(Re_AFI_Params_Buf)
  IF( ALLOCATED(Db_AFI_Params_Buf) )  DEALLOCATE(Db_AFI_Params_Buf)
  IF( ALLOCATED(Int_AFI_Params_Buf) ) DEALLOCATE(Int_AFI_Params_Buf)
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%NumOuts )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%OutSwtch )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%UnOutFile )
  Int_Xferred   = Int_Xferred   + 1
 END SUBROUTINE UnsteadyAero_PackParam

 SUBROUTINE UnsteadyAero_UnPackParam( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(UnsteadyAero_ParameterType), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
  REAL(ReKi),    ALLOCATABLE :: Re_AFI_Params_Buf(:)
  REAL(DbKi),    ALLOCATABLE :: Db_AFI_Params_Buf(:)
  INTEGER(IntKi),    ALLOCATABLE :: Int_AFI_Params_Buf(:)
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  OutData%dt = DbKiBuf ( Db_Xferred )
  Db_Xferred   = Db_Xferred   + 1
  IF ( ALLOCATED(OutData%c) ) THEN
  ALLOCATE(mask2(SIZE(OutData%c,1),SIZE(OutData%c,2)))
  mask2 = .TRUE.
    OutData%c = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%c))-1 ),mask2,OutData%c)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%c)
  ENDIF
  OutData%numBlades = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%nNodesPerBlade = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%DSMod = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%a_s = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  IF ( ALLOCATED(OutData%AFIndx) ) THEN
  ALLOCATE(mask2(SIZE(OutData%AFIndx,1),SIZE(OutData%AFIndx,2)))
  mask2 = .TRUE.
    OutData%AFIndx = UNPACK(IntKiBuf( Int_Xferred:Re_Xferred+(SIZE(OutData%AFIndx))-1 ),mask2,OutData%AFIndx)
  DEALLOCATE(mask2)
    Int_Xferred   = Int_Xferred   + SIZE(OutData%AFIndx)
  ENDIF
 ! first call AFI_PackParam to get correctly sized buffers for unpacking
  CALL AFI_PackParam( Re_AFI_Params_Buf, Db_AFI_Params_Buf, Int_AFI_Params_Buf, OutData%AFI_Params, ErrStat, ErrMsg, .TRUE. ) ! AFI_Params 
  IF(ALLOCATED(Re_AFI_Params_Buf)) THEN
    Re_AFI_Params_Buf = ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_AFI_Params_Buf)-1 )
    Re_Xferred = Re_Xferred + SIZE(Re_AFI_Params_Buf)
  ENDIF
  IF(ALLOCATED(Db_AFI_Params_Buf)) THEN
    Db_AFI_Params_Buf = DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_AFI_Params_Buf)-1 )
    Db_Xferred = Db_Xferred + SIZE(Db_AFI_Params_Buf)
  ENDIF
  IF(ALLOCATED(Int_AFI_Params_Buf)) THEN
    Int_AFI_Params_Buf = IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_AFI_Params_Buf)-1 )
    Int_Xferred = Int_Xferred + SIZE(Int_AFI_Params_Buf)
  ENDIF
  CALL AFI_UnPackParam( Re_AFI_Params_Buf, Db_AFI_Params_Buf, Int_AFI_Params_Buf, OutData%AFI_Params, ErrStat, ErrMsg ) ! AFI_Params 
  OutData%NumOuts = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%OutSwtch = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%UnOutFile = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE UnsteadyAero_UnPackParam

 SUBROUTINE UnsteadyAero_CopyInput( SrcInputData, DstInputData, CtrlCode, ErrStat, ErrMsg )
   TYPE(UnsteadyAero_InputType), INTENT(IN) :: SrcInputData
   TYPE(UnsteadyAero_InputType), INTENT(INOUT) :: DstInputData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: i2, i2_l, i2_u  !  bounds (upper/lower) for an array dimension 2
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(1024)                :: ErrMsg2
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
IF (ALLOCATED(SrcInputData%U)) THEN
   i1_l = LBOUND(SrcInputData%U,1)
   i1_u = UBOUND(SrcInputData%U,1)
   i2_l = LBOUND(SrcInputData%U,2)
   i2_u = UBOUND(SrcInputData%U,2)
   IF (.NOT. ALLOCATED(DstInputData%U)) THEN 
      ALLOCATE(DstInputData%U(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInputData%U.', ErrStat, ErrMsg,'UnsteadyAero_CopyInput')
         RETURN
      END IF
   END IF
   DstInputData%U = SrcInputData%U
ENDIF
IF (ALLOCATED(SrcInputData%Re)) THEN
   i1_l = LBOUND(SrcInputData%Re,1)
   i1_u = UBOUND(SrcInputData%Re,1)
   i2_l = LBOUND(SrcInputData%Re,2)
   i2_u = UBOUND(SrcInputData%Re,2)
   IF (.NOT. ALLOCATED(DstInputData%Re)) THEN 
      ALLOCATE(DstInputData%Re(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInputData%Re.', ErrStat, ErrMsg,'UnsteadyAero_CopyInput')
         RETURN
      END IF
   END IF
   DstInputData%Re = SrcInputData%Re
ENDIF
IF (ALLOCATED(SrcInputData%alpha)) THEN
   i1_l = LBOUND(SrcInputData%alpha,1)
   i1_u = UBOUND(SrcInputData%alpha,1)
   i2_l = LBOUND(SrcInputData%alpha,2)
   i2_u = UBOUND(SrcInputData%alpha,2)
   IF (.NOT. ALLOCATED(DstInputData%alpha)) THEN 
      ALLOCATE(DstInputData%alpha(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInputData%alpha.', ErrStat, ErrMsg,'UnsteadyAero_CopyInput')
         RETURN
      END IF
   END IF
   DstInputData%alpha = SrcInputData%alpha
ENDIF
 END SUBROUTINE UnsteadyAero_CopyInput

 SUBROUTINE UnsteadyAero_DestroyInput( InputData, ErrStat, ErrMsg )
  TYPE(UnsteadyAero_InputType), INTENT(INOUT) :: InputData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
IF (ALLOCATED(InputData%U)) THEN
   DEALLOCATE(InputData%U)
ENDIF
IF (ALLOCATED(InputData%Re)) THEN
   DEALLOCATE(InputData%Re)
ENDIF
IF (ALLOCATED(InputData%alpha)) THEN
   DEALLOCATE(InputData%alpha)
ENDIF
 END SUBROUTINE UnsteadyAero_DestroyInput

 SUBROUTINE UnsteadyAero_PackInput( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(UnsteadyAero_InputType),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  IF ( ALLOCATED(InData%U) )   Re_BufSz    = Re_BufSz    + SIZE( InData%U )  ! U 
  IF ( ALLOCATED(InData%Re) )   Re_BufSz    = Re_BufSz    + SIZE( InData%Re )  ! Re 
  IF ( ALLOCATED(InData%alpha) )   Re_BufSz    = Re_BufSz    + SIZE( InData%alpha )  ! alpha 
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  IF ( ALLOCATED(InData%U) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%U))-1 ) =  PACK(InData%U ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%U)
  ENDIF
  IF ( ALLOCATED(InData%Re) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%Re))-1 ) =  PACK(InData%Re ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%Re)
  ENDIF
  IF ( ALLOCATED(InData%alpha) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%alpha))-1 ) =  PACK(InData%alpha ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%alpha)
  ENDIF
 END SUBROUTINE UnsteadyAero_PackInput

 SUBROUTINE UnsteadyAero_UnPackInput( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(UnsteadyAero_InputType), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  IF ( ALLOCATED(OutData%U) ) THEN
  ALLOCATE(mask2(SIZE(OutData%U,1),SIZE(OutData%U,2)))
  mask2 = .TRUE.
    OutData%U = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%U))-1 ),mask2,OutData%U)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%U)
  ENDIF
  IF ( ALLOCATED(OutData%Re) ) THEN
  ALLOCATE(mask2(SIZE(OutData%Re,1),SIZE(OutData%Re,2)))
  mask2 = .TRUE.
    OutData%Re = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%Re))-1 ),mask2,OutData%Re)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%Re)
  ENDIF
  IF ( ALLOCATED(OutData%alpha) ) THEN
  ALLOCATE(mask2(SIZE(OutData%alpha,1),SIZE(OutData%alpha,2)))
  mask2 = .TRUE.
    OutData%alpha = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%alpha))-1 ),mask2,OutData%alpha)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%alpha)
  ENDIF
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE UnsteadyAero_UnPackInput

 SUBROUTINE UnsteadyAero_CopyOutput( SrcOutputData, DstOutputData, CtrlCode, ErrStat, ErrMsg )
   TYPE(UnsteadyAero_OutputType), INTENT(IN) :: SrcOutputData
   TYPE(UnsteadyAero_OutputType), INTENT(INOUT) :: DstOutputData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: i2, i2_l, i2_u  !  bounds (upper/lower) for an array dimension 2
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(1024)                :: ErrMsg2
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
IF (ALLOCATED(SrcOutputData%Cn)) THEN
   i1_l = LBOUND(SrcOutputData%Cn,1)
   i1_u = UBOUND(SrcOutputData%Cn,1)
   i2_l = LBOUND(SrcOutputData%Cn,2)
   i2_u = UBOUND(SrcOutputData%Cn,2)
   IF (.NOT. ALLOCATED(DstOutputData%Cn)) THEN 
      ALLOCATE(DstOutputData%Cn(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstOutputData%Cn.', ErrStat, ErrMsg,'UnsteadyAero_CopyOutput')
         RETURN
      END IF
   END IF
   DstOutputData%Cn = SrcOutputData%Cn
ENDIF
IF (ALLOCATED(SrcOutputData%Cc)) THEN
   i1_l = LBOUND(SrcOutputData%Cc,1)
   i1_u = UBOUND(SrcOutputData%Cc,1)
   i2_l = LBOUND(SrcOutputData%Cc,2)
   i2_u = UBOUND(SrcOutputData%Cc,2)
   IF (.NOT. ALLOCATED(DstOutputData%Cc)) THEN 
      ALLOCATE(DstOutputData%Cc(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstOutputData%Cc.', ErrStat, ErrMsg,'UnsteadyAero_CopyOutput')
         RETURN
      END IF
   END IF
   DstOutputData%Cc = SrcOutputData%Cc
ENDIF
IF (ALLOCATED(SrcOutputData%Cm)) THEN
   i1_l = LBOUND(SrcOutputData%Cm,1)
   i1_u = UBOUND(SrcOutputData%Cm,1)
   i2_l = LBOUND(SrcOutputData%Cm,2)
   i2_u = UBOUND(SrcOutputData%Cm,2)
   IF (.NOT. ALLOCATED(DstOutputData%Cm)) THEN 
      ALLOCATE(DstOutputData%Cm(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstOutputData%Cm.', ErrStat, ErrMsg,'UnsteadyAero_CopyOutput')
         RETURN
      END IF
   END IF
   DstOutputData%Cm = SrcOutputData%Cm
ENDIF
IF (ALLOCATED(SrcOutputData%Cl)) THEN
   i1_l = LBOUND(SrcOutputData%Cl,1)
   i1_u = UBOUND(SrcOutputData%Cl,1)
   i2_l = LBOUND(SrcOutputData%Cl,2)
   i2_u = UBOUND(SrcOutputData%Cl,2)
   IF (.NOT. ALLOCATED(DstOutputData%Cl)) THEN 
      ALLOCATE(DstOutputData%Cl(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstOutputData%Cl.', ErrStat, ErrMsg,'UnsteadyAero_CopyOutput')
         RETURN
      END IF
   END IF
   DstOutputData%Cl = SrcOutputData%Cl
ENDIF
IF (ALLOCATED(SrcOutputData%Cd)) THEN
   i1_l = LBOUND(SrcOutputData%Cd,1)
   i1_u = UBOUND(SrcOutputData%Cd,1)
   i2_l = LBOUND(SrcOutputData%Cd,2)
   i2_u = UBOUND(SrcOutputData%Cd,2)
   IF (.NOT. ALLOCATED(DstOutputData%Cd)) THEN 
      ALLOCATE(DstOutputData%Cd(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstOutputData%Cd.', ErrStat, ErrMsg,'UnsteadyAero_CopyOutput')
         RETURN
      END IF
   END IF
   DstOutputData%Cd = SrcOutputData%Cd
ENDIF
IF (ALLOCATED(SrcOutputData%WriteOutput)) THEN
   i1_l = LBOUND(SrcOutputData%WriteOutput,1)
   i1_u = UBOUND(SrcOutputData%WriteOutput,1)
   IF (.NOT. ALLOCATED(DstOutputData%WriteOutput)) THEN 
      ALLOCATE(DstOutputData%WriteOutput(i1_l:i1_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstOutputData%WriteOutput.', ErrStat, ErrMsg,'UnsteadyAero_CopyOutput')
         RETURN
      END IF
   END IF
   DstOutputData%WriteOutput = SrcOutputData%WriteOutput
ENDIF
 END SUBROUTINE UnsteadyAero_CopyOutput

 SUBROUTINE UnsteadyAero_DestroyOutput( OutputData, ErrStat, ErrMsg )
  TYPE(UnsteadyAero_OutputType), INTENT(INOUT) :: OutputData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
IF (ALLOCATED(OutputData%Cn)) THEN
   DEALLOCATE(OutputData%Cn)
ENDIF
IF (ALLOCATED(OutputData%Cc)) THEN
   DEALLOCATE(OutputData%Cc)
ENDIF
IF (ALLOCATED(OutputData%Cm)) THEN
   DEALLOCATE(OutputData%Cm)
ENDIF
IF (ALLOCATED(OutputData%Cl)) THEN
   DEALLOCATE(OutputData%Cl)
ENDIF
IF (ALLOCATED(OutputData%Cd)) THEN
   DEALLOCATE(OutputData%Cd)
ENDIF
IF (ALLOCATED(OutputData%WriteOutput)) THEN
   DEALLOCATE(OutputData%WriteOutput)
ENDIF
 END SUBROUTINE UnsteadyAero_DestroyOutput

 SUBROUTINE UnsteadyAero_PackOutput( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(UnsteadyAero_OutputType),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  IF ( ALLOCATED(InData%Cn) )   Re_BufSz    = Re_BufSz    + SIZE( InData%Cn )  ! Cn 
  IF ( ALLOCATED(InData%Cc) )   Re_BufSz    = Re_BufSz    + SIZE( InData%Cc )  ! Cc 
  IF ( ALLOCATED(InData%Cm) )   Re_BufSz    = Re_BufSz    + SIZE( InData%Cm )  ! Cm 
  IF ( ALLOCATED(InData%Cl) )   Re_BufSz    = Re_BufSz    + SIZE( InData%Cl )  ! Cl 
  IF ( ALLOCATED(InData%Cd) )   Re_BufSz    = Re_BufSz    + SIZE( InData%Cd )  ! Cd 
  IF ( ALLOCATED(InData%WriteOutput) )   Re_BufSz    = Re_BufSz    + SIZE( InData%WriteOutput )  ! WriteOutput 
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  IF ( ALLOCATED(InData%Cn) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%Cn))-1 ) =  PACK(InData%Cn ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%Cn)
  ENDIF
  IF ( ALLOCATED(InData%Cc) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%Cc))-1 ) =  PACK(InData%Cc ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%Cc)
  ENDIF
  IF ( ALLOCATED(InData%Cm) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%Cm))-1 ) =  PACK(InData%Cm ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%Cm)
  ENDIF
  IF ( ALLOCATED(InData%Cl) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%Cl))-1 ) =  PACK(InData%Cl ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%Cl)
  ENDIF
  IF ( ALLOCATED(InData%Cd) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%Cd))-1 ) =  PACK(InData%Cd ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%Cd)
  ENDIF
  IF ( ALLOCATED(InData%WriteOutput) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%WriteOutput))-1 ) =  PACK(InData%WriteOutput ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%WriteOutput)
  ENDIF
 END SUBROUTINE UnsteadyAero_PackOutput

 SUBROUTINE UnsteadyAero_UnPackOutput( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(UnsteadyAero_OutputType), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  IF ( ALLOCATED(OutData%Cn) ) THEN
  ALLOCATE(mask2(SIZE(OutData%Cn,1),SIZE(OutData%Cn,2)))
  mask2 = .TRUE.
    OutData%Cn = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%Cn))-1 ),mask2,OutData%Cn)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%Cn)
  ENDIF
  IF ( ALLOCATED(OutData%Cc) ) THEN
  ALLOCATE(mask2(SIZE(OutData%Cc,1),SIZE(OutData%Cc,2)))
  mask2 = .TRUE.
    OutData%Cc = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%Cc))-1 ),mask2,OutData%Cc)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%Cc)
  ENDIF
  IF ( ALLOCATED(OutData%Cm) ) THEN
  ALLOCATE(mask2(SIZE(OutData%Cm,1),SIZE(OutData%Cm,2)))
  mask2 = .TRUE.
    OutData%Cm = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%Cm))-1 ),mask2,OutData%Cm)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%Cm)
  ENDIF
  IF ( ALLOCATED(OutData%Cl) ) THEN
  ALLOCATE(mask2(SIZE(OutData%Cl,1),SIZE(OutData%Cl,2)))
  mask2 = .TRUE.
    OutData%Cl = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%Cl))-1 ),mask2,OutData%Cl)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%Cl)
  ENDIF
  IF ( ALLOCATED(OutData%Cd) ) THEN
  ALLOCATE(mask2(SIZE(OutData%Cd,1),SIZE(OutData%Cd,2)))
  mask2 = .TRUE.
    OutData%Cd = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%Cd))-1 ),mask2,OutData%Cd)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%Cd)
  ENDIF
  IF ( ALLOCATED(OutData%WriteOutput) ) THEN
  ALLOCATE(mask1(SIZE(OutData%WriteOutput,1)))
  mask1 = .TRUE.
    OutData%WriteOutput = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%WriteOutput))-1 ),mask1,OutData%WriteOutput)
  DEALLOCATE(mask1)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%WriteOutput)
  ENDIF
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE UnsteadyAero_UnPackOutput


 SUBROUTINE UnsteadyAero_Input_ExtrapInterp(u, tin, u_out, tin_out, ErrStat, ErrMsg )
!
! This subroutine calculates a extrapolated (or interpolated) input u_out at time t_out, from previous/future time
! values of u (which has values associated with times in t).  Order of the interpolation is given by the size of u
!
!  expressions below based on either
!
!  f(t) = a
!  f(t) = a + b * t, or
!  f(t) = a + b * t + c * t**2
!
!  where a, b and c are determined as the solution to
!  f(t1) = u1, f(t2) = u2, f(t3) = u3  (as appropriate)
!
!..................................................................................................................................

 TYPE(UnsteadyAero_inputtype), INTENT(INOUT)  :: u(:)      ! Inputs at t1 > t2 > t3
 REAL(DbKi),         INTENT(IN   )  :: tin(:)      ! Times associated with the inputs
 TYPE(UnsteadyAero_inputtype), INTENT(INOUT)  :: u_out     ! Inputs at tin_out
 REAL(DbKi),         INTENT(IN   )  :: tin_out     ! time to be extrap/interp'd to
 INTEGER(IntKi),     INTENT(  OUT)  :: ErrStat   ! Error status of the operation
 CHARACTER(*),       INTENT(  OUT)  :: ErrMsg    ! Error message if ErrStat /= ErrID_None
   ! local variables
 REAL(DbKi) :: t(SIZE(tin))    ! Times associated with the inputs
 REAL(DbKi) :: t_out           ! Time to which to be extrap/interpd
 INTEGER(IntKi)                 :: order    ! order of polynomial fit (max 2)
 REAL(DbKi)                                 :: b0       ! temporary for extrapolation/interpolation
 REAL(DbKi)                                 :: c0       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:)        :: b1       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:)        :: c1       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:,:)      :: b2       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:,:)      :: c2       ! temporary for extrapolation/interpolation
 INTEGER(IntKi)                             :: ErrStat2 ! local errors
 CHARACTER(1024)                            :: ErrMsg2  ! local errors
    ! Initialize ErrStat
 ErrStat = ErrID_None
 ErrMsg  = ""
    ! we'll subtract a constant from the times to resolve some 
    ! numerical issues when t gets large (and to simplify the equations)
 t = tin - tin(1)
 t_out = tin_out - tin(1)

 if ( size(t) .ne. size(u)) then
    ErrStat = ErrID_Fatal
    ErrMsg = ' Error in UnsteadyAero_Input_ExtrapInterp: size(t) must equal size(u) '
    RETURN
 endif
 if (size(u) .gt. 3) then
    ErrStat = ErrID_Fatal
    ErrMsg  = ' Error in UnsteadyAero_Input_ExtrapInterp: size(u) must be less than 4 '
    RETURN
 endif
 order = SIZE(u) - 1
 IF ( order .eq. 0 ) THEN
IF (ALLOCATED(u_out%U) .AND. ALLOCATED(u(1)%U)) THEN
  u_out%U = u(1)%U
END IF ! check if allocated
IF (ALLOCATED(u_out%Re) .AND. ALLOCATED(u(1)%Re)) THEN
  u_out%Re = u(1)%Re
END IF ! check if allocated
IF (ALLOCATED(u_out%alpha) .AND. ALLOCATED(u(1)%alpha)) THEN
  u_out%alpha = u(1)%alpha
END IF ! check if allocated
 ELSE IF ( order .eq. 1 ) THEN
  IF ( EqualRealNos( t(1), t(2) ) ) THEN
    ErrStat = ErrID_Fatal
    ErrMsg  = ' Error in UnsteadyAero_Input_ExtrapInterp: t(1) must not equal t(2) to avoid a division-by-zero error.'
    RETURN
  END IF
IF (ALLOCATED(u_out%U) .AND. ALLOCATED(u(1)%U)) THEN
  ALLOCATE(b2(SIZE(u_out%U,1),SIZE(u_out%U,2) ))
  ALLOCATE(c2(SIZE(u_out%U,1),SIZE(u_out%U,2) ))
  b2 = -(u(1)%U - u(2)%U)/t(2)
  u_out%U = u(1)%U + b2 * t_out
  DEALLOCATE(b2)
  DEALLOCATE(c2)
END IF ! check if allocated
IF (ALLOCATED(u_out%Re) .AND. ALLOCATED(u(1)%Re)) THEN
  ALLOCATE(b2(SIZE(u_out%Re,1),SIZE(u_out%Re,2) ))
  ALLOCATE(c2(SIZE(u_out%Re,1),SIZE(u_out%Re,2) ))
  b2 = -(u(1)%Re - u(2)%Re)/t(2)
  u_out%Re = u(1)%Re + b2 * t_out
  DEALLOCATE(b2)
  DEALLOCATE(c2)
END IF ! check if allocated
IF (ALLOCATED(u_out%alpha) .AND. ALLOCATED(u(1)%alpha)) THEN
  ALLOCATE(b2(SIZE(u_out%alpha,1),SIZE(u_out%alpha,2) ))
  ALLOCATE(c2(SIZE(u_out%alpha,1),SIZE(u_out%alpha,2) ))
  b2 = -(u(1)%alpha - u(2)%alpha)/t(2)
  u_out%alpha = u(1)%alpha + b2 * t_out
  DEALLOCATE(b2)
  DEALLOCATE(c2)
END IF ! check if allocated
 ELSE IF ( order .eq. 2 ) THEN
  IF ( EqualRealNos( t(1), t(2) ) ) THEN
    ErrStat = ErrID_Fatal
    ErrMsg  = ' Error in UnsteadyAero_Input_ExtrapInterp: t(1) must not equal t(2) to avoid a division-by-zero error.'
    RETURN
  END IF
  IF ( EqualRealNos( t(2), t(3) ) ) THEN
    ErrStat = ErrID_Fatal
    ErrMsg  = ' Error in UnsteadyAero_Input_ExtrapInterp: t(2) must not equal t(3) to avoid a division-by-zero error.'
    RETURN
  END IF
  IF ( EqualRealNos( t(1), t(3) ) ) THEN
    ErrStat = ErrID_Fatal
    ErrMsg  = ' Error in UnsteadyAero_Input_ExtrapInterp: t(1) must not equal t(3) to avoid a division-by-zero error.'
    RETURN
  END IF
IF (ALLOCATED(u_out%U) .AND. ALLOCATED(u(1)%U)) THEN
  ALLOCATE(b2(SIZE(u_out%U,1),SIZE(u_out%U,2) ))
  ALLOCATE(c2(SIZE(u_out%U,1),SIZE(u_out%U,2) ))
  b2 = (t(3)**2*(u(1)%U - u(2)%U) + t(2)**2*(-u(1)%U + u(3)%U))/(t(2)*t(3)*(t(2) - t(3)))
  c2 = ( (t(2)-t(3))*u(1)%U + t(3)*u(2)%U - t(2)*u(3)%U ) / (t(2)*t(3)*(t(2) - t(3)))
  u_out%U = u(1)%U + b2 * t_out + c2 * t_out**2
  DEALLOCATE(b2)
  DEALLOCATE(c2)
END IF ! check if allocated
IF (ALLOCATED(u_out%Re) .AND. ALLOCATED(u(1)%Re)) THEN
  ALLOCATE(b2(SIZE(u_out%Re,1),SIZE(u_out%Re,2) ))
  ALLOCATE(c2(SIZE(u_out%Re,1),SIZE(u_out%Re,2) ))
  b2 = (t(3)**2*(u(1)%Re - u(2)%Re) + t(2)**2*(-u(1)%Re + u(3)%Re))/(t(2)*t(3)*(t(2) - t(3)))
  c2 = ( (t(2)-t(3))*u(1)%Re + t(3)*u(2)%Re - t(2)*u(3)%Re ) / (t(2)*t(3)*(t(2) - t(3)))
  u_out%Re = u(1)%Re + b2 * t_out + c2 * t_out**2
  DEALLOCATE(b2)
  DEALLOCATE(c2)
END IF ! check if allocated
IF (ALLOCATED(u_out%alpha) .AND. ALLOCATED(u(1)%alpha)) THEN
  ALLOCATE(b2(SIZE(u_out%alpha,1),SIZE(u_out%alpha,2) ))
  ALLOCATE(c2(SIZE(u_out%alpha,1),SIZE(u_out%alpha,2) ))
  b2 = (t(3)**2*(u(1)%alpha - u(2)%alpha) + t(2)**2*(-u(1)%alpha + u(3)%alpha))/(t(2)*t(3)*(t(2) - t(3)))
  c2 = ( (t(2)-t(3))*u(1)%alpha + t(3)*u(2)%alpha - t(2)*u(3)%alpha ) / (t(2)*t(3)*(t(2) - t(3)))
  u_out%alpha = u(1)%alpha + b2 * t_out + c2 * t_out**2
  DEALLOCATE(b2)
  DEALLOCATE(c2)
END IF ! check if allocated
 ELSE 
   ErrStat = ErrID_Fatal
   ErrMsg = ' order must be less than 3 in UnsteadyAero_Input_ExtrapInterp '
   RETURN
 ENDIF 
 END SUBROUTINE UnsteadyAero_Input_ExtrapInterp


 SUBROUTINE UnsteadyAero_Output_ExtrapInterp(u, tin, u_out, tin_out, ErrStat, ErrMsg )
!
! This subroutine calculates a extrapolated (or interpolated) input u_out at time t_out, from previous/future time
! values of u (which has values associated with times in t).  Order of the interpolation is given by the size of u
!
!  expressions below based on either
!
!  f(t) = a
!  f(t) = a + b * t, or
!  f(t) = a + b * t + c * t**2
!
!  where a, b and c are determined as the solution to
!  f(t1) = u1, f(t2) = u2, f(t3) = u3  (as appropriate)
!
!..................................................................................................................................

 TYPE(UnsteadyAero_outputtype), INTENT(INOUT)  :: u(:)      ! Inputs at t1 > t2 > t3
 REAL(DbKi),         INTENT(IN   )  :: tin(:)      ! Times associated with the inputs
 TYPE(UnsteadyAero_outputtype), INTENT(INOUT)  :: u_out     ! Inputs at tin_out
 REAL(DbKi),         INTENT(IN   )  :: tin_out     ! time to be extrap/interp'd to
 INTEGER(IntKi),     INTENT(  OUT)  :: ErrStat   ! Error status of the operation
 CHARACTER(*),       INTENT(  OUT)  :: ErrMsg    ! Error message if ErrStat /= ErrID_None
   ! local variables
 REAL(DbKi) :: t(SIZE(tin))    ! Times associated with the inputs
 REAL(DbKi) :: t_out           ! Time to which to be extrap/interpd
 INTEGER(IntKi)                 :: order    ! order of polynomial fit (max 2)
 REAL(DbKi)                                 :: b0       ! temporary for extrapolation/interpolation
 REAL(DbKi)                                 :: c0       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:)        :: b1       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:)        :: c1       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:,:)      :: b2       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:,:)      :: c2       ! temporary for extrapolation/interpolation
 INTEGER(IntKi)                             :: ErrStat2 ! local errors
 CHARACTER(1024)                            :: ErrMsg2  ! local errors
    ! Initialize ErrStat
 ErrStat = ErrID_None
 ErrMsg  = ""
    ! we'll subtract a constant from the times to resolve some 
    ! numerical issues when t gets large (and to simplify the equations)
 t = tin - tin(1)
 t_out = tin_out - tin(1)

 if ( size(t) .ne. size(u)) then
    ErrStat = ErrID_Fatal
    ErrMsg = ' Error in UnsteadyAero_Output_ExtrapInterp: size(t) must equal size(u) '
    RETURN
 endif
 if (size(u) .gt. 3) then
    ErrStat = ErrID_Fatal
    ErrMsg  = ' Error in UnsteadyAero_Output_ExtrapInterp: size(u) must be less than 4 '
    RETURN
 endif
 order = SIZE(u) - 1
 IF ( order .eq. 0 ) THEN
IF (ALLOCATED(u_out%Cn) .AND. ALLOCATED(u(1)%Cn)) THEN
  u_out%Cn = u(1)%Cn
END IF ! check if allocated
IF (ALLOCATED(u_out%Cc) .AND. ALLOCATED(u(1)%Cc)) THEN
  u_out%Cc = u(1)%Cc
END IF ! check if allocated
IF (ALLOCATED(u_out%Cm) .AND. ALLOCATED(u(1)%Cm)) THEN
  u_out%Cm = u(1)%Cm
END IF ! check if allocated
IF (ALLOCATED(u_out%Cl) .AND. ALLOCATED(u(1)%Cl)) THEN
  u_out%Cl = u(1)%Cl
END IF ! check if allocated
IF (ALLOCATED(u_out%Cd) .AND. ALLOCATED(u(1)%Cd)) THEN
  u_out%Cd = u(1)%Cd
END IF ! check if allocated
IF (ALLOCATED(u_out%WriteOutput) .AND. ALLOCATED(u(1)%WriteOutput)) THEN
  u_out%WriteOutput = u(1)%WriteOutput
END IF ! check if allocated
 ELSE IF ( order .eq. 1 ) THEN
  IF ( EqualRealNos( t(1), t(2) ) ) THEN
    ErrStat = ErrID_Fatal
    ErrMsg  = ' Error in UnsteadyAero_Output_ExtrapInterp: t(1) must not equal t(2) to avoid a division-by-zero error.'
    RETURN
  END IF
IF (ALLOCATED(u_out%Cn) .AND. ALLOCATED(u(1)%Cn)) THEN
  ALLOCATE(b2(SIZE(u_out%Cn,1),SIZE(u_out%Cn,2) ))
  ALLOCATE(c2(SIZE(u_out%Cn,1),SIZE(u_out%Cn,2) ))
  b2 = -(u(1)%Cn - u(2)%Cn)/t(2)
  u_out%Cn = u(1)%Cn + b2 * t_out
  DEALLOCATE(b2)
  DEALLOCATE(c2)
END IF ! check if allocated
IF (ALLOCATED(u_out%Cc) .AND. ALLOCATED(u(1)%Cc)) THEN
  ALLOCATE(b2(SIZE(u_out%Cc,1),SIZE(u_out%Cc,2) ))
  ALLOCATE(c2(SIZE(u_out%Cc,1),SIZE(u_out%Cc,2) ))
  b2 = -(u(1)%Cc - u(2)%Cc)/t(2)
  u_out%Cc = u(1)%Cc + b2 * t_out
  DEALLOCATE(b2)
  DEALLOCATE(c2)
END IF ! check if allocated
IF (ALLOCATED(u_out%Cm) .AND. ALLOCATED(u(1)%Cm)) THEN
  ALLOCATE(b2(SIZE(u_out%Cm,1),SIZE(u_out%Cm,2) ))
  ALLOCATE(c2(SIZE(u_out%Cm,1),SIZE(u_out%Cm,2) ))
  b2 = -(u(1)%Cm - u(2)%Cm)/t(2)
  u_out%Cm = u(1)%Cm + b2 * t_out
  DEALLOCATE(b2)
  DEALLOCATE(c2)
END IF ! check if allocated
IF (ALLOCATED(u_out%Cl) .AND. ALLOCATED(u(1)%Cl)) THEN
  ALLOCATE(b2(SIZE(u_out%Cl,1),SIZE(u_out%Cl,2) ))
  ALLOCATE(c2(SIZE(u_out%Cl,1),SIZE(u_out%Cl,2) ))
  b2 = -(u(1)%Cl - u(2)%Cl)/t(2)
  u_out%Cl = u(1)%Cl + b2 * t_out
  DEALLOCATE(b2)
  DEALLOCATE(c2)
END IF ! check if allocated
IF (ALLOCATED(u_out%Cd) .AND. ALLOCATED(u(1)%Cd)) THEN
  ALLOCATE(b2(SIZE(u_out%Cd,1),SIZE(u_out%Cd,2) ))
  ALLOCATE(c2(SIZE(u_out%Cd,1),SIZE(u_out%Cd,2) ))
  b2 = -(u(1)%Cd - u(2)%Cd)/t(2)
  u_out%Cd = u(1)%Cd + b2 * t_out
  DEALLOCATE(b2)
  DEALLOCATE(c2)
END IF ! check if allocated
IF (ALLOCATED(u_out%WriteOutput) .AND. ALLOCATED(u(1)%WriteOutput)) THEN
  ALLOCATE(b1(SIZE(u_out%WriteOutput,1)))
  ALLOCATE(c1(SIZE(u_out%WriteOutput,1)))
  b1 = -(u(1)%WriteOutput - u(2)%WriteOutput)/t(2)
  u_out%WriteOutput = u(1)%WriteOutput + b1 * t_out
  DEALLOCATE(b1)
  DEALLOCATE(c1)
END IF ! check if allocated
 ELSE IF ( order .eq. 2 ) THEN
  IF ( EqualRealNos( t(1), t(2) ) ) THEN
    ErrStat = ErrID_Fatal
    ErrMsg  = ' Error in UnsteadyAero_Output_ExtrapInterp: t(1) must not equal t(2) to avoid a division-by-zero error.'
    RETURN
  END IF
  IF ( EqualRealNos( t(2), t(3) ) ) THEN
    ErrStat = ErrID_Fatal
    ErrMsg  = ' Error in UnsteadyAero_Output_ExtrapInterp: t(2) must not equal t(3) to avoid a division-by-zero error.'
    RETURN
  END IF
  IF ( EqualRealNos( t(1), t(3) ) ) THEN
    ErrStat = ErrID_Fatal
    ErrMsg  = ' Error in UnsteadyAero_Output_ExtrapInterp: t(1) must not equal t(3) to avoid a division-by-zero error.'
    RETURN
  END IF
IF (ALLOCATED(u_out%Cn) .AND. ALLOCATED(u(1)%Cn)) THEN
  ALLOCATE(b2(SIZE(u_out%Cn,1),SIZE(u_out%Cn,2) ))
  ALLOCATE(c2(SIZE(u_out%Cn,1),SIZE(u_out%Cn,2) ))
  b2 = (t(3)**2*(u(1)%Cn - u(2)%Cn) + t(2)**2*(-u(1)%Cn + u(3)%Cn))/(t(2)*t(3)*(t(2) - t(3)))
  c2 = ( (t(2)-t(3))*u(1)%Cn + t(3)*u(2)%Cn - t(2)*u(3)%Cn ) / (t(2)*t(3)*(t(2) - t(3)))
  u_out%Cn = u(1)%Cn + b2 * t_out + c2 * t_out**2
  DEALLOCATE(b2)
  DEALLOCATE(c2)
END IF ! check if allocated
IF (ALLOCATED(u_out%Cc) .AND. ALLOCATED(u(1)%Cc)) THEN
  ALLOCATE(b2(SIZE(u_out%Cc,1),SIZE(u_out%Cc,2) ))
  ALLOCATE(c2(SIZE(u_out%Cc,1),SIZE(u_out%Cc,2) ))
  b2 = (t(3)**2*(u(1)%Cc - u(2)%Cc) + t(2)**2*(-u(1)%Cc + u(3)%Cc))/(t(2)*t(3)*(t(2) - t(3)))
  c2 = ( (t(2)-t(3))*u(1)%Cc + t(3)*u(2)%Cc - t(2)*u(3)%Cc ) / (t(2)*t(3)*(t(2) - t(3)))
  u_out%Cc = u(1)%Cc + b2 * t_out + c2 * t_out**2
  DEALLOCATE(b2)
  DEALLOCATE(c2)
END IF ! check if allocated
IF (ALLOCATED(u_out%Cm) .AND. ALLOCATED(u(1)%Cm)) THEN
  ALLOCATE(b2(SIZE(u_out%Cm,1),SIZE(u_out%Cm,2) ))
  ALLOCATE(c2(SIZE(u_out%Cm,1),SIZE(u_out%Cm,2) ))
  b2 = (t(3)**2*(u(1)%Cm - u(2)%Cm) + t(2)**2*(-u(1)%Cm + u(3)%Cm))/(t(2)*t(3)*(t(2) - t(3)))
  c2 = ( (t(2)-t(3))*u(1)%Cm + t(3)*u(2)%Cm - t(2)*u(3)%Cm ) / (t(2)*t(3)*(t(2) - t(3)))
  u_out%Cm = u(1)%Cm + b2 * t_out + c2 * t_out**2
  DEALLOCATE(b2)
  DEALLOCATE(c2)
END IF ! check if allocated
IF (ALLOCATED(u_out%Cl) .AND. ALLOCATED(u(1)%Cl)) THEN
  ALLOCATE(b2(SIZE(u_out%Cl,1),SIZE(u_out%Cl,2) ))
  ALLOCATE(c2(SIZE(u_out%Cl,1),SIZE(u_out%Cl,2) ))
  b2 = (t(3)**2*(u(1)%Cl - u(2)%Cl) + t(2)**2*(-u(1)%Cl + u(3)%Cl))/(t(2)*t(3)*(t(2) - t(3)))
  c2 = ( (t(2)-t(3))*u(1)%Cl + t(3)*u(2)%Cl - t(2)*u(3)%Cl ) / (t(2)*t(3)*(t(2) - t(3)))
  u_out%Cl = u(1)%Cl + b2 * t_out + c2 * t_out**2
  DEALLOCATE(b2)
  DEALLOCATE(c2)
END IF ! check if allocated
IF (ALLOCATED(u_out%Cd) .AND. ALLOCATED(u(1)%Cd)) THEN
  ALLOCATE(b2(SIZE(u_out%Cd,1),SIZE(u_out%Cd,2) ))
  ALLOCATE(c2(SIZE(u_out%Cd,1),SIZE(u_out%Cd,2) ))
  b2 = (t(3)**2*(u(1)%Cd - u(2)%Cd) + t(2)**2*(-u(1)%Cd + u(3)%Cd))/(t(2)*t(3)*(t(2) - t(3)))
  c2 = ( (t(2)-t(3))*u(1)%Cd + t(3)*u(2)%Cd - t(2)*u(3)%Cd ) / (t(2)*t(3)*(t(2) - t(3)))
  u_out%Cd = u(1)%Cd + b2 * t_out + c2 * t_out**2
  DEALLOCATE(b2)
  DEALLOCATE(c2)
END IF ! check if allocated
IF (ALLOCATED(u_out%WriteOutput) .AND. ALLOCATED(u(1)%WriteOutput)) THEN
  ALLOCATE(b1(SIZE(u_out%WriteOutput,1)))
  ALLOCATE(c1(SIZE(u_out%WriteOutput,1)))
  b1 = (t(3)**2*(u(1)%WriteOutput - u(2)%WriteOutput) + t(2)**2*(-u(1)%WriteOutput + u(3)%WriteOutput))/(t(2)*t(3)*(t(2) - t(3)))
  c1 = ( (t(2)-t(3))*u(1)%WriteOutput + t(3)*u(2)%WriteOutput - t(2)*u(3)%WriteOutput ) / (t(2)*t(3)*(t(2) - t(3)))
  u_out%WriteOutput = u(1)%WriteOutput + b1 * t_out + c1 * t_out**2
  DEALLOCATE(b1)
  DEALLOCATE(c1)
END IF ! check if allocated
 ELSE 
   ErrStat = ErrID_Fatal
   ErrMsg = ' order must be less than 3 in UnsteadyAero_Output_ExtrapInterp '
   RETURN
 ENDIF 
 END SUBROUTINE UnsteadyAero_Output_ExtrapInterp

END MODULE UnsteadyAero_Types
!ENDOFREGISTRYGENERATEDFILE
