!STARTOFREGISTRYGENERATEDFILE './UnsteadyAero_Types.f90'
!
! WARNING This file is generated automatically by the FAST registry
! Do not edit.  Your changes to this file will be lost.
!
! FAST Registry (v2.05.00, 10-Jan-2015)
!*********************************************************************************************************************************
! UnsteadyAero_Types
!.................................................................................................................................
! This file is part of UnsteadyAero.
!
! Copyright (C) 2012-2015 National Renewable Energy Laboratory
!
! Licensed under the Apache License, Version 2.0 (the "License");
! you may not use this file except in compliance with the License.
! You may obtain a copy of the License at
!
!     http://www.apache.org/licenses/LICENSE-2.0
!
! Unless required by applicable law or agreed to in writing, software
! distributed under the License is distributed on an "AS IS" BASIS,
! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
! See the License for the specific language governing permissions and
! limitations under the License.
!
!
! W A R N I N G : This file was automatically generated from the FAST registry.  Changes made to this file may be lost.
!
!*********************************************************************************************************************************
MODULE UnsteadyAero_Types
! This module contains all of the user-defined types needed in UnsteadyAero. It also contains copy, destroy, pack, and
! unpack routines associated with each defined data type. This code will be generated by the FAST Registry.
!---------------------------------------------------------------------------------------------------------------------------------
USE AirfoilInfo_Types
USE NWTC_Library
IMPLICIT NONE
! =========  UA_InitInputType  =======
  TYPE, PUBLIC :: UA_InitInputType
    REAL(DbKi)  :: dt      ! time step [s]
    CHARACTER(1024)  :: OutRootName      ! Supplied by Driver:  The name of the root file (without extension) including the full path [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: c      ! Chord length at node [m]
    INTEGER(IntKi)  :: numBlades      ! Number nodes of all blades [-]
    INTEGER(IntKi)  :: nNodesPerBlade      ! Number nodes per blades [-]
    INTEGER(IntKi)  :: DSMod      ! Model for the dynamic stall equations [1 = Leishman/Beddoes, 2 = Gonzalez, 3 = Minnema] [-]
    REAL(ReKi)  :: a_s      ! speed of sound [m/s]
    CHARACTER(20)  :: OutFmt      ! Output format for numerical results [-]
    CHARACTER(20)  :: OutSFmt      ! Output format for header strings [-]
    INTEGER(IntKi)  :: NumOuts      ! The number of outputs for this module as requested in the input file [-]
    CHARACTER(10) , DIMENSION(1:199)  :: OutList      ! The user-requested output channel labels for this module. This should really be dimensioned with MaxOutPts [-]
  END TYPE UA_InitInputType
! =======================
! =========  UA_InitOutputType  =======
  TYPE, PUBLIC :: UA_InitOutputType
    TYPE(ProgDesc)  :: Version      ! Version structure [-]
    CHARACTER(10) , DIMENSION(:), ALLOCATABLE  :: WriteOutputHdr      ! The is the list of all HD-related output channel header strings (includes all sub-module channels) [-]
    CHARACTER(10) , DIMENSION(:), ALLOCATABLE  :: WriteOutputUnt      ! The is the list of all HD-related output channel unit strings (includes all sub-module channels) [-]
  END TYPE UA_InitOutputType
! =======================
! =========  UA_ContinuousStateType  =======
  TYPE, PUBLIC :: UA_ContinuousStateType
    REAL(ReKi)  :: DummyContState      ! Remove this variable if you have continuous states [-]
  END TYPE UA_ContinuousStateType
! =======================
! =========  UA_DiscreteStateType  =======
  TYPE, PUBLIC :: UA_DiscreteStateType
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: alpha_minus1      ! angle of attack, previous time step [rad]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: alpha_minus2      ! angle of attack, two time steps ago [rad]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: q_minus1      ! non-dimensional pitching rate, previous time step [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: q_minus2      ! non-dimensional pitching rate, two time steps ago [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: X1_minus1      ! deficiency function used in the development of Cn_alpha_q__circ, previous time step [rad]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: X2_minus1      ! deficiency function used in the development of Cn_alpha_q__circ, previous time step [rad]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: Kprime_alpha_minus1      ! deficiency function used in the development of Cn_alpha_nc, previous time step [rad/s]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: Kprime_q_minus1      ! deficiency function used in the development of Cn_q_nc, previous time step [rad/s^2]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: Kprimeprime_q_minus1      ! deficiency function used in the development of Cm_q_nc, previous time step [rad/s^2]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: K3prime_q_minus1      ! deficiency function used in the development of Cm_q_circ, previous time step [rad/s]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: Dp_minus1      ! deficiency function used in the development of Cm_q_circ, previous time step [rad/s]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: Cn_pot_minus1      ! deficiency function used in the development of Cn_prime [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: fprimeprime_minus1      ! lagged version of fprime, accounting for unsteady boundary layer response, previous time step [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: Df_minus1      ! deficiency function used in the development of fprime, previous time step [rad/s]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: fprime_minus1      ! separation point distance from leading edge, expressed in cord fraction, previous time step [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: tau_V      ! time variable, tracking the travel of the LE vortex over the airfoil suction surface [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: Cn_v_minus1      ! normal force coefficient due to the presence of LE vortex, previous time step [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: C_V_minus1      ! contribution to the normal force coefficient due to accumulated vorticity in the LE vortex, previous time step [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: Dfalpha_minus1      ! deficiency function used in the development of alpha_f_prime, previous time step [rad]
  END TYPE UA_DiscreteStateType
! =======================
! =========  UA_ConstraintStateType  =======
  TYPE, PUBLIC :: UA_ConstraintStateType
    REAL(ReKi)  :: DummyConstraintState      !  [-]
  END TYPE UA_ConstraintStateType
! =======================
! =========  UA_OtherStateType  =======
  TYPE, PUBLIC :: UA_OtherStateType
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: sigma1      ! multiplier for T_f [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: sigma3      ! multiplier for T_V [-]
    LOGICAL , DIMENSION(:,:), ALLOCATABLE  :: TESF      ! logical flag indicating if trailing edge separation is possible [-]
    LOGICAL , DIMENSION(:,:), ALLOCATABLE  :: LESF      ! logical flag indicating if leading edge separation is possible [-]
    LOGICAL , DIMENSION(:,:), ALLOCATABLE  :: VRTX      ! logical flag indicating if a vortex is being processed [-]
    LOGICAL  :: FirstPass      ! logical flag indicating if this is the first time step [-]
    INTEGER(IntKi)  :: iBladeNode      ! index for the blade node being operated on (within the current blade) [-]
    INTEGER(IntKi)  :: iBlade      ! index for the blade being operated on [-]
  END TYPE UA_OtherStateType
! =======================
! =========  UA_ParameterType  =======
  TYPE, PUBLIC :: UA_ParameterType
    REAL(DbKi)  :: dt      ! time step [s]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: c      ! Chord length at node [m]
    INTEGER(IntKi)  :: numBlades      ! Number nodes of all blades [-]
    INTEGER(IntKi)  :: nNodesPerBlade      ! Number nodes per blades [-]
    INTEGER(IntKi)  :: DSMod      ! Model for the dynamic stall equations [1 = Leishman/Beddoes, 2 = Gonzalez, 3 = Minnema] [-]
    REAL(ReKi)  :: a_s      ! speed of sound [m/s]
    INTEGER(IntKi)  :: NumOuts      ! Number of outputs [-]
    INTEGER(IntKi)  :: OutSwtch      ! Output requested channels to: [1=Unsteady.out 2=GlueCode.out  3=both files] [-]
    CHARACTER(20)  :: OutFmt      ! Output format for numerical results [-]
    CHARACTER(20)  :: OutSFmt      ! Output format for header strings [-]
    CHARACTER(10)  :: Delim      ! Delimiter string for outputs, defaults to tab-delimiters [-]
    INTEGER(IntKi)  :: UnOutFile      ! File unit for the UnsteadyAero outputs [-]
  END TYPE UA_ParameterType
! =======================
! =========  UA_InputType  =======
  TYPE, PUBLIC :: UA_InputType
    REAL(ReKi)  :: U      ! air velocity magnitude relative to the airfoil [m/s]
    REAL(ReKi)  :: alpha      ! angle of attack [rad]
    REAL(ReKi)  :: Re      ! Reynold's number [-]
  END TYPE UA_InputType
! =======================
! =========  UA_OutputType  =======
  TYPE, PUBLIC :: UA_OutputType
    REAL(ReKi)  :: Cn      ! 2D, normal to chord, force coefficient [-]
    REAL(ReKi)  :: Cc      ! 2D, tangent to chord, force coefficient [-]
    REAL(ReKi)  :: Cm      ! 2D pitching moment coefficient about the 1/4 chord, positive when nose is up [-]
    REAL(ReKi)  :: Cl      ! 2D lift coefficient [-]
    REAL(ReKi)  :: Cd      ! 2D drag coefficient [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: WriteOutput      ! outputs to be written to a file [-]
  END TYPE UA_OutputType
! =======================
CONTAINS
 SUBROUTINE UA_CopyInitInput( SrcInitInputData, DstInitInputData, CtrlCode, ErrStat, ErrMsg )
   TYPE(UA_InitInputType), INTENT(IN) :: SrcInitInputData
   TYPE(UA_InitInputType), INTENT(INOUT) :: DstInitInputData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: i2, i2_l, i2_u  !  bounds (upper/lower) for an array dimension 2
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(1024)                :: ErrMsg2
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
   DstInitInputData%dt = SrcInitInputData%dt
   DstInitInputData%OutRootName = SrcInitInputData%OutRootName
IF (ALLOCATED(SrcInitInputData%c)) THEN
   i1_l = LBOUND(SrcInitInputData%c,1)
   i1_u = UBOUND(SrcInitInputData%c,1)
   i2_l = LBOUND(SrcInitInputData%c,2)
   i2_u = UBOUND(SrcInitInputData%c,2)
   IF (.NOT. ALLOCATED(DstInitInputData%c)) THEN 
      ALLOCATE(DstInitInputData%c(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInitInputData%c.', ErrStat, ErrMsg,'UA_CopyInitInput')
         RETURN
      END IF
   END IF
   DstInitInputData%c = SrcInitInputData%c
ENDIF
   DstInitInputData%numBlades = SrcInitInputData%numBlades
   DstInitInputData%nNodesPerBlade = SrcInitInputData%nNodesPerBlade
   DstInitInputData%DSMod = SrcInitInputData%DSMod
   DstInitInputData%a_s = SrcInitInputData%a_s
   DstInitInputData%OutFmt = SrcInitInputData%OutFmt
   DstInitInputData%OutSFmt = SrcInitInputData%OutSFmt
   DstInitInputData%NumOuts = SrcInitInputData%NumOuts
   DstInitInputData%OutList = SrcInitInputData%OutList
 END SUBROUTINE UA_CopyInitInput

 SUBROUTINE UA_DestroyInitInput( InitInputData, ErrStat, ErrMsg )
  TYPE(UA_InitInputType), INTENT(INOUT) :: InitInputData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
IF (ALLOCATED(InitInputData%c)) THEN
   DEALLOCATE(InitInputData%c)
ENDIF
 END SUBROUTINE UA_DestroyInitInput

 SUBROUTINE UA_PackInitInput( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(UA_InitInputType),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  Db_BufSz   = Db_BufSz   + 1  ! dt
!  missing buffer for OutRootName
  IF ( ALLOCATED(InData%c) )   Re_BufSz    = Re_BufSz    + SIZE( InData%c )  ! c 
  Int_BufSz  = Int_BufSz  + 1  ! numBlades
  Int_BufSz  = Int_BufSz  + 1  ! nNodesPerBlade
  Int_BufSz  = Int_BufSz  + 1  ! DSMod
  Re_BufSz   = Re_BufSz   + 1  ! a_s
!  missing buffer for OutFmt
!  missing buffer for OutSFmt
  Int_BufSz  = Int_BufSz  + 1  ! NumOuts
!  missing buffer for OutList
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  IF ( .NOT. OnlySize ) DbKiBuf ( Db_Xferred:Db_Xferred+(1)-1 ) =  (InData%dt )
  Db_Xferred   = Db_Xferred   + 1
  IF ( ALLOCATED(InData%c) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%c))-1 ) =  PACK(InData%c ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%c)
  ENDIF
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%numBlades )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%nNodesPerBlade )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%DSMod )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%a_s )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%NumOuts )
  Int_Xferred   = Int_Xferred   + 1
 END SUBROUTINE UA_PackInitInput

 SUBROUTINE UA_UnPackInitInput( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(UA_InitInputType), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  OutData%dt = DbKiBuf ( Db_Xferred )
  Db_Xferred   = Db_Xferred   + 1
  IF ( ALLOCATED(OutData%c) ) THEN
  ALLOCATE(mask2(SIZE(OutData%c,1),SIZE(OutData%c,2)))
  mask2 = .TRUE.
    OutData%c = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%c))-1 ),mask2,OutData%c)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%c)
  ENDIF
  OutData%numBlades = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%nNodesPerBlade = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%DSMod = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%a_s = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%NumOuts = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE UA_UnPackInitInput

 SUBROUTINE UA_CopyInitOutput( SrcInitOutputData, DstInitOutputData, CtrlCode, ErrStat, ErrMsg )
   TYPE(UA_InitOutputType), INTENT(IN) :: SrcInitOutputData
   TYPE(UA_InitOutputType), INTENT(INOUT) :: DstInitOutputData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: i2, i2_l, i2_u  !  bounds (upper/lower) for an array dimension 2
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(1024)                :: ErrMsg2
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
      CALL NWTC_Library_Copyprogdesc( SrcInitOutputData%Version, DstInitOutputData%Version, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,'UA_CopyInitOutput:Version')
         IF (ErrStat>=AbortErrLev) RETURN
IF (ALLOCATED(SrcInitOutputData%WriteOutputHdr)) THEN
   i1_l = LBOUND(SrcInitOutputData%WriteOutputHdr,1)
   i1_u = UBOUND(SrcInitOutputData%WriteOutputHdr,1)
   IF (.NOT. ALLOCATED(DstInitOutputData%WriteOutputHdr)) THEN 
      ALLOCATE(DstInitOutputData%WriteOutputHdr(i1_l:i1_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInitOutputData%WriteOutputHdr.', ErrStat, ErrMsg,'UA_CopyInitOutput')
         RETURN
      END IF
   END IF
   DstInitOutputData%WriteOutputHdr = SrcInitOutputData%WriteOutputHdr
ENDIF
IF (ALLOCATED(SrcInitOutputData%WriteOutputUnt)) THEN
   i1_l = LBOUND(SrcInitOutputData%WriteOutputUnt,1)
   i1_u = UBOUND(SrcInitOutputData%WriteOutputUnt,1)
   IF (.NOT. ALLOCATED(DstInitOutputData%WriteOutputUnt)) THEN 
      ALLOCATE(DstInitOutputData%WriteOutputUnt(i1_l:i1_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInitOutputData%WriteOutputUnt.', ErrStat, ErrMsg,'UA_CopyInitOutput')
         RETURN
      END IF
   END IF
   DstInitOutputData%WriteOutputUnt = SrcInitOutputData%WriteOutputUnt
ENDIF
 END SUBROUTINE UA_CopyInitOutput

 SUBROUTINE UA_DestroyInitOutput( InitOutputData, ErrStat, ErrMsg )
  TYPE(UA_InitOutputType), INTENT(INOUT) :: InitOutputData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
  CALL NWTC_Library_Destroyprogdesc( InitOutputData%Version, ErrStat, ErrMsg )
IF (ALLOCATED(InitOutputData%WriteOutputHdr)) THEN
   DEALLOCATE(InitOutputData%WriteOutputHdr)
ENDIF
IF (ALLOCATED(InitOutputData%WriteOutputUnt)) THEN
   DEALLOCATE(InitOutputData%WriteOutputUnt)
ENDIF
 END SUBROUTINE UA_DestroyInitOutput

 SUBROUTINE UA_PackInitOutput( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(UA_InitOutputType),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  REAL(ReKi),     ALLOCATABLE :: Re_Version_Buf(:)
  REAL(DbKi),     ALLOCATABLE :: Db_Version_Buf(:)
  INTEGER(IntKi), ALLOCATABLE :: Int_Version_Buf(:)
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  CALL NWTC_Library_Packprogdesc( Re_Version_Buf, Db_Version_Buf, Int_Version_Buf, InData%Version, ErrStat, ErrMsg, .TRUE. ) ! Version 
  IF(ALLOCATED(Re_Version_Buf)) Re_BufSz  = Re_BufSz  + SIZE( Re_Version_Buf  ) ! Version
  IF(ALLOCATED(Db_Version_Buf)) Db_BufSz  = Db_BufSz  + SIZE( Db_Version_Buf  ) ! Version
  IF(ALLOCATED(Int_Version_Buf))Int_BufSz = Int_BufSz + SIZE( Int_Version_Buf ) ! Version
  IF(ALLOCATED(Re_Version_Buf))  DEALLOCATE(Re_Version_Buf)
  IF(ALLOCATED(Db_Version_Buf))  DEALLOCATE(Db_Version_Buf)
  IF(ALLOCATED(Int_Version_Buf)) DEALLOCATE(Int_Version_Buf)
!  missing buffer for WriteOutputHdr
!  missing buffer for WriteOutputUnt
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  CALL NWTC_Library_Packprogdesc( Re_Version_Buf, Db_Version_Buf, Int_Version_Buf, InData%Version, ErrStat, ErrMsg, OnlySize ) ! Version 
  IF(ALLOCATED(Re_Version_Buf)) THEN
    IF ( .NOT. OnlySize ) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_Version_Buf)-1 ) = Re_Version_Buf
    Re_Xferred = Re_Xferred + SIZE(Re_Version_Buf)
  ENDIF
  IF(ALLOCATED(Db_Version_Buf)) THEN
    IF ( .NOT. OnlySize ) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_Version_Buf)-1 ) = Db_Version_Buf
    Db_Xferred = Db_Xferred + SIZE(Db_Version_Buf)
  ENDIF
  IF(ALLOCATED(Int_Version_Buf)) THEN
    IF ( .NOT. OnlySize ) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_Version_Buf)-1 ) = Int_Version_Buf
    Int_Xferred = Int_Xferred + SIZE(Int_Version_Buf)
  ENDIF
  IF( ALLOCATED(Re_Version_Buf) )  DEALLOCATE(Re_Version_Buf)
  IF( ALLOCATED(Db_Version_Buf) )  DEALLOCATE(Db_Version_Buf)
  IF( ALLOCATED(Int_Version_Buf) ) DEALLOCATE(Int_Version_Buf)
 END SUBROUTINE UA_PackInitOutput

 SUBROUTINE UA_UnPackInitOutput( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(UA_InitOutputType), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
  REAL(ReKi),    ALLOCATABLE :: Re_Version_Buf(:)
  REAL(DbKi),    ALLOCATABLE :: Db_Version_Buf(:)
  INTEGER(IntKi),    ALLOCATABLE :: Int_Version_Buf(:)
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
 ! first call NWTC_Library_Packprogdesc to get correctly sized buffers for unpacking
  CALL NWTC_Library_Packprogdesc( Re_Version_Buf, Db_Version_Buf, Int_Version_Buf, OutData%Version, ErrStat, ErrMsg, .TRUE. ) ! Version 
  IF(ALLOCATED(Re_Version_Buf)) THEN
    Re_Version_Buf = ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_Version_Buf)-1 )
    Re_Xferred = Re_Xferred + SIZE(Re_Version_Buf)
  ENDIF
  IF(ALLOCATED(Db_Version_Buf)) THEN
    Db_Version_Buf = DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_Version_Buf)-1 )
    Db_Xferred = Db_Xferred + SIZE(Db_Version_Buf)
  ENDIF
  IF(ALLOCATED(Int_Version_Buf)) THEN
    Int_Version_Buf = IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_Version_Buf)-1 )
    Int_Xferred = Int_Xferred + SIZE(Int_Version_Buf)
  ENDIF
  CALL NWTC_Library_UnPackprogdesc( Re_Version_Buf, Db_Version_Buf, Int_Version_Buf, OutData%Version, ErrStat, ErrMsg ) ! Version 
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE UA_UnPackInitOutput

 SUBROUTINE UA_CopyContState( SrcContStateData, DstContStateData, CtrlCode, ErrStat, ErrMsg )
   TYPE(UA_ContinuousStateType), INTENT(IN) :: SrcContStateData
   TYPE(UA_ContinuousStateType), INTENT(INOUT) :: DstContStateData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: i2, i2_l, i2_u  !  bounds (upper/lower) for an array dimension 2
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(1024)                :: ErrMsg2
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
   DstContStateData%DummyContState = SrcContStateData%DummyContState
 END SUBROUTINE UA_CopyContState

 SUBROUTINE UA_DestroyContState( ContStateData, ErrStat, ErrMsg )
  TYPE(UA_ContinuousStateType), INTENT(INOUT) :: ContStateData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
 END SUBROUTINE UA_DestroyContState

 SUBROUTINE UA_PackContState( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(UA_ContinuousStateType),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  Re_BufSz   = Re_BufSz   + 1  ! DummyContState
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%DummyContState )
  Re_Xferred   = Re_Xferred   + 1
 END SUBROUTINE UA_PackContState

 SUBROUTINE UA_UnPackContState( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(UA_ContinuousStateType), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  OutData%DummyContState = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE UA_UnPackContState

 SUBROUTINE UA_CopyDiscState( SrcDiscStateData, DstDiscStateData, CtrlCode, ErrStat, ErrMsg )
   TYPE(UA_DiscreteStateType), INTENT(IN) :: SrcDiscStateData
   TYPE(UA_DiscreteStateType), INTENT(INOUT) :: DstDiscStateData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: i2, i2_l, i2_u  !  bounds (upper/lower) for an array dimension 2
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(1024)                :: ErrMsg2
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
IF (ALLOCATED(SrcDiscStateData%alpha_minus1)) THEN
   i1_l = LBOUND(SrcDiscStateData%alpha_minus1,1)
   i1_u = UBOUND(SrcDiscStateData%alpha_minus1,1)
   i2_l = LBOUND(SrcDiscStateData%alpha_minus1,2)
   i2_u = UBOUND(SrcDiscStateData%alpha_minus1,2)
   IF (.NOT. ALLOCATED(DstDiscStateData%alpha_minus1)) THEN 
      ALLOCATE(DstDiscStateData%alpha_minus1(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstDiscStateData%alpha_minus1.', ErrStat, ErrMsg,'UA_CopyDiscState')
         RETURN
      END IF
   END IF
   DstDiscStateData%alpha_minus1 = SrcDiscStateData%alpha_minus1
ENDIF
IF (ALLOCATED(SrcDiscStateData%alpha_minus2)) THEN
   i1_l = LBOUND(SrcDiscStateData%alpha_minus2,1)
   i1_u = UBOUND(SrcDiscStateData%alpha_minus2,1)
   i2_l = LBOUND(SrcDiscStateData%alpha_minus2,2)
   i2_u = UBOUND(SrcDiscStateData%alpha_minus2,2)
   IF (.NOT. ALLOCATED(DstDiscStateData%alpha_minus2)) THEN 
      ALLOCATE(DstDiscStateData%alpha_minus2(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstDiscStateData%alpha_minus2.', ErrStat, ErrMsg,'UA_CopyDiscState')
         RETURN
      END IF
   END IF
   DstDiscStateData%alpha_minus2 = SrcDiscStateData%alpha_minus2
ENDIF
IF (ALLOCATED(SrcDiscStateData%q_minus1)) THEN
   i1_l = LBOUND(SrcDiscStateData%q_minus1,1)
   i1_u = UBOUND(SrcDiscStateData%q_minus1,1)
   i2_l = LBOUND(SrcDiscStateData%q_minus1,2)
   i2_u = UBOUND(SrcDiscStateData%q_minus1,2)
   IF (.NOT. ALLOCATED(DstDiscStateData%q_minus1)) THEN 
      ALLOCATE(DstDiscStateData%q_minus1(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstDiscStateData%q_minus1.', ErrStat, ErrMsg,'UA_CopyDiscState')
         RETURN
      END IF
   END IF
   DstDiscStateData%q_minus1 = SrcDiscStateData%q_minus1
ENDIF
IF (ALLOCATED(SrcDiscStateData%q_minus2)) THEN
   i1_l = LBOUND(SrcDiscStateData%q_minus2,1)
   i1_u = UBOUND(SrcDiscStateData%q_minus2,1)
   i2_l = LBOUND(SrcDiscStateData%q_minus2,2)
   i2_u = UBOUND(SrcDiscStateData%q_minus2,2)
   IF (.NOT. ALLOCATED(DstDiscStateData%q_minus2)) THEN 
      ALLOCATE(DstDiscStateData%q_minus2(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstDiscStateData%q_minus2.', ErrStat, ErrMsg,'UA_CopyDiscState')
         RETURN
      END IF
   END IF
   DstDiscStateData%q_minus2 = SrcDiscStateData%q_minus2
ENDIF
IF (ALLOCATED(SrcDiscStateData%X1_minus1)) THEN
   i1_l = LBOUND(SrcDiscStateData%X1_minus1,1)
   i1_u = UBOUND(SrcDiscStateData%X1_minus1,1)
   i2_l = LBOUND(SrcDiscStateData%X1_minus1,2)
   i2_u = UBOUND(SrcDiscStateData%X1_minus1,2)
   IF (.NOT. ALLOCATED(DstDiscStateData%X1_minus1)) THEN 
      ALLOCATE(DstDiscStateData%X1_minus1(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstDiscStateData%X1_minus1.', ErrStat, ErrMsg,'UA_CopyDiscState')
         RETURN
      END IF
   END IF
   DstDiscStateData%X1_minus1 = SrcDiscStateData%X1_minus1
ENDIF
IF (ALLOCATED(SrcDiscStateData%X2_minus1)) THEN
   i1_l = LBOUND(SrcDiscStateData%X2_minus1,1)
   i1_u = UBOUND(SrcDiscStateData%X2_minus1,1)
   i2_l = LBOUND(SrcDiscStateData%X2_minus1,2)
   i2_u = UBOUND(SrcDiscStateData%X2_minus1,2)
   IF (.NOT. ALLOCATED(DstDiscStateData%X2_minus1)) THEN 
      ALLOCATE(DstDiscStateData%X2_minus1(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstDiscStateData%X2_minus1.', ErrStat, ErrMsg,'UA_CopyDiscState')
         RETURN
      END IF
   END IF
   DstDiscStateData%X2_minus1 = SrcDiscStateData%X2_minus1
ENDIF
IF (ALLOCATED(SrcDiscStateData%Kprime_alpha_minus1)) THEN
   i1_l = LBOUND(SrcDiscStateData%Kprime_alpha_minus1,1)
   i1_u = UBOUND(SrcDiscStateData%Kprime_alpha_minus1,1)
   i2_l = LBOUND(SrcDiscStateData%Kprime_alpha_minus1,2)
   i2_u = UBOUND(SrcDiscStateData%Kprime_alpha_minus1,2)
   IF (.NOT. ALLOCATED(DstDiscStateData%Kprime_alpha_minus1)) THEN 
      ALLOCATE(DstDiscStateData%Kprime_alpha_minus1(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstDiscStateData%Kprime_alpha_minus1.', ErrStat, ErrMsg,'UA_CopyDiscState')
         RETURN
      END IF
   END IF
   DstDiscStateData%Kprime_alpha_minus1 = SrcDiscStateData%Kprime_alpha_minus1
ENDIF
IF (ALLOCATED(SrcDiscStateData%Kprime_q_minus1)) THEN
   i1_l = LBOUND(SrcDiscStateData%Kprime_q_minus1,1)
   i1_u = UBOUND(SrcDiscStateData%Kprime_q_minus1,1)
   i2_l = LBOUND(SrcDiscStateData%Kprime_q_minus1,2)
   i2_u = UBOUND(SrcDiscStateData%Kprime_q_minus1,2)
   IF (.NOT. ALLOCATED(DstDiscStateData%Kprime_q_minus1)) THEN 
      ALLOCATE(DstDiscStateData%Kprime_q_minus1(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstDiscStateData%Kprime_q_minus1.', ErrStat, ErrMsg,'UA_CopyDiscState')
         RETURN
      END IF
   END IF
   DstDiscStateData%Kprime_q_minus1 = SrcDiscStateData%Kprime_q_minus1
ENDIF
IF (ALLOCATED(SrcDiscStateData%Kprimeprime_q_minus1)) THEN
   i1_l = LBOUND(SrcDiscStateData%Kprimeprime_q_minus1,1)
   i1_u = UBOUND(SrcDiscStateData%Kprimeprime_q_minus1,1)
   i2_l = LBOUND(SrcDiscStateData%Kprimeprime_q_minus1,2)
   i2_u = UBOUND(SrcDiscStateData%Kprimeprime_q_minus1,2)
   IF (.NOT. ALLOCATED(DstDiscStateData%Kprimeprime_q_minus1)) THEN 
      ALLOCATE(DstDiscStateData%Kprimeprime_q_minus1(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstDiscStateData%Kprimeprime_q_minus1.', ErrStat, ErrMsg,'UA_CopyDiscState')
         RETURN
      END IF
   END IF
   DstDiscStateData%Kprimeprime_q_minus1 = SrcDiscStateData%Kprimeprime_q_minus1
ENDIF
IF (ALLOCATED(SrcDiscStateData%K3prime_q_minus1)) THEN
   i1_l = LBOUND(SrcDiscStateData%K3prime_q_minus1,1)
   i1_u = UBOUND(SrcDiscStateData%K3prime_q_minus1,1)
   i2_l = LBOUND(SrcDiscStateData%K3prime_q_minus1,2)
   i2_u = UBOUND(SrcDiscStateData%K3prime_q_minus1,2)
   IF (.NOT. ALLOCATED(DstDiscStateData%K3prime_q_minus1)) THEN 
      ALLOCATE(DstDiscStateData%K3prime_q_minus1(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstDiscStateData%K3prime_q_minus1.', ErrStat, ErrMsg,'UA_CopyDiscState')
         RETURN
      END IF
   END IF
   DstDiscStateData%K3prime_q_minus1 = SrcDiscStateData%K3prime_q_minus1
ENDIF
IF (ALLOCATED(SrcDiscStateData%Dp_minus1)) THEN
   i1_l = LBOUND(SrcDiscStateData%Dp_minus1,1)
   i1_u = UBOUND(SrcDiscStateData%Dp_minus1,1)
   i2_l = LBOUND(SrcDiscStateData%Dp_minus1,2)
   i2_u = UBOUND(SrcDiscStateData%Dp_minus1,2)
   IF (.NOT. ALLOCATED(DstDiscStateData%Dp_minus1)) THEN 
      ALLOCATE(DstDiscStateData%Dp_minus1(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstDiscStateData%Dp_minus1.', ErrStat, ErrMsg,'UA_CopyDiscState')
         RETURN
      END IF
   END IF
   DstDiscStateData%Dp_minus1 = SrcDiscStateData%Dp_minus1
ENDIF
IF (ALLOCATED(SrcDiscStateData%Cn_pot_minus1)) THEN
   i1_l = LBOUND(SrcDiscStateData%Cn_pot_minus1,1)
   i1_u = UBOUND(SrcDiscStateData%Cn_pot_minus1,1)
   i2_l = LBOUND(SrcDiscStateData%Cn_pot_minus1,2)
   i2_u = UBOUND(SrcDiscStateData%Cn_pot_minus1,2)
   IF (.NOT. ALLOCATED(DstDiscStateData%Cn_pot_minus1)) THEN 
      ALLOCATE(DstDiscStateData%Cn_pot_minus1(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstDiscStateData%Cn_pot_minus1.', ErrStat, ErrMsg,'UA_CopyDiscState')
         RETURN
      END IF
   END IF
   DstDiscStateData%Cn_pot_minus1 = SrcDiscStateData%Cn_pot_minus1
ENDIF
IF (ALLOCATED(SrcDiscStateData%fprimeprime_minus1)) THEN
   i1_l = LBOUND(SrcDiscStateData%fprimeprime_minus1,1)
   i1_u = UBOUND(SrcDiscStateData%fprimeprime_minus1,1)
   i2_l = LBOUND(SrcDiscStateData%fprimeprime_minus1,2)
   i2_u = UBOUND(SrcDiscStateData%fprimeprime_minus1,2)
   IF (.NOT. ALLOCATED(DstDiscStateData%fprimeprime_minus1)) THEN 
      ALLOCATE(DstDiscStateData%fprimeprime_minus1(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstDiscStateData%fprimeprime_minus1.', ErrStat, ErrMsg,'UA_CopyDiscState')
         RETURN
      END IF
   END IF
   DstDiscStateData%fprimeprime_minus1 = SrcDiscStateData%fprimeprime_minus1
ENDIF
IF (ALLOCATED(SrcDiscStateData%Df_minus1)) THEN
   i1_l = LBOUND(SrcDiscStateData%Df_minus1,1)
   i1_u = UBOUND(SrcDiscStateData%Df_minus1,1)
   i2_l = LBOUND(SrcDiscStateData%Df_minus1,2)
   i2_u = UBOUND(SrcDiscStateData%Df_minus1,2)
   IF (.NOT. ALLOCATED(DstDiscStateData%Df_minus1)) THEN 
      ALLOCATE(DstDiscStateData%Df_minus1(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstDiscStateData%Df_minus1.', ErrStat, ErrMsg,'UA_CopyDiscState')
         RETURN
      END IF
   END IF
   DstDiscStateData%Df_minus1 = SrcDiscStateData%Df_minus1
ENDIF
IF (ALLOCATED(SrcDiscStateData%fprime_minus1)) THEN
   i1_l = LBOUND(SrcDiscStateData%fprime_minus1,1)
   i1_u = UBOUND(SrcDiscStateData%fprime_minus1,1)
   i2_l = LBOUND(SrcDiscStateData%fprime_minus1,2)
   i2_u = UBOUND(SrcDiscStateData%fprime_minus1,2)
   IF (.NOT. ALLOCATED(DstDiscStateData%fprime_minus1)) THEN 
      ALLOCATE(DstDiscStateData%fprime_minus1(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstDiscStateData%fprime_minus1.', ErrStat, ErrMsg,'UA_CopyDiscState')
         RETURN
      END IF
   END IF
   DstDiscStateData%fprime_minus1 = SrcDiscStateData%fprime_minus1
ENDIF
IF (ALLOCATED(SrcDiscStateData%tau_V)) THEN
   i1_l = LBOUND(SrcDiscStateData%tau_V,1)
   i1_u = UBOUND(SrcDiscStateData%tau_V,1)
   i2_l = LBOUND(SrcDiscStateData%tau_V,2)
   i2_u = UBOUND(SrcDiscStateData%tau_V,2)
   IF (.NOT. ALLOCATED(DstDiscStateData%tau_V)) THEN 
      ALLOCATE(DstDiscStateData%tau_V(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstDiscStateData%tau_V.', ErrStat, ErrMsg,'UA_CopyDiscState')
         RETURN
      END IF
   END IF
   DstDiscStateData%tau_V = SrcDiscStateData%tau_V
ENDIF
IF (ALLOCATED(SrcDiscStateData%Cn_v_minus1)) THEN
   i1_l = LBOUND(SrcDiscStateData%Cn_v_minus1,1)
   i1_u = UBOUND(SrcDiscStateData%Cn_v_minus1,1)
   i2_l = LBOUND(SrcDiscStateData%Cn_v_minus1,2)
   i2_u = UBOUND(SrcDiscStateData%Cn_v_minus1,2)
   IF (.NOT. ALLOCATED(DstDiscStateData%Cn_v_minus1)) THEN 
      ALLOCATE(DstDiscStateData%Cn_v_minus1(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstDiscStateData%Cn_v_minus1.', ErrStat, ErrMsg,'UA_CopyDiscState')
         RETURN
      END IF
   END IF
   DstDiscStateData%Cn_v_minus1 = SrcDiscStateData%Cn_v_minus1
ENDIF
IF (ALLOCATED(SrcDiscStateData%C_V_minus1)) THEN
   i1_l = LBOUND(SrcDiscStateData%C_V_minus1,1)
   i1_u = UBOUND(SrcDiscStateData%C_V_minus1,1)
   i2_l = LBOUND(SrcDiscStateData%C_V_minus1,2)
   i2_u = UBOUND(SrcDiscStateData%C_V_minus1,2)
   IF (.NOT. ALLOCATED(DstDiscStateData%C_V_minus1)) THEN 
      ALLOCATE(DstDiscStateData%C_V_minus1(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstDiscStateData%C_V_minus1.', ErrStat, ErrMsg,'UA_CopyDiscState')
         RETURN
      END IF
   END IF
   DstDiscStateData%C_V_minus1 = SrcDiscStateData%C_V_minus1
ENDIF
IF (ALLOCATED(SrcDiscStateData%Dfalpha_minus1)) THEN
   i1_l = LBOUND(SrcDiscStateData%Dfalpha_minus1,1)
   i1_u = UBOUND(SrcDiscStateData%Dfalpha_minus1,1)
   i2_l = LBOUND(SrcDiscStateData%Dfalpha_minus1,2)
   i2_u = UBOUND(SrcDiscStateData%Dfalpha_minus1,2)
   IF (.NOT. ALLOCATED(DstDiscStateData%Dfalpha_minus1)) THEN 
      ALLOCATE(DstDiscStateData%Dfalpha_minus1(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstDiscStateData%Dfalpha_minus1.', ErrStat, ErrMsg,'UA_CopyDiscState')
         RETURN
      END IF
   END IF
   DstDiscStateData%Dfalpha_minus1 = SrcDiscStateData%Dfalpha_minus1
ENDIF
 END SUBROUTINE UA_CopyDiscState

 SUBROUTINE UA_DestroyDiscState( DiscStateData, ErrStat, ErrMsg )
  TYPE(UA_DiscreteStateType), INTENT(INOUT) :: DiscStateData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
IF (ALLOCATED(DiscStateData%alpha_minus1)) THEN
   DEALLOCATE(DiscStateData%alpha_minus1)
ENDIF
IF (ALLOCATED(DiscStateData%alpha_minus2)) THEN
   DEALLOCATE(DiscStateData%alpha_minus2)
ENDIF
IF (ALLOCATED(DiscStateData%q_minus1)) THEN
   DEALLOCATE(DiscStateData%q_minus1)
ENDIF
IF (ALLOCATED(DiscStateData%q_minus2)) THEN
   DEALLOCATE(DiscStateData%q_minus2)
ENDIF
IF (ALLOCATED(DiscStateData%X1_minus1)) THEN
   DEALLOCATE(DiscStateData%X1_minus1)
ENDIF
IF (ALLOCATED(DiscStateData%X2_minus1)) THEN
   DEALLOCATE(DiscStateData%X2_minus1)
ENDIF
IF (ALLOCATED(DiscStateData%Kprime_alpha_minus1)) THEN
   DEALLOCATE(DiscStateData%Kprime_alpha_minus1)
ENDIF
IF (ALLOCATED(DiscStateData%Kprime_q_minus1)) THEN
   DEALLOCATE(DiscStateData%Kprime_q_minus1)
ENDIF
IF (ALLOCATED(DiscStateData%Kprimeprime_q_minus1)) THEN
   DEALLOCATE(DiscStateData%Kprimeprime_q_minus1)
ENDIF
IF (ALLOCATED(DiscStateData%K3prime_q_minus1)) THEN
   DEALLOCATE(DiscStateData%K3prime_q_minus1)
ENDIF
IF (ALLOCATED(DiscStateData%Dp_minus1)) THEN
   DEALLOCATE(DiscStateData%Dp_minus1)
ENDIF
IF (ALLOCATED(DiscStateData%Cn_pot_minus1)) THEN
   DEALLOCATE(DiscStateData%Cn_pot_minus1)
ENDIF
IF (ALLOCATED(DiscStateData%fprimeprime_minus1)) THEN
   DEALLOCATE(DiscStateData%fprimeprime_minus1)
ENDIF
IF (ALLOCATED(DiscStateData%Df_minus1)) THEN
   DEALLOCATE(DiscStateData%Df_minus1)
ENDIF
IF (ALLOCATED(DiscStateData%fprime_minus1)) THEN
   DEALLOCATE(DiscStateData%fprime_minus1)
ENDIF
IF (ALLOCATED(DiscStateData%tau_V)) THEN
   DEALLOCATE(DiscStateData%tau_V)
ENDIF
IF (ALLOCATED(DiscStateData%Cn_v_minus1)) THEN
   DEALLOCATE(DiscStateData%Cn_v_minus1)
ENDIF
IF (ALLOCATED(DiscStateData%C_V_minus1)) THEN
   DEALLOCATE(DiscStateData%C_V_minus1)
ENDIF
IF (ALLOCATED(DiscStateData%Dfalpha_minus1)) THEN
   DEALLOCATE(DiscStateData%Dfalpha_minus1)
ENDIF
 END SUBROUTINE UA_DestroyDiscState

 SUBROUTINE UA_PackDiscState( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(UA_DiscreteStateType),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  IF ( ALLOCATED(InData%alpha_minus1) )   Re_BufSz    = Re_BufSz    + SIZE( InData%alpha_minus1 )  ! alpha_minus1 
  IF ( ALLOCATED(InData%alpha_minus2) )   Re_BufSz    = Re_BufSz    + SIZE( InData%alpha_minus2 )  ! alpha_minus2 
  IF ( ALLOCATED(InData%q_minus1) )   Re_BufSz    = Re_BufSz    + SIZE( InData%q_minus1 )  ! q_minus1 
  IF ( ALLOCATED(InData%q_minus2) )   Re_BufSz    = Re_BufSz    + SIZE( InData%q_minus2 )  ! q_minus2 
  IF ( ALLOCATED(InData%X1_minus1) )   Re_BufSz    = Re_BufSz    + SIZE( InData%X1_minus1 )  ! X1_minus1 
  IF ( ALLOCATED(InData%X2_minus1) )   Re_BufSz    = Re_BufSz    + SIZE( InData%X2_minus1 )  ! X2_minus1 
  IF ( ALLOCATED(InData%Kprime_alpha_minus1) )   Re_BufSz    = Re_BufSz    + SIZE( InData%Kprime_alpha_minus1 )  ! Kprime_alpha_minus1 
  IF ( ALLOCATED(InData%Kprime_q_minus1) )   Re_BufSz    = Re_BufSz    + SIZE( InData%Kprime_q_minus1 )  ! Kprime_q_minus1 
  IF ( ALLOCATED(InData%Kprimeprime_q_minus1) )   Re_BufSz    = Re_BufSz    + SIZE( InData%Kprimeprime_q_minus1 )  ! Kprimeprime_q_minus1 
  IF ( ALLOCATED(InData%K3prime_q_minus1) )   Re_BufSz    = Re_BufSz    + SIZE( InData%K3prime_q_minus1 )  ! K3prime_q_minus1 
  IF ( ALLOCATED(InData%Dp_minus1) )   Re_BufSz    = Re_BufSz    + SIZE( InData%Dp_minus1 )  ! Dp_minus1 
  IF ( ALLOCATED(InData%Cn_pot_minus1) )   Re_BufSz    = Re_BufSz    + SIZE( InData%Cn_pot_minus1 )  ! Cn_pot_minus1 
  IF ( ALLOCATED(InData%fprimeprime_minus1) )   Re_BufSz    = Re_BufSz    + SIZE( InData%fprimeprime_minus1 )  ! fprimeprime_minus1 
  IF ( ALLOCATED(InData%Df_minus1) )   Re_BufSz    = Re_BufSz    + SIZE( InData%Df_minus1 )  ! Df_minus1 
  IF ( ALLOCATED(InData%fprime_minus1) )   Re_BufSz    = Re_BufSz    + SIZE( InData%fprime_minus1 )  ! fprime_minus1 
  IF ( ALLOCATED(InData%tau_V) )   Re_BufSz    = Re_BufSz    + SIZE( InData%tau_V )  ! tau_V 
  IF ( ALLOCATED(InData%Cn_v_minus1) )   Re_BufSz    = Re_BufSz    + SIZE( InData%Cn_v_minus1 )  ! Cn_v_minus1 
  IF ( ALLOCATED(InData%C_V_minus1) )   Re_BufSz    = Re_BufSz    + SIZE( InData%C_V_minus1 )  ! C_V_minus1 
  IF ( ALLOCATED(InData%Dfalpha_minus1) )   Re_BufSz    = Re_BufSz    + SIZE( InData%Dfalpha_minus1 )  ! Dfalpha_minus1 
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  IF ( ALLOCATED(InData%alpha_minus1) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%alpha_minus1))-1 ) =  PACK(InData%alpha_minus1 ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%alpha_minus1)
  ENDIF
  IF ( ALLOCATED(InData%alpha_minus2) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%alpha_minus2))-1 ) =  PACK(InData%alpha_minus2 ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%alpha_minus2)
  ENDIF
  IF ( ALLOCATED(InData%q_minus1) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%q_minus1))-1 ) =  PACK(InData%q_minus1 ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%q_minus1)
  ENDIF
  IF ( ALLOCATED(InData%q_minus2) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%q_minus2))-1 ) =  PACK(InData%q_minus2 ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%q_minus2)
  ENDIF
  IF ( ALLOCATED(InData%X1_minus1) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%X1_minus1))-1 ) =  PACK(InData%X1_minus1 ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%X1_minus1)
  ENDIF
  IF ( ALLOCATED(InData%X2_minus1) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%X2_minus1))-1 ) =  PACK(InData%X2_minus1 ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%X2_minus1)
  ENDIF
  IF ( ALLOCATED(InData%Kprime_alpha_minus1) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%Kprime_alpha_minus1))-1 ) =  PACK(InData%Kprime_alpha_minus1 ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%Kprime_alpha_minus1)
  ENDIF
  IF ( ALLOCATED(InData%Kprime_q_minus1) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%Kprime_q_minus1))-1 ) =  PACK(InData%Kprime_q_minus1 ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%Kprime_q_minus1)
  ENDIF
  IF ( ALLOCATED(InData%Kprimeprime_q_minus1) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%Kprimeprime_q_minus1))-1 ) =  PACK(InData%Kprimeprime_q_minus1 ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%Kprimeprime_q_minus1)
  ENDIF
  IF ( ALLOCATED(InData%K3prime_q_minus1) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%K3prime_q_minus1))-1 ) =  PACK(InData%K3prime_q_minus1 ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%K3prime_q_minus1)
  ENDIF
  IF ( ALLOCATED(InData%Dp_minus1) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%Dp_minus1))-1 ) =  PACK(InData%Dp_minus1 ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%Dp_minus1)
  ENDIF
  IF ( ALLOCATED(InData%Cn_pot_minus1) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%Cn_pot_minus1))-1 ) =  PACK(InData%Cn_pot_minus1 ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%Cn_pot_minus1)
  ENDIF
  IF ( ALLOCATED(InData%fprimeprime_minus1) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%fprimeprime_minus1))-1 ) =  PACK(InData%fprimeprime_minus1 ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%fprimeprime_minus1)
  ENDIF
  IF ( ALLOCATED(InData%Df_minus1) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%Df_minus1))-1 ) =  PACK(InData%Df_minus1 ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%Df_minus1)
  ENDIF
  IF ( ALLOCATED(InData%fprime_minus1) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%fprime_minus1))-1 ) =  PACK(InData%fprime_minus1 ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%fprime_minus1)
  ENDIF
  IF ( ALLOCATED(InData%tau_V) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%tau_V))-1 ) =  PACK(InData%tau_V ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%tau_V)
  ENDIF
  IF ( ALLOCATED(InData%Cn_v_minus1) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%Cn_v_minus1))-1 ) =  PACK(InData%Cn_v_minus1 ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%Cn_v_minus1)
  ENDIF
  IF ( ALLOCATED(InData%C_V_minus1) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%C_V_minus1))-1 ) =  PACK(InData%C_V_minus1 ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%C_V_minus1)
  ENDIF
  IF ( ALLOCATED(InData%Dfalpha_minus1) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%Dfalpha_minus1))-1 ) =  PACK(InData%Dfalpha_minus1 ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%Dfalpha_minus1)
  ENDIF
 END SUBROUTINE UA_PackDiscState

 SUBROUTINE UA_UnPackDiscState( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(UA_DiscreteStateType), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  IF ( ALLOCATED(OutData%alpha_minus1) ) THEN
  ALLOCATE(mask2(SIZE(OutData%alpha_minus1,1),SIZE(OutData%alpha_minus1,2)))
  mask2 = .TRUE.
    OutData%alpha_minus1 = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%alpha_minus1))-1 ),mask2,OutData%alpha_minus1)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%alpha_minus1)
  ENDIF
  IF ( ALLOCATED(OutData%alpha_minus2) ) THEN
  ALLOCATE(mask2(SIZE(OutData%alpha_minus2,1),SIZE(OutData%alpha_minus2,2)))
  mask2 = .TRUE.
    OutData%alpha_minus2 = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%alpha_minus2))-1 ),mask2,OutData%alpha_minus2)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%alpha_minus2)
  ENDIF
  IF ( ALLOCATED(OutData%q_minus1) ) THEN
  ALLOCATE(mask2(SIZE(OutData%q_minus1,1),SIZE(OutData%q_minus1,2)))
  mask2 = .TRUE.
    OutData%q_minus1 = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%q_minus1))-1 ),mask2,OutData%q_minus1)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%q_minus1)
  ENDIF
  IF ( ALLOCATED(OutData%q_minus2) ) THEN
  ALLOCATE(mask2(SIZE(OutData%q_minus2,1),SIZE(OutData%q_minus2,2)))
  mask2 = .TRUE.
    OutData%q_minus2 = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%q_minus2))-1 ),mask2,OutData%q_minus2)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%q_minus2)
  ENDIF
  IF ( ALLOCATED(OutData%X1_minus1) ) THEN
  ALLOCATE(mask2(SIZE(OutData%X1_minus1,1),SIZE(OutData%X1_minus1,2)))
  mask2 = .TRUE.
    OutData%X1_minus1 = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%X1_minus1))-1 ),mask2,OutData%X1_minus1)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%X1_minus1)
  ENDIF
  IF ( ALLOCATED(OutData%X2_minus1) ) THEN
  ALLOCATE(mask2(SIZE(OutData%X2_minus1,1),SIZE(OutData%X2_minus1,2)))
  mask2 = .TRUE.
    OutData%X2_minus1 = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%X2_minus1))-1 ),mask2,OutData%X2_minus1)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%X2_minus1)
  ENDIF
  IF ( ALLOCATED(OutData%Kprime_alpha_minus1) ) THEN
  ALLOCATE(mask2(SIZE(OutData%Kprime_alpha_minus1,1),SIZE(OutData%Kprime_alpha_minus1,2)))
  mask2 = .TRUE.
    OutData%Kprime_alpha_minus1 = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%Kprime_alpha_minus1))-1 ),mask2,OutData%Kprime_alpha_minus1)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%Kprime_alpha_minus1)
  ENDIF
  IF ( ALLOCATED(OutData%Kprime_q_minus1) ) THEN
  ALLOCATE(mask2(SIZE(OutData%Kprime_q_minus1,1),SIZE(OutData%Kprime_q_minus1,2)))
  mask2 = .TRUE.
    OutData%Kprime_q_minus1 = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%Kprime_q_minus1))-1 ),mask2,OutData%Kprime_q_minus1)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%Kprime_q_minus1)
  ENDIF
  IF ( ALLOCATED(OutData%Kprimeprime_q_minus1) ) THEN
  ALLOCATE(mask2(SIZE(OutData%Kprimeprime_q_minus1,1),SIZE(OutData%Kprimeprime_q_minus1,2)))
  mask2 = .TRUE.
    OutData%Kprimeprime_q_minus1 = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%Kprimeprime_q_minus1))-1 ),mask2,OutData%Kprimeprime_q_minus1)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%Kprimeprime_q_minus1)
  ENDIF
  IF ( ALLOCATED(OutData%K3prime_q_minus1) ) THEN
  ALLOCATE(mask2(SIZE(OutData%K3prime_q_minus1,1),SIZE(OutData%K3prime_q_minus1,2)))
  mask2 = .TRUE.
    OutData%K3prime_q_minus1 = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%K3prime_q_minus1))-1 ),mask2,OutData%K3prime_q_minus1)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%K3prime_q_minus1)
  ENDIF
  IF ( ALLOCATED(OutData%Dp_minus1) ) THEN
  ALLOCATE(mask2(SIZE(OutData%Dp_minus1,1),SIZE(OutData%Dp_minus1,2)))
  mask2 = .TRUE.
    OutData%Dp_minus1 = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%Dp_minus1))-1 ),mask2,OutData%Dp_minus1)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%Dp_minus1)
  ENDIF
  IF ( ALLOCATED(OutData%Cn_pot_minus1) ) THEN
  ALLOCATE(mask2(SIZE(OutData%Cn_pot_minus1,1),SIZE(OutData%Cn_pot_minus1,2)))
  mask2 = .TRUE.
    OutData%Cn_pot_minus1 = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%Cn_pot_minus1))-1 ),mask2,OutData%Cn_pot_minus1)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%Cn_pot_minus1)
  ENDIF
  IF ( ALLOCATED(OutData%fprimeprime_minus1) ) THEN
  ALLOCATE(mask2(SIZE(OutData%fprimeprime_minus1,1),SIZE(OutData%fprimeprime_minus1,2)))
  mask2 = .TRUE.
    OutData%fprimeprime_minus1 = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%fprimeprime_minus1))-1 ),mask2,OutData%fprimeprime_minus1)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%fprimeprime_minus1)
  ENDIF
  IF ( ALLOCATED(OutData%Df_minus1) ) THEN
  ALLOCATE(mask2(SIZE(OutData%Df_minus1,1),SIZE(OutData%Df_minus1,2)))
  mask2 = .TRUE.
    OutData%Df_minus1 = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%Df_minus1))-1 ),mask2,OutData%Df_minus1)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%Df_minus1)
  ENDIF
  IF ( ALLOCATED(OutData%fprime_minus1) ) THEN
  ALLOCATE(mask2(SIZE(OutData%fprime_minus1,1),SIZE(OutData%fprime_minus1,2)))
  mask2 = .TRUE.
    OutData%fprime_minus1 = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%fprime_minus1))-1 ),mask2,OutData%fprime_minus1)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%fprime_minus1)
  ENDIF
  IF ( ALLOCATED(OutData%tau_V) ) THEN
  ALLOCATE(mask2(SIZE(OutData%tau_V,1),SIZE(OutData%tau_V,2)))
  mask2 = .TRUE.
    OutData%tau_V = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%tau_V))-1 ),mask2,OutData%tau_V)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%tau_V)
  ENDIF
  IF ( ALLOCATED(OutData%Cn_v_minus1) ) THEN
  ALLOCATE(mask2(SIZE(OutData%Cn_v_minus1,1),SIZE(OutData%Cn_v_minus1,2)))
  mask2 = .TRUE.
    OutData%Cn_v_minus1 = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%Cn_v_minus1))-1 ),mask2,OutData%Cn_v_minus1)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%Cn_v_minus1)
  ENDIF
  IF ( ALLOCATED(OutData%C_V_minus1) ) THEN
  ALLOCATE(mask2(SIZE(OutData%C_V_minus1,1),SIZE(OutData%C_V_minus1,2)))
  mask2 = .TRUE.
    OutData%C_V_minus1 = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%C_V_minus1))-1 ),mask2,OutData%C_V_minus1)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%C_V_minus1)
  ENDIF
  IF ( ALLOCATED(OutData%Dfalpha_minus1) ) THEN
  ALLOCATE(mask2(SIZE(OutData%Dfalpha_minus1,1),SIZE(OutData%Dfalpha_minus1,2)))
  mask2 = .TRUE.
    OutData%Dfalpha_minus1 = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%Dfalpha_minus1))-1 ),mask2,OutData%Dfalpha_minus1)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%Dfalpha_minus1)
  ENDIF
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE UA_UnPackDiscState

 SUBROUTINE UA_CopyConstrState( SrcConstrStateData, DstConstrStateData, CtrlCode, ErrStat, ErrMsg )
   TYPE(UA_ConstraintStateType), INTENT(IN) :: SrcConstrStateData
   TYPE(UA_ConstraintStateType), INTENT(INOUT) :: DstConstrStateData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: i2, i2_l, i2_u  !  bounds (upper/lower) for an array dimension 2
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(1024)                :: ErrMsg2
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
   DstConstrStateData%DummyConstraintState = SrcConstrStateData%DummyConstraintState
 END SUBROUTINE UA_CopyConstrState

 SUBROUTINE UA_DestroyConstrState( ConstrStateData, ErrStat, ErrMsg )
  TYPE(UA_ConstraintStateType), INTENT(INOUT) :: ConstrStateData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
 END SUBROUTINE UA_DestroyConstrState

 SUBROUTINE UA_PackConstrState( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(UA_ConstraintStateType),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  Re_BufSz   = Re_BufSz   + 1  ! DummyConstraintState
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%DummyConstraintState )
  Re_Xferred   = Re_Xferred   + 1
 END SUBROUTINE UA_PackConstrState

 SUBROUTINE UA_UnPackConstrState( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(UA_ConstraintStateType), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  OutData%DummyConstraintState = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE UA_UnPackConstrState

 SUBROUTINE UA_CopyOtherState( SrcOtherStateData, DstOtherStateData, CtrlCode, ErrStat, ErrMsg )
   TYPE(UA_OtherStateType), INTENT(IN) :: SrcOtherStateData
   TYPE(UA_OtherStateType), INTENT(INOUT) :: DstOtherStateData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: i2, i2_l, i2_u  !  bounds (upper/lower) for an array dimension 2
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(1024)                :: ErrMsg2
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
IF (ALLOCATED(SrcOtherStateData%sigma1)) THEN
   i1_l = LBOUND(SrcOtherStateData%sigma1,1)
   i1_u = UBOUND(SrcOtherStateData%sigma1,1)
   i2_l = LBOUND(SrcOtherStateData%sigma1,2)
   i2_u = UBOUND(SrcOtherStateData%sigma1,2)
   IF (.NOT. ALLOCATED(DstOtherStateData%sigma1)) THEN 
      ALLOCATE(DstOtherStateData%sigma1(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstOtherStateData%sigma1.', ErrStat, ErrMsg,'UA_CopyOtherState')
         RETURN
      END IF
   END IF
   DstOtherStateData%sigma1 = SrcOtherStateData%sigma1
ENDIF
IF (ALLOCATED(SrcOtherStateData%sigma3)) THEN
   i1_l = LBOUND(SrcOtherStateData%sigma3,1)
   i1_u = UBOUND(SrcOtherStateData%sigma3,1)
   i2_l = LBOUND(SrcOtherStateData%sigma3,2)
   i2_u = UBOUND(SrcOtherStateData%sigma3,2)
   IF (.NOT. ALLOCATED(DstOtherStateData%sigma3)) THEN 
      ALLOCATE(DstOtherStateData%sigma3(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstOtherStateData%sigma3.', ErrStat, ErrMsg,'UA_CopyOtherState')
         RETURN
      END IF
   END IF
   DstOtherStateData%sigma3 = SrcOtherStateData%sigma3
ENDIF
IF (ALLOCATED(SrcOtherStateData%TESF)) THEN
   i1_l = LBOUND(SrcOtherStateData%TESF,1)
   i1_u = UBOUND(SrcOtherStateData%TESF,1)
   i2_l = LBOUND(SrcOtherStateData%TESF,2)
   i2_u = UBOUND(SrcOtherStateData%TESF,2)
   IF (.NOT. ALLOCATED(DstOtherStateData%TESF)) THEN 
      ALLOCATE(DstOtherStateData%TESF(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstOtherStateData%TESF.', ErrStat, ErrMsg,'UA_CopyOtherState')
         RETURN
      END IF
   END IF
   DstOtherStateData%TESF = SrcOtherStateData%TESF
ENDIF
IF (ALLOCATED(SrcOtherStateData%LESF)) THEN
   i1_l = LBOUND(SrcOtherStateData%LESF,1)
   i1_u = UBOUND(SrcOtherStateData%LESF,1)
   i2_l = LBOUND(SrcOtherStateData%LESF,2)
   i2_u = UBOUND(SrcOtherStateData%LESF,2)
   IF (.NOT. ALLOCATED(DstOtherStateData%LESF)) THEN 
      ALLOCATE(DstOtherStateData%LESF(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstOtherStateData%LESF.', ErrStat, ErrMsg,'UA_CopyOtherState')
         RETURN
      END IF
   END IF
   DstOtherStateData%LESF = SrcOtherStateData%LESF
ENDIF
IF (ALLOCATED(SrcOtherStateData%VRTX)) THEN
   i1_l = LBOUND(SrcOtherStateData%VRTX,1)
   i1_u = UBOUND(SrcOtherStateData%VRTX,1)
   i2_l = LBOUND(SrcOtherStateData%VRTX,2)
   i2_u = UBOUND(SrcOtherStateData%VRTX,2)
   IF (.NOT. ALLOCATED(DstOtherStateData%VRTX)) THEN 
      ALLOCATE(DstOtherStateData%VRTX(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstOtherStateData%VRTX.', ErrStat, ErrMsg,'UA_CopyOtherState')
         RETURN
      END IF
   END IF
   DstOtherStateData%VRTX = SrcOtherStateData%VRTX
ENDIF
   DstOtherStateData%FirstPass = SrcOtherStateData%FirstPass
   DstOtherStateData%iBladeNode = SrcOtherStateData%iBladeNode
   DstOtherStateData%iBlade = SrcOtherStateData%iBlade
 END SUBROUTINE UA_CopyOtherState

 SUBROUTINE UA_DestroyOtherState( OtherStateData, ErrStat, ErrMsg )
  TYPE(UA_OtherStateType), INTENT(INOUT) :: OtherStateData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
IF (ALLOCATED(OtherStateData%sigma1)) THEN
   DEALLOCATE(OtherStateData%sigma1)
ENDIF
IF (ALLOCATED(OtherStateData%sigma3)) THEN
   DEALLOCATE(OtherStateData%sigma3)
ENDIF
IF (ALLOCATED(OtherStateData%TESF)) THEN
   DEALLOCATE(OtherStateData%TESF)
ENDIF
IF (ALLOCATED(OtherStateData%LESF)) THEN
   DEALLOCATE(OtherStateData%LESF)
ENDIF
IF (ALLOCATED(OtherStateData%VRTX)) THEN
   DEALLOCATE(OtherStateData%VRTX)
ENDIF
 END SUBROUTINE UA_DestroyOtherState

 SUBROUTINE UA_PackOtherState( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(UA_OtherStateType),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  IF ( ALLOCATED(InData%sigma1) )   Re_BufSz    = Re_BufSz    + SIZE( InData%sigma1 )  ! sigma1 
  IF ( ALLOCATED(InData%sigma3) )   Re_BufSz    = Re_BufSz    + SIZE( InData%sigma3 )  ! sigma3 
  IF ( ALLOCATED(InData%TESF) )   Int_BufSz   = Int_BufSz   + SIZE( InData%TESF )  ! TESF 
  IF ( ALLOCATED(InData%LESF) )   Int_BufSz   = Int_BufSz   + SIZE( InData%LESF )  ! LESF 
  IF ( ALLOCATED(InData%VRTX) )   Int_BufSz   = Int_BufSz   + SIZE( InData%VRTX )  ! VRTX 
  Int_BufSz  = Int_BufSz  + 1  ! FirstPass
  Int_BufSz  = Int_BufSz  + 1  ! iBladeNode
  Int_BufSz  = Int_BufSz  + 1  ! iBlade
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  IF ( ALLOCATED(InData%sigma1) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%sigma1))-1 ) =  PACK(InData%sigma1 ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%sigma1)
  ENDIF
  IF ( ALLOCATED(InData%sigma3) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%sigma3))-1 ) =  PACK(InData%sigma3 ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%sigma3)
  ENDIF
  IF ( ALLOCATED(InData%TESF) ) THEN
    IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(SIZE(InData%TESF))-1 ) = TRANSFER( PACK(InData%TESF ,.TRUE.), IntKiBuf(1), 1)
    Int_Xferred   = Int_Xferred   + SIZE(InData%TESF)
  ENDIF
  IF ( ALLOCATED(InData%LESF) ) THEN
    IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(SIZE(InData%LESF))-1 ) = TRANSFER( PACK(InData%LESF ,.TRUE.), IntKiBuf(1), 1)
    Int_Xferred   = Int_Xferred   + SIZE(InData%LESF)
  ENDIF
  IF ( ALLOCATED(InData%VRTX) ) THEN
    IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(SIZE(InData%VRTX))-1 ) = TRANSFER( PACK(InData%VRTX ,.TRUE.), IntKiBuf(1), 1)
    Int_Xferred   = Int_Xferred   + SIZE(InData%VRTX)
  ENDIF
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = TRANSFER( (InData%FirstPass ), IntKiBuf(1), 1)
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%iBladeNode )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%iBlade )
  Int_Xferred   = Int_Xferred   + 1
 END SUBROUTINE UA_PackOtherState

 SUBROUTINE UA_UnPackOtherState( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(UA_OtherStateType), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  IF ( ALLOCATED(OutData%sigma1) ) THEN
  ALLOCATE(mask2(SIZE(OutData%sigma1,1),SIZE(OutData%sigma1,2)))
  mask2 = .TRUE.
    OutData%sigma1 = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%sigma1))-1 ),mask2,OutData%sigma1)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%sigma1)
  ENDIF
  IF ( ALLOCATED(OutData%sigma3) ) THEN
  ALLOCATE(mask2(SIZE(OutData%sigma3,1),SIZE(OutData%sigma3,2)))
  mask2 = .TRUE.
    OutData%sigma3 = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%sigma3))-1 ),mask2,OutData%sigma3)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%sigma3)
  ENDIF
  IF ( ALLOCATED(OutData%TESF) ) THEN
  ENDIF
  IF ( ALLOCATED(OutData%LESF) ) THEN
  ENDIF
  IF ( ALLOCATED(OutData%VRTX) ) THEN
  ENDIF
  OutData%iBladeNode = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%iBlade = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE UA_UnPackOtherState

 SUBROUTINE UA_CopyParam( SrcParamData, DstParamData, CtrlCode, ErrStat, ErrMsg )
   TYPE(UA_ParameterType), INTENT(IN) :: SrcParamData
   TYPE(UA_ParameterType), INTENT(INOUT) :: DstParamData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: i2, i2_l, i2_u  !  bounds (upper/lower) for an array dimension 2
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(1024)                :: ErrMsg2
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
   DstParamData%dt = SrcParamData%dt
IF (ALLOCATED(SrcParamData%c)) THEN
   i1_l = LBOUND(SrcParamData%c,1)
   i1_u = UBOUND(SrcParamData%c,1)
   i2_l = LBOUND(SrcParamData%c,2)
   i2_u = UBOUND(SrcParamData%c,2)
   IF (.NOT. ALLOCATED(DstParamData%c)) THEN 
      ALLOCATE(DstParamData%c(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%c.', ErrStat, ErrMsg,'UA_CopyParam')
         RETURN
      END IF
   END IF
   DstParamData%c = SrcParamData%c
ENDIF
   DstParamData%numBlades = SrcParamData%numBlades
   DstParamData%nNodesPerBlade = SrcParamData%nNodesPerBlade
   DstParamData%DSMod = SrcParamData%DSMod
   DstParamData%a_s = SrcParamData%a_s
   DstParamData%NumOuts = SrcParamData%NumOuts
   DstParamData%OutSwtch = SrcParamData%OutSwtch
   DstParamData%OutFmt = SrcParamData%OutFmt
   DstParamData%OutSFmt = SrcParamData%OutSFmt
   DstParamData%Delim = SrcParamData%Delim
   DstParamData%UnOutFile = SrcParamData%UnOutFile
 END SUBROUTINE UA_CopyParam

 SUBROUTINE UA_DestroyParam( ParamData, ErrStat, ErrMsg )
  TYPE(UA_ParameterType), INTENT(INOUT) :: ParamData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
IF (ALLOCATED(ParamData%c)) THEN
   DEALLOCATE(ParamData%c)
ENDIF
 END SUBROUTINE UA_DestroyParam

 SUBROUTINE UA_PackParam( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(UA_ParameterType),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  Db_BufSz   = Db_BufSz   + 1  ! dt
  IF ( ALLOCATED(InData%c) )   Re_BufSz    = Re_BufSz    + SIZE( InData%c )  ! c 
  Int_BufSz  = Int_BufSz  + 1  ! numBlades
  Int_BufSz  = Int_BufSz  + 1  ! nNodesPerBlade
  Int_BufSz  = Int_BufSz  + 1  ! DSMod
  Re_BufSz   = Re_BufSz   + 1  ! a_s
  Int_BufSz  = Int_BufSz  + 1  ! NumOuts
  Int_BufSz  = Int_BufSz  + 1  ! OutSwtch
!  missing buffer for OutFmt
!  missing buffer for OutSFmt
!  missing buffer for Delim
  Int_BufSz  = Int_BufSz  + 1  ! UnOutFile
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  IF ( .NOT. OnlySize ) DbKiBuf ( Db_Xferred:Db_Xferred+(1)-1 ) =  (InData%dt )
  Db_Xferred   = Db_Xferred   + 1
  IF ( ALLOCATED(InData%c) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%c))-1 ) =  PACK(InData%c ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%c)
  ENDIF
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%numBlades )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%nNodesPerBlade )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%DSMod )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%a_s )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%NumOuts )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%OutSwtch )
  Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. OnlySize ) IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = (InData%UnOutFile )
  Int_Xferred   = Int_Xferred   + 1
 END SUBROUTINE UA_PackParam

 SUBROUTINE UA_UnPackParam( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(UA_ParameterType), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  OutData%dt = DbKiBuf ( Db_Xferred )
  Db_Xferred   = Db_Xferred   + 1
  IF ( ALLOCATED(OutData%c) ) THEN
  ALLOCATE(mask2(SIZE(OutData%c,1),SIZE(OutData%c,2)))
  mask2 = .TRUE.
    OutData%c = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%c))-1 ),mask2,OutData%c)
  DEALLOCATE(mask2)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%c)
  ENDIF
  OutData%numBlades = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%nNodesPerBlade = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%DSMod = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%a_s = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%NumOuts = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%OutSwtch = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  OutData%UnOutFile = IntKiBuf ( Int_Xferred )
  Int_Xferred   = Int_Xferred   + 1
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE UA_UnPackParam

 SUBROUTINE UA_CopyInput( SrcInputData, DstInputData, CtrlCode, ErrStat, ErrMsg )
   TYPE(UA_InputType), INTENT(IN) :: SrcInputData
   TYPE(UA_InputType), INTENT(INOUT) :: DstInputData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: i2, i2_l, i2_u  !  bounds (upper/lower) for an array dimension 2
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(1024)                :: ErrMsg2
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
   DstInputData%U = SrcInputData%U
   DstInputData%alpha = SrcInputData%alpha
   DstInputData%Re = SrcInputData%Re
 END SUBROUTINE UA_CopyInput

 SUBROUTINE UA_DestroyInput( InputData, ErrStat, ErrMsg )
  TYPE(UA_InputType), INTENT(INOUT) :: InputData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
 END SUBROUTINE UA_DestroyInput

 SUBROUTINE UA_PackInput( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(UA_InputType),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  Re_BufSz   = Re_BufSz   + 1  ! U
  Re_BufSz   = Re_BufSz   + 1  ! alpha
  Re_BufSz   = Re_BufSz   + 1  ! Re
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%U )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%alpha )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%Re )
  Re_Xferred   = Re_Xferred   + 1
 END SUBROUTINE UA_PackInput

 SUBROUTINE UA_UnPackInput( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(UA_InputType), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  OutData%U = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%alpha = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%Re = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE UA_UnPackInput

 SUBROUTINE UA_CopyOutput( SrcOutputData, DstOutputData, CtrlCode, ErrStat, ErrMsg )
   TYPE(UA_OutputType), INTENT(IN) :: SrcOutputData
   TYPE(UA_OutputType), INTENT(INOUT) :: DstOutputData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: i2, i2_l, i2_u  !  bounds (upper/lower) for an array dimension 2
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(1024)                :: ErrMsg2
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
   DstOutputData%Cn = SrcOutputData%Cn
   DstOutputData%Cc = SrcOutputData%Cc
   DstOutputData%Cm = SrcOutputData%Cm
   DstOutputData%Cl = SrcOutputData%Cl
   DstOutputData%Cd = SrcOutputData%Cd
IF (ALLOCATED(SrcOutputData%WriteOutput)) THEN
   i1_l = LBOUND(SrcOutputData%WriteOutput,1)
   i1_u = UBOUND(SrcOutputData%WriteOutput,1)
   IF (.NOT. ALLOCATED(DstOutputData%WriteOutput)) THEN 
      ALLOCATE(DstOutputData%WriteOutput(i1_l:i1_u),STAT=ErrStat2)
      IF (ErrStat2 /= 0) THEN 
         CALL SetErrStat(ErrID_Fatal, 'Error allocating DstOutputData%WriteOutput.', ErrStat, ErrMsg,'UA_CopyOutput')
         RETURN
      END IF
   END IF
   DstOutputData%WriteOutput = SrcOutputData%WriteOutput
ENDIF
 END SUBROUTINE UA_CopyOutput

 SUBROUTINE UA_DestroyOutput( OutputData, ErrStat, ErrMsg )
  TYPE(UA_OutputType), INTENT(INOUT) :: OutputData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
IF (ALLOCATED(OutputData%WriteOutput)) THEN
   DEALLOCATE(OutputData%WriteOutput)
ENDIF
 END SUBROUTINE UA_DestroyOutput

 SUBROUTINE UA_PackOutput( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(UA_OutputType),  INTENT(INOUT) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
 ! buffers to store meshes, if any
  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  Re_BufSz   = Re_BufSz   + 1  ! Cn
  Re_BufSz   = Re_BufSz   + 1  ! Cc
  Re_BufSz   = Re_BufSz   + 1  ! Cm
  Re_BufSz   = Re_BufSz   + 1  ! Cl
  Re_BufSz   = Re_BufSz   + 1  ! Cd
  IF ( ALLOCATED(InData%WriteOutput) )   Re_BufSz    = Re_BufSz    + SIZE( InData%WriteOutput )  ! WriteOutput 
  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%Cn )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%Cc )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%Cm )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%Cl )
  Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%Cd )
  Re_Xferred   = Re_Xferred   + 1
  IF ( ALLOCATED(InData%WriteOutput) ) THEN
    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%WriteOutput))-1 ) =  PACK(InData%WriteOutput ,.TRUE.)
    Re_Xferred   = Re_Xferred   + SIZE(InData%WriteOutput)
  ENDIF
 END SUBROUTINE UA_PackOutput

 SUBROUTINE UA_UnPackOutput( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(UA_OutputType), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Re_CurrSz
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Db_CurrSz
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: Int_CurrSz
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
 ! buffers to store meshes, if any
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  OutData%Cn = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%Cc = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%Cm = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%Cl = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  OutData%Cd = ReKiBuf ( Re_Xferred )
  Re_Xferred   = Re_Xferred   + 1
  IF ( ALLOCATED(OutData%WriteOutput) ) THEN
  ALLOCATE(mask1(SIZE(OutData%WriteOutput,1)))
  mask1 = .TRUE.
    OutData%WriteOutput = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%WriteOutput))-1 ),mask1,OutData%WriteOutput)
  DEALLOCATE(mask1)
    Re_Xferred   = Re_Xferred   + SIZE(OutData%WriteOutput)
  ENDIF
  Re_Xferred   = Re_Xferred-1
  Db_Xferred   = Db_Xferred-1
  Int_Xferred  = Int_Xferred-1
 END SUBROUTINE UA_UnPackOutput


 SUBROUTINE UA_Input_ExtrapInterp(u, tin, u_out, tin_out, ErrStat, ErrMsg )
!
! This subroutine calculates a extrapolated (or interpolated) input u_out at time t_out, from previous/future time
! values of u (which has values associated with times in t).  Order of the interpolation is given by the size of u
!
!  expressions below based on either
!
!  f(t) = a
!  f(t) = a + b * t, or
!  f(t) = a + b * t + c * t**2
!
!  where a, b and c are determined as the solution to
!  f(t1) = u1, f(t2) = u2, f(t3) = u3  (as appropriate)
!
!..................................................................................................................................

 TYPE(UA_inputtype), INTENT(INOUT)  :: u(:)      ! Inputs at t1 > t2 > t3
 REAL(DbKi),         INTENT(IN   )  :: tin(:)      ! Times associated with the inputs
 TYPE(UA_inputtype), INTENT(INOUT)  :: u_out     ! Inputs at tin_out
 REAL(DbKi),         INTENT(IN   )  :: tin_out     ! time to be extrap/interp'd to
 INTEGER(IntKi),     INTENT(  OUT)  :: ErrStat   ! Error status of the operation
 CHARACTER(*),       INTENT(  OUT)  :: ErrMsg    ! Error message if ErrStat /= ErrID_None
   ! local variables
 REAL(DbKi) :: t(SIZE(tin))    ! Times associated with the inputs
 REAL(DbKi) :: t_out           ! Time to which to be extrap/interpd
 INTEGER(IntKi)                 :: order    ! order of polynomial fit (max 2)
 REAL(DbKi)                                 :: b0       ! temporary for extrapolation/interpolation
 REAL(DbKi)                                 :: c0       ! temporary for extrapolation/interpolation
 INTEGER(IntKi)                             :: ErrStat2 ! local errors
 CHARACTER(1024)                            :: ErrMsg2  ! local errors
    ! Initialize ErrStat
 ErrStat = ErrID_None
 ErrMsg  = ""
    ! we'll subtract a constant from the times to resolve some 
    ! numerical issues when t gets large (and to simplify the equations)
 t = tin - tin(1)
 t_out = tin_out - tin(1)

 if ( size(t) .ne. size(u)) then
    ErrStat = ErrID_Fatal
    ErrMsg = ' Error in UA_Input_ExtrapInterp: size(t) must equal size(u) '
    RETURN
 endif
 if (size(u) .gt. 3) then
    ErrStat = ErrID_Fatal
    ErrMsg  = ' Error in UA_Input_ExtrapInterp: size(u) must be less than 4 '
    RETURN
 endif
 order = SIZE(u) - 1
 IF ( order .eq. 0 ) THEN
  u_out%U = u(1)%U
  u_out%alpha = u(1)%alpha
  u_out%Re = u(1)%Re
 ELSE IF ( order .eq. 1 ) THEN
  IF ( EqualRealNos( t(1), t(2) ) ) THEN
    ErrStat = ErrID_Fatal
    ErrMsg  = ' Error in UA_Input_ExtrapInterp: t(1) must not equal t(2) to avoid a division-by-zero error.'
    RETURN
  END IF
  b0 = -(u(1)%U - u(2)%U)/t(2)
  u_out%U = u(1)%U + b0 * t_out
  b0 = -(u(1)%alpha - u(2)%alpha)/t(2)
  u_out%alpha = u(1)%alpha + b0 * t_out
  b0 = -(u(1)%Re - u(2)%Re)/t(2)
  u_out%Re = u(1)%Re + b0 * t_out
 ELSE IF ( order .eq. 2 ) THEN
  IF ( EqualRealNos( t(1), t(2) ) ) THEN
    ErrStat = ErrID_Fatal
    ErrMsg  = ' Error in UA_Input_ExtrapInterp: t(1) must not equal t(2) to avoid a division-by-zero error.'
    RETURN
  END IF
  IF ( EqualRealNos( t(2), t(3) ) ) THEN
    ErrStat = ErrID_Fatal
    ErrMsg  = ' Error in UA_Input_ExtrapInterp: t(2) must not equal t(3) to avoid a division-by-zero error.'
    RETURN
  END IF
  IF ( EqualRealNos( t(1), t(3) ) ) THEN
    ErrStat = ErrID_Fatal
    ErrMsg  = ' Error in UA_Input_ExtrapInterp: t(1) must not equal t(3) to avoid a division-by-zero error.'
    RETURN
  END IF
  b0 = (t(3)**2*(u(1)%U - u(2)%U) + t(2)**2*(-u(1)%U + u(3)%U))/(t(2)*t(3)*(t(2) - t(3)))
  c0 = ( (t(2)-t(3))*u(1)%U + t(3)*u(2)%U - t(2)*u(3)%U ) / (t(2)*t(3)*(t(2) - t(3)))
  u_out%U = u(1)%U + b0 * t_out + c0 * t_out**2
  b0 = (t(3)**2*(u(1)%alpha - u(2)%alpha) + t(2)**2*(-u(1)%alpha + u(3)%alpha))/(t(2)*t(3)*(t(2) - t(3)))
  c0 = ( (t(2)-t(3))*u(1)%alpha + t(3)*u(2)%alpha - t(2)*u(3)%alpha ) / (t(2)*t(3)*(t(2) - t(3)))
  u_out%alpha = u(1)%alpha + b0 * t_out + c0 * t_out**2
  b0 = (t(3)**2*(u(1)%Re - u(2)%Re) + t(2)**2*(-u(1)%Re + u(3)%Re))/(t(2)*t(3)*(t(2) - t(3)))
  c0 = ( (t(2)-t(3))*u(1)%Re + t(3)*u(2)%Re - t(2)*u(3)%Re ) / (t(2)*t(3)*(t(2) - t(3)))
  u_out%Re = u(1)%Re + b0 * t_out + c0 * t_out**2
 ELSE 
   ErrStat = ErrID_Fatal
   ErrMsg = ' order must be less than 3 in UA_Input_ExtrapInterp '
   RETURN
 ENDIF 
 END SUBROUTINE UA_Input_ExtrapInterp


 SUBROUTINE UA_Output_ExtrapInterp(u, tin, u_out, tin_out, ErrStat, ErrMsg )
!
! This subroutine calculates a extrapolated (or interpolated) input u_out at time t_out, from previous/future time
! values of u (which has values associated with times in t).  Order of the interpolation is given by the size of u
!
!  expressions below based on either
!
!  f(t) = a
!  f(t) = a + b * t, or
!  f(t) = a + b * t + c * t**2
!
!  where a, b and c are determined as the solution to
!  f(t1) = u1, f(t2) = u2, f(t3) = u3  (as appropriate)
!
!..................................................................................................................................

 TYPE(UA_outputtype), INTENT(INOUT)  :: u(:)      ! Inputs at t1 > t2 > t3
 REAL(DbKi),         INTENT(IN   )  :: tin(:)      ! Times associated with the inputs
 TYPE(UA_outputtype), INTENT(INOUT)  :: u_out     ! Inputs at tin_out
 REAL(DbKi),         INTENT(IN   )  :: tin_out     ! time to be extrap/interp'd to
 INTEGER(IntKi),     INTENT(  OUT)  :: ErrStat   ! Error status of the operation
 CHARACTER(*),       INTENT(  OUT)  :: ErrMsg    ! Error message if ErrStat /= ErrID_None
   ! local variables
 REAL(DbKi) :: t(SIZE(tin))    ! Times associated with the inputs
 REAL(DbKi) :: t_out           ! Time to which to be extrap/interpd
 INTEGER(IntKi)                 :: order    ! order of polynomial fit (max 2)
 REAL(DbKi)                                 :: b0       ! temporary for extrapolation/interpolation
 REAL(DbKi)                                 :: c0       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:)        :: b1       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:)        :: c1       ! temporary for extrapolation/interpolation
 INTEGER(IntKi)                             :: ErrStat2 ! local errors
 CHARACTER(1024)                            :: ErrMsg2  ! local errors
    ! Initialize ErrStat
 ErrStat = ErrID_None
 ErrMsg  = ""
    ! we'll subtract a constant from the times to resolve some 
    ! numerical issues when t gets large (and to simplify the equations)
 t = tin - tin(1)
 t_out = tin_out - tin(1)

 if ( size(t) .ne. size(u)) then
    ErrStat = ErrID_Fatal
    ErrMsg = ' Error in UA_Output_ExtrapInterp: size(t) must equal size(u) '
    RETURN
 endif
 if (size(u) .gt. 3) then
    ErrStat = ErrID_Fatal
    ErrMsg  = ' Error in UA_Output_ExtrapInterp: size(u) must be less than 4 '
    RETURN
 endif
 order = SIZE(u) - 1
 IF ( order .eq. 0 ) THEN
  u_out%Cn = u(1)%Cn
  u_out%Cc = u(1)%Cc
  u_out%Cm = u(1)%Cm
  u_out%Cl = u(1)%Cl
  u_out%Cd = u(1)%Cd
IF (ALLOCATED(u_out%WriteOutput) .AND. ALLOCATED(u(1)%WriteOutput)) THEN
  u_out%WriteOutput = u(1)%WriteOutput
END IF ! check if allocated
 ELSE IF ( order .eq. 1 ) THEN
  IF ( EqualRealNos( t(1), t(2) ) ) THEN
    ErrStat = ErrID_Fatal
    ErrMsg  = ' Error in UA_Output_ExtrapInterp: t(1) must not equal t(2) to avoid a division-by-zero error.'
    RETURN
  END IF
  b0 = -(u(1)%Cn - u(2)%Cn)/t(2)
  u_out%Cn = u(1)%Cn + b0 * t_out
  b0 = -(u(1)%Cc - u(2)%Cc)/t(2)
  u_out%Cc = u(1)%Cc + b0 * t_out
  b0 = -(u(1)%Cm - u(2)%Cm)/t(2)
  u_out%Cm = u(1)%Cm + b0 * t_out
  b0 = -(u(1)%Cl - u(2)%Cl)/t(2)
  u_out%Cl = u(1)%Cl + b0 * t_out
  b0 = -(u(1)%Cd - u(2)%Cd)/t(2)
  u_out%Cd = u(1)%Cd + b0 * t_out
IF (ALLOCATED(u_out%WriteOutput) .AND. ALLOCATED(u(1)%WriteOutput)) THEN
  ALLOCATE(b1(SIZE(u_out%WriteOutput,1)))
  ALLOCATE(c1(SIZE(u_out%WriteOutput,1)))
  b1 = -(u(1)%WriteOutput - u(2)%WriteOutput)/t(2)
  u_out%WriteOutput = u(1)%WriteOutput + b1 * t_out
  DEALLOCATE(b1)
  DEALLOCATE(c1)
END IF ! check if allocated
 ELSE IF ( order .eq. 2 ) THEN
  IF ( EqualRealNos( t(1), t(2) ) ) THEN
    ErrStat = ErrID_Fatal
    ErrMsg  = ' Error in UA_Output_ExtrapInterp: t(1) must not equal t(2) to avoid a division-by-zero error.'
    RETURN
  END IF
  IF ( EqualRealNos( t(2), t(3) ) ) THEN
    ErrStat = ErrID_Fatal
    ErrMsg  = ' Error in UA_Output_ExtrapInterp: t(2) must not equal t(3) to avoid a division-by-zero error.'
    RETURN
  END IF
  IF ( EqualRealNos( t(1), t(3) ) ) THEN
    ErrStat = ErrID_Fatal
    ErrMsg  = ' Error in UA_Output_ExtrapInterp: t(1) must not equal t(3) to avoid a division-by-zero error.'
    RETURN
  END IF
  b0 = (t(3)**2*(u(1)%Cn - u(2)%Cn) + t(2)**2*(-u(1)%Cn + u(3)%Cn))/(t(2)*t(3)*(t(2) - t(3)))
  c0 = ( (t(2)-t(3))*u(1)%Cn + t(3)*u(2)%Cn - t(2)*u(3)%Cn ) / (t(2)*t(3)*(t(2) - t(3)))
  u_out%Cn = u(1)%Cn + b0 * t_out + c0 * t_out**2
  b0 = (t(3)**2*(u(1)%Cc - u(2)%Cc) + t(2)**2*(-u(1)%Cc + u(3)%Cc))/(t(2)*t(3)*(t(2) - t(3)))
  c0 = ( (t(2)-t(3))*u(1)%Cc + t(3)*u(2)%Cc - t(2)*u(3)%Cc ) / (t(2)*t(3)*(t(2) - t(3)))
  u_out%Cc = u(1)%Cc + b0 * t_out + c0 * t_out**2
  b0 = (t(3)**2*(u(1)%Cm - u(2)%Cm) + t(2)**2*(-u(1)%Cm + u(3)%Cm))/(t(2)*t(3)*(t(2) - t(3)))
  c0 = ( (t(2)-t(3))*u(1)%Cm + t(3)*u(2)%Cm - t(2)*u(3)%Cm ) / (t(2)*t(3)*(t(2) - t(3)))
  u_out%Cm = u(1)%Cm + b0 * t_out + c0 * t_out**2
  b0 = (t(3)**2*(u(1)%Cl - u(2)%Cl) + t(2)**2*(-u(1)%Cl + u(3)%Cl))/(t(2)*t(3)*(t(2) - t(3)))
  c0 = ( (t(2)-t(3))*u(1)%Cl + t(3)*u(2)%Cl - t(2)*u(3)%Cl ) / (t(2)*t(3)*(t(2) - t(3)))
  u_out%Cl = u(1)%Cl + b0 * t_out + c0 * t_out**2
  b0 = (t(3)**2*(u(1)%Cd - u(2)%Cd) + t(2)**2*(-u(1)%Cd + u(3)%Cd))/(t(2)*t(3)*(t(2) - t(3)))
  c0 = ( (t(2)-t(3))*u(1)%Cd + t(3)*u(2)%Cd - t(2)*u(3)%Cd ) / (t(2)*t(3)*(t(2) - t(3)))
  u_out%Cd = u(1)%Cd + b0 * t_out + c0 * t_out**2
IF (ALLOCATED(u_out%WriteOutput) .AND. ALLOCATED(u(1)%WriteOutput)) THEN
  ALLOCATE(b1(SIZE(u_out%WriteOutput,1)))
  ALLOCATE(c1(SIZE(u_out%WriteOutput,1)))
  b1 = (t(3)**2*(u(1)%WriteOutput - u(2)%WriteOutput) + t(2)**2*(-u(1)%WriteOutput + u(3)%WriteOutput))/(t(2)*t(3)*(t(2) - t(3)))
  c1 = ( (t(2)-t(3))*u(1)%WriteOutput + t(3)*u(2)%WriteOutput - t(2)*u(3)%WriteOutput ) / (t(2)*t(3)*(t(2) - t(3)))
  u_out%WriteOutput = u(1)%WriteOutput + b1 * t_out + c1 * t_out**2
  DEALLOCATE(b1)
  DEALLOCATE(c1)
END IF ! check if allocated
 ELSE 
   ErrStat = ErrID_Fatal
   ErrMsg = ' order must be less than 3 in UA_Output_ExtrapInterp '
   RETURN
 ENDIF 
 END SUBROUTINE UA_Output_ExtrapInterp

END MODULE UnsteadyAero_Types
!ENDOFREGISTRYGENERATEDFILE
